     1                                  ; OZ - A more utopian OS
     2                                  ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
     3                                  ;
     4                                  ;
     5                                  ;       x86-32 startup 
     6                                  ;
     7                                  ;
     8                                  ; usage:
     9                                  ;	$ qemu-system-i386 -boot a -fda oz_fd.img
    10                                  ;
    11                                  ; requires: nasm-2.07  or later from: http://www.nasm.us
    12                                  ;
    13                                  ; contributors:
    14                                  ;        djv - Duane Voth
    15                                  ;
    16                                  ; history:
    17                                  ; 2007/03/03 - 0.00.01 - djv - begin with various web examples
    18                                  ;                      http://linuxgazette.net/issue82/misc/raghu/code.asm.txt
    19                                  ;                      http://www.osdever.net/tutorials/brunmar/simple_asm.txt
    20                                  ; 2007/03/04 - 0.00.02 - djv - add timer interrupt support with stray int dbg
    21                                  ; 2007/03/05 - 0.00.03 - djv - remove stray int dbg, add mbr data struc back
    22                                  ; 2007/03/11 - 0.00.04 - djv - debug USB boot problem
    23                                  ; 2007/03/28 - 0.01.00 - djv - add a real-mode stage2 loader in the mbr to
    24                                  ;                              load the sectors past the mbr on the boot
    25                                  ;                              device into the memory behind the mbr.  so even
    26                                  ;                              tho the read from the device happens in two
    27                                  ;                              parts, memory contains a linear image of the
    28                                  ;                              first few sectors of the boot device.
    29                                  ; 2009/02/01 - 0.02.00 - djv - begin to define application and dynamic library
    30                                  ;                              binary formats with headers detailing size and
    31                                  ;                              entry points.
    32                                  ; 2009/08/01 - 0.03.00 - djv - create the OZ app execution container using
    33                                  ;                              TSSes, paging, and rings 0 and 3.  begin to
    34                                  ;                              play with system calls.
    35                                  ; 2015/10/07 - 0.03.01 - djv - cleanup, add smp usermode tss structs, sleep,
    36                                  ;                              wakeup, and ipi for user thread creation.
    37                                  
    38                                  %ifdef USB
    39                                  [map symbols oz_usb.map]
    40                                  %else
    41                                  [map symbols oz_fd.map]
    42                                  %endif
    43                                  
    44                                  ; -------- stage 1 ---------------------------------------------------------
    45                                  ; A classic x86 Master Boot Record
    46                                  
    47                                  section .text start=0x7c00  ; PC BIOS boot loader entry point
    48                                  textstart :
    49                                  
    50                                  bios_entry :
    51 00000000 FA                          cli
    52 00000001 EB21                        jmp short load_stage2   ; jump to stage2 loader, skip mbr data struct
    53                                  
    54 00000003 00<rept>                times 6-($-$$)  db 0
    55 00000006 6F7A                    oemid db "oz"
    56                                  
    57 00000008 00<rept>                times 11-($-$$)  db 0
    58                                  
    59                                  ; compute the size of the kernel image in 512 byte sectors
    60                                  total_size equ (kernel_text_size + kernel_data_size)
    61                                  kisectors  equ (total_size)/512 + (APP_SIZE + 512)/512
    62                                  ; compute the end of the kernel image (with apps attached)
    63                                  kilast equ 0x7c00 + kisectors * 512
    64                                  
    65                                  ; MS MBR  (http://support.microsoft.com/kb/140418)
    66                                  %ifdef FLOPPY
    67                                      dw 512                  ; Bytes per sector
    68                                      db 1                    ; Sectors per cluster
    69                                      dw kisectors            ; Number of reserved sectors
    70                                      db 2                    ; Number of FATs
    71                                      dw 0x00e0               ; Number of dirs in root
    72                                      dw 0x0b40               ; Number of sectors in volume
    73                                      db 0xf0                 ; Media descriptor
    74                                      dw 9                    ; Number of sectors per FAT
    75                                      dw 18                   ; Number of sectors per track
    76                                      dw 2                    ; Number of heads
    77                                      dd 0                    ; Number of hidden sectors
    78                                      dd 0                    ; Large Sectors
    79                                  %endif
    80                                  
    81                                  %ifdef USB
    82 0000000B 0000                        dw 0                    ; Bytes per sector
    83 0000000D 00                          db 0                    ; Sectors per cluster
    84 0000000E 3A00                        dw kisectors            ; Number of reserved sectors
    85 00000010 00                          db 0                    ; Number of FATs
    86 00000011 0000                        dw 0                    ; Number of dirs in root
    87 00000013 0000                        dw 0                    ; Number of sectors in volume
    88 00000015 00                          db 0                    ; Media descriptor
    89 00000016 0000                        dw 0                    ; Number of sectors per FAT
    90 00000018 0000                        dw 0                    ; Number of sectors per track
    91 0000001A 0000                        dw 0                    ; Number of heads
    92 0000001C 00000000                    dd 0                    ; Number of hidden sectors
    93 00000020 00000000                    dd 0                    ; Large Sectors
    94                                  %endif
    95                                  
    96                                  ; -------- stage 2 loader ------------
    97                                  bits 16
    98                                  alignb 2
    99                                  
   100                                  load_stage2 :
   101 00000024 52                          push dx                 ; save BIOS drive number
   102                                  
   103 00000025 B80006                      mov  ax,0x0600          ; ah=6 scroll window up, if al = 0 clrscr
   104 00000028 B90000                      mov  cx,0x0000          ; clear window from 0,0 
   105 0000002B BA4F17                      mov  dx,0x174f          ; to 23,79
   106 0000002E B70F                        mov  bh,0xf             ; fill with hi white
   107 00000030 CD10                        int  0x10               ; clear screen for direct writes to video memory
   108                                  
   109 00000032 BE[A500]                    mov  si,bootmsg
   110 00000035 31DB                        xor  bx,bx
   111 00000037 E85700                      call puts_vga_rm
   112                                                              ; puts_vga_rm leaves gs pointing at video mem
   113 0000003A 65C60601000E                mov  byte [gs:1],0xE    ; turn the first two chars yellow
   114 00000040 65C60603000E                mov  byte [gs:3],0xE
   115                                  
   116                                      ;F - white              
   117                                      ;E - yellow             
   118                                      ;D - magenta            
   119                                      ;C - red                
   120                                      ;B - cyan               
   121                                      ;A - green              
   122                                      ;9 - blue               
   123                                      ;8 - dark grey          
   124                                  
   125 00000046 A1[0002]                    mov  ax,[stage2]         ; check the signature byte
   126 00000049 0306[0202]                  add  ax,[stage2+2]
   127 0000004D 3DA17A                      cmp  ax,0x7a6f+0x32
   128 00000050 741D                        jz   stage2_present
   129                                  
   130                                      ; -------- stage2 boot loader --------
   131                                  
   132                                      ; Assume that the kernel is smaller than whatever space
   133                                      ; is provided prior to file system data structures on the
   134                                      ; boot device, and that it can immediately follow the MBR.
   135                                  
   136 00000052 B402                        mov  ah,02h
   137 00000054 B039                        mov  al,kisectors-1     ; number of sectors to load
   138 00000056 BB[0002]                    mov  bx,stage2
   139 00000059 B90200                      mov  cx,2
   140 0000005C 5A                          pop  dx                 ; recover BIOS drive number
   141 0000005D 0E                          push cs
   142 0000005E 07                          pop  es
   143 0000005F CD13                        int  13h
   144 00000061 7211                        jc   ioerr
   145                                  
   146                                      ; ---- make sure second stage actually got loaded
   147                                  
   148 00000063 A1[0002]                    mov  ax,[stage2]        ; check the signature byte
   149 00000066 0306[0202]                  add  ax,[stage2+2]
   150 0000006A 3DA17A                      cmp  ax,0x7a6f+0x32
   151 0000006D 750A                        jnz  s2err
   152                                  stage2_present :
   153 0000006F EA[0902]0000                jmp  0:start_stage2     ; use an absolute jump so stage 1
   154                                                              ; can be position independent
   155                                  
   156                                  ioerr :                     ; ah has status...
   157 00000074 BE[D500]                    mov  si,ioerrmsg
   158 00000077 EB03                        jmp  print_err
   159                                  
   160                                  s2err :
   161 00000079 BE[BF00]                    mov  si,s2errmsg
   162                                  print_err :
   163 0000007C BBA000                      mov  bx,160
   164 0000007F E80F00                      call puts_vga_rm
   165 00000082 65C60601000C                mov  byte [gs:1],0xC    ; turn the first two vga chars red
   166 00000088 65C60603000C                mov  byte [gs:3],0xC
   167                                  
   168                                  hang :
   169 0000008E F4                          hlt
   170 0000008F EBFD                        jmp  hang
   171                                  
   172                                  ; ----------------------------
   173                                  ;   puts_vga_rm - write a null delimited string to the VGA controller
   174                                  ;                 in real mode
   175                                  ;
   176                                  ;    enter:
   177                                  ;            esi - address of string
   178                                  ;            ebx - screen location (2 bytes per char, 160 bytes per line)
   179                                  ;    exit:
   180                                  ;            eax - destroyed
   181                                  ;             gs - set to video memory selector
   182                                  
   183                                  puts_vga_rm :
   184 00000091 B800B8                      mov  ax,0xb800      ; point gs at video memory
   185 00000094 8EE8                        mov  gs,ax          
   186                                  puts_vga_rm_loop :
   187 00000096 AC                          lodsb
   188 00000097 3C00                        cmp  al,0
   189 00000099 7409                        jz   puts_vga_rm_done
   190 0000009B 658807                      mov  [gs:bx],al
   191 0000009E 6683C302                    add  ebx,2
   192 000000A2 EBF2                        jmp  puts_vga_rm_loop
   193                                  puts_vga_rm_done :
   194 000000A4 C3                          ret
   195                                  
   196 000000A5 4F5A2076302E30332E-     bootmsg     db      "OZ v0.03.01 - 2015/10/07 ",0
   197 000000AE 3031202D2032303135-
   198 000000B7 2F31302F30372000   
   199 000000BF 73746167652032206C-     s2errmsg    db      "stage 2 load failure ",0
   200 000000C8 6F6164206661696C75-
   201 000000D1 72652000           
   202 000000D5 692F6F206572726F72-     ioerrmsg    db      "i/o error loading stage 2 ",0
   203 000000DE 206C6F6164696E6720-
   204 000000E7 737461676520322000 
   205                                  
   206 000000F0 00<rept>                times 446-($-$$) db 0       ; fill with zeros up to partition table
   207                                  
   208                                  tmpstk      equ     $
   209                                  
   210                                  ; If the kernel is loaded from a disk (including usb) the MBR
   211                                  ; must include a partition table based on the device geometry.
   212                                  ; This gets fed into oz.asm here via usbptbl.inc
   213                                  %ifdef USB
   214                                  %include "usbptbl.inc"
   215 000001BE 80000200060FFEFD    <1> db 0x80,0x00,0x02,0x00,0x06,0x0f,0xfe,0xfd
   216 000001C6 010000003F780F00    <1> db 0x01,0x00,0x00,0x00,0x3f,0x78,0x0f,0x00
   217 000001CE 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   218 000001D6 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   219 000001DE 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   220 000001E6 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   221 000001EE 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   222 000001F6 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   223                                  %else
   224                                      ; If the kernel is placed in memory by some other means
   225                                      ; (PXE, pxelinux, etc.) the partition table is irrelevant
   226                                      ; but the space is still required.  Make the default ptbl
   227                                      ; match a 1.44MB floppy.
   228                                      db 0x80,0x01,0x01,0x00,0x06,0x01,0x12,0x4f
   229                                      db 0x12,0x00,0x00,0x00,0x2e,0x0b,0x00,0x00
   230                                      db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   231                                      db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   232                                      db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   233                                  %endif
   234                                  
   235                                  %ifdef NEWUSB
   236                                  new usb?  gpt correct?
   237                                  0000 01B0: 00 00 00 00 00 2C 44 63  E0 36 03 00 00 00 80 20  .....,Dc .6.....
   238                                  0000 01C0: 21 00 83 9D 11 4C 00 08  00 00 00 C0 12 00 00 9D  !....L.. ........
   239                                  0000 01D0: 12 4C 83 57 25 F2 00 C8  12 00 00 A0 28 00 00 00  .L.W%... ....(...
   240                                  0000 01E0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ........ ........
   241                                  0000 01F0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 AA  ........ ......U.
   242                                  %endif
   243                                  
   244                                  
   245                                  times 510-($-$$) db 0       ; fill with zeros up to MBR signature
   246                                  
   247 000001FE 55AA                                dw 0x0aa55      ; write aa55 in bytes 511,512 to indicate
   248                                                              ; that it is a boot sector. 
   249                                  
   250                                  ; end of MBR
   251                                  ;
   252                                  ; -------- stage 2 ---------------------------------------------------------
   253                                  ;
   254                                  ; If a boot loader only loads 512 bytes in the first pass, the following
   255                                  ; code won't appear in memory until the code above has completed.  Other
   256                                  ; loaders however can load the entire OZ kernel image into memory in one
   257                                  ; shot.
   258                                  
   259                                  bits 16
   260                                  
   261                                  stage2 :
   262 00000200 6F7A3200                    db "oz2",0                      ; stage2 signature
   263                                  
   264                                  non_boot_cpu_ljmp_instruction :     ; place this in 16 bit code land
   265 00000204 EA00000000                  jmp word 0:0                    ; so we get the right opcode
   266                                  
   267                                  kstack_loc  equ 0x1000      ; must be on a 4k pysical page boundary
   268                                  kstack_size equ 4096*2
   269                                  
   270                                  pgdir equ 0x3000            ; use some of the free memory below us
   271                                  pgtb0 equ 0x4000            ; code below assumes this follows pgdir
   272                                  pgtb1 equ 0x5000            ; code below assumes this follows pgtb0
   273                                  
   274                                  idt   equ 0x7000            ; use some of the free memory below us
   275                                  
   276                                  ; ---------------------
   277                                  
   278                                  start_stage2 :
   279                                  
   280 00000209 B80030                      mov  ax,kstack_loc+kstack_size  ; setup the kernel stack
   281 0000020C 89C4                        mov  sp,ax
   282                                  
   283                                      ; ---- initialize the 8259's while in real mode
   284                                  
   285 0000020E E84305                      call irq_init_hardware
   286                                  
   287                                  ; ------------ main kernel entry point ------------
   288                                  ; all cpus enter here
   289                                  main :
   290                                  
   291                                      ; -------- enter protected mode --------
   292                                  
   293 00000211 0F0116[0803]                lgdt [gdtr]             ; initialize the gdt
   294 00000216 0F20C0                      mov  eax,cr0
   295 00000219 0C01                        or   al,0x01            ; set the protected mode bit (lsb of cr0)
   296 0000021B 0F22C0                      mov  cr0,eax
   297 0000021E EA[2302]0800                jmp  codesel:flush_ip1  ; flush the cpu instruction pipeline
   298                                  flush_ip1: 
   299                                  bits 32                     ; instructions after this point are 32bit
   300                                  
   301 00000223 B801000000                  mov  eax,1
   302 00000228 0FC105[14030000]            xadd [ncpus],eax        ; get our unique cpu number
   303                                                              ; could use the lapic id if available
   304 0000022F 89C6                        mov  esi,eax
   305 00000231 66B81000                    mov  ax,datasel   
   306 00000235 8ED8                        mov  ds,ax              ; initialize the data segments
   307 00000237 8EC0                        mov  es,ax
   308 00000239 66B81800                    mov  ax,stacksel        ; setup a restricted stack segment
   309 0000023D 8ED0                        mov  ss,ax
   310 0000023F BC00200000                  mov  esp,kstack_size
   311 00000244 89F0                        mov  eax,esi
   312 00000246 C1E008                      shl  eax,8              ; divvy up the stack, 256 bytes per cpu
   313 00000249 29C4                        sub  esp,eax
   314                                  
   315 0000024B 89F0                        mov  eax,esi
   316 0000024D 50                          push eax
   317 0000024E 89C3                        mov  ebx,eax
   318 00000250 80C330                      add  bl,'0'             ; boot cpu announces via ascii 0
   319 00000253 BF9E000000                  mov  edi,160-2          ; last chracter on first line of vga
   320 00000258 D1E0                        shl  eax,1
   321 0000025A 29C7                        sub  edi,eax
   322 0000025C 66B82000                    mov  ax,videosel        ; point gs at video memory
   323 00000260 8EE8                        mov  gs,ax
   324 00000262 65881F                      mov  [gs:edi],bl        ; announce cpu presence
   325 00000265 58                          pop  eax
   326                                  
   327 00000266 09C0                        or   eax,eax            ; are we the boot cpu?
   328 00000268 0F8F4E010000                jg   non_boot_init      ; if not, do non_boot_init
   329                                  
   330 0000026E E80A050000                  call irq_init_bsp_apic_hardware
   331                                  
   332                                      ; ---- debug marker
   333 00000273 65C605010000000A            mov  byte [gs:1],0xA    ; turn the first two chars green
   334 0000027B 65C605030000000A            mov  byte [gs:3],0xA
   335                                  
   336                                      ; ---- build the interrupt descriptor table
   337                                  
   338 00000283 BE[E40C0000]                mov  esi,irq_setup_table
   339 00000288 B900010000                  mov  ecx,irq_setup_table_size
   340 0000028D BA00700000                  mov  edx,idt
   341                                  irq_init :
   342 00000292 31C0                        xor  eax,eax
   343 00000294 8902                        mov  [edx],eax                  ; clear the idt entry
   344 00000296 894202                      mov  [edx+2],eax
   345 00000299 66AD                        lodsw
   346 0000029B 6689C3                      mov  bx,ax
   347 0000029E 6625FCFF                    and  ax,strict 0xfffc           ; separate config flags
   348 000002A2 6683E303                    and  bx,3                       ; from selector/offset value
   349 000002A6 6683FB02                    cmp  bx,irqt_task               ; task gates are different
   350 000002AA 7407                        jz   irq_init_task_gate
   351 000002AC 668902                      mov  [edx],ax                   ; store the handler offset
   352 000002AF 66B80800                    mov  ax,codesel
   353                                  irq_init_task_gate :
   354 000002B3 66894202                    mov  word [edx+2],ax
   355 000002B7 678AA7[E00C]                mov  ah,byte [bx+irq_types]
   356 000002BC 30C0                        xor  al,al
   357 000002BE 66894204                    mov  word [edx+4],ax
   358 000002C2 83C208                      add  edx,8
   359 000002C5 E2CB                        loop irq_init
   360                                  
   361 000002C7 0F011D[0E030000]            lidt [idtr]                     ; install the idt
   362                                  
   363                                      ; ---- setup entry point for non_boot_cpus
   364                                  
   365 000002CE A0[04020000]                mov  al,[non_boot_cpu_ljmp_instruction]     ; get the ljmp instruction
   366 000002D3 A200100000                  mov  [kstack_loc],al                        ; place it at a 4k phys mem boundary
   367 000002D8 C70501100000-               mov  dword [kstack_loc+1],main
   368 000002DE [11020000]         
   369                                  
   370                                      ; ---- setup the paging tables
   371                                  
   372 000002E2 BF00300000                  mov  edi,pgdir          ; first the page directory
   373 000002E7 0F22DF                      mov  cr3,edi            ; install the page directory
   374 000002EA B807400000                  mov  eax,pgtb0 + 7      ; page table 0: present, pl=3, r/w
   375 000002EF AB                          stosd                   ; ... pl=3 for now (simplify vga access)
   376 000002F0 B807500000                  mov  eax,pgtb1 + 7      ; page table 1: present, pl=3, r/w
   377 000002F5 AB                          stosd                   ; ... app memory
   378 000002F6 31C0                        xor  eax,eax            ; invalidate the rest of the app laddr space
   379 000002F8 B9FE030000                  mov  ecx,0x400-2        ; (yeah, only one pgdir for kernel+apps for now)
   380 000002FD F3AB                        rep stosd
   381                                  
   382                                              ; assume pgtb0 physically follows the pg dir
   383                                              ; pgtb0 is the page table for kernel memory
   384                                  
   385 000002FF AB                          stosd                   ; access to page 0 will always cause a fault
   386 00000300 B803100000                  mov  eax,0x1000 + 3     ; rest are direct map: present, pl=0, r/w
   387 00000305 B9FF030000                  mov  ecx,0x400-1
   388                                  pgtb0_fill :
   389 0000030A AB                          stosd
   390 0000030B 0500100000                  add  eax,0x1000
   391 00000310 E2F8                        loop pgtb0_fill
   392                                  
   393                                              ; assume pgtb1 physically follows pgtb0
   394                                              ; pgtb1 is the first page table for app code/data/stack
   395                                  
   396 00000312 31C0                        xor  eax,eax            ; invalidate the app logical address space
   397 00000314 B900040000                  mov  ecx,0x400          ; (we'll fill in what we need later)
   398 00000319 F3AB                        rep stosd
   399                                  
   400                                              ; enable paging
   401                                  
   402 0000031B 0F20C0                      mov  eax,cr0
   403 0000031E 0D00000080                  or   eax,0x80000000     ; msb of cr0
   404 00000323 0F22C0                      mov  cr0,eax
   405 00000326 EB00                        jmp  flush_ip2          ; flush the cpu instruction pipeline
   406                                  flush_ip2: 
   407                                  
   408                                              ; establish a "pool" of free pyhsical memory
   409                                  
   410 00000328 B810000000                  mov  eax,((kilast+0x1000) >> 12)    ; include a buffer zone
   411 0000032D A3[19030000]                mov  [next_free_page],eax
   412                                  
   413                                              ; if enabled, create page table entry for the lapic
   414                                  
   415 00000332 A0[18030000]                mov  al,[enabled_lapic]
   416 00000337 08C0                        or   al,al
   417 00000339 740F                        jz   no_lapic_init
   418                                  
   419 0000033B BA0000E0FE                  mov  edx,0xfee00000     ; phys address
   420 00000340 B900100000                  mov  ecx,0x1000         ; length
   421 00000345 E8490C0000                  call map_pmem
   422                                  
   423                                  no_lapic_init :
   424                                  
   425                                      ; ---- establish a current task
   426                                  
   427 0000034A 31C0                        xor  eax,eax
   428 0000034C B050                        mov  al,tasksel_k00
   429 0000034E 0F00D8                      ltr  ax
   430                                  
   431                                      ; ---- check for init apps
   432                                  
   433 00000351 BB[E0000000]                mov  ebx, kend
   434                                  app_loop :
   435 00000356 8B4318                      mov  eax, [ebx+0x18]    ; load the entry address
   436 00000359 813B6F7A6170                cmp  dword [ebx], 0x70617a6f  ; check for "ozap"
   437 0000035F 7402                        jz   have_an_app
   438 00000361 31C0                        xor  eax, eax           ; no app
   439                                  have_an_app :
   440                                  
   441 00000363 83F800                      cmp  eax, 0             ; is there an app to run?
   442 00000366 0F848E000000                jz   idle               ; if not, idle right away
   443                                  
   444                                      ; ---- setup the init task entry point
   445                                  
   446 0000036C BF[C0020000]                mov  edi,tss1_eip
   447 00000371 AB                          stosd
   448                                  
   449                                      ; cheat: reuse the same tss, ldt, and page tables for all
   450                                      ; the init apps - this means they run serialy - each has
   451                                      ; to exit for the next one to run
   452                                  
   453 00000372 31C0                        xor   eax,eax
   454 00000374 A3[A0020000]                mov   [tss1],eax        ; clear out previous task link
   455 00000379 AB                          stosd                   ; and some registers (flags)
   456 0000037A AB                          stosd                   ; (eax)
   457 0000037B AB                          stosd                   ; (ecx)
   458 0000037C AB                          stosd                   ; (edx)
   459 0000037D AB                          stosd                   ; (ebx)
   460 0000037E 8B4310                      mov   eax, [ebx+0x10]   ; get the end of the app
   461                                      ;add   eax,0x8001000     ; (this tests app stack page faults)
   462 00000381 AB                          stosd                   ; (esp)
   463 00000382 31C0                        xor   eax,eax
   464 00000384 AB                          stosd                   ; (ebp)
   465 00000385 AB                          stosd                   ; (esi)
   466 00000386 AB                          stosd                   ; (edi)
   467                                  
   468 00000387 BF00500000                  mov  edi,pgtb1          ; rewrite the app's page table
   469 0000038C 89D8                        mov  eax,ebx
   470 0000038E 83C805                      or   eax,5              ; init app code at 0x400000 (4Mb) present and r/o
   471 00000391 AB                          stosd                   ; assume all the init apps are < 4k
   472 00000392 0502100000                  add  eax,0x1000 + 2     ; add one page for data/bss/stack
   473 00000397 AB                          stosd
   474                                  
   475                                      ; ---- start the app
   476                                  
   477 00000398 53                          push ebx
   478 00000399 FB                          sti
   479 0000039A 9A000000005800              call tasksel_u00:0
   480 000003A1 5B                          pop  ebx
   481                                  
   482                                      ; ---- point to the end of this init app
   483                                  
   484 000003A2 0F013D00004000              invlpg [0x400000]       ; FIXME 80386 needs to reload cr3
   485 000003A9 0F013D00104000              invlpg [0x401000]
   486                                  
   487 000003B0 8B4310                      mov  eax, [ebx+0x10]    ; load the app end address
   488 000003B3 2D00004000                  sub  eax,0x400000
   489 000003B8 01C3                        add  ebx,eax            ; point ebx to the next app
   490 000003BA EB9A                        jmp  app_loop
   491                                  
   492                                  ; -------- non-boot cpu initialization --------
   493                                  
   494                                  non_boot_init :
   495                                  
   496 000003BC 0F011D[0E030000]            lidt [idtr]             ; install the global idt
   497                                  
   498                                      ; ---- enable paging
   499                                  
   500 000003C3 BF00300000                  mov  edi,pgdir          ; load this cpu's paging register
   501 000003C8 0F22DF                      mov  cr3,edi
   502                                  
   503 000003CB 50                          push eax
   504 000003CC 0F20C0                      mov  eax,cr0            ; enable paging
   505 000003CF 0D00000080                  or   eax,0x80000000
   506 000003D4 0F22C0                      mov  cr0,eax
   507 000003D7 EB00                        jmp  flush_ip3          ; flush the cpu instruction pipeline
   508                                  flush_ip3 : 
   509 000003D9 58                          pop  eax
   510                                  
   511                                      ; ---- limit the number of cpus we support here
   512                                  
   513 000003DA 83F810                      cmp  eax,16
   514 000003DD 7317                        jae  nb_idle
   515                                  
   516                                      ; ---- init the lapic
   517                                  
   518 000003DF E8F0030000                  call irq_init_ap_apic_hardware
   519                                  
   520                                      ; setup smbase?
   521                                  
   522                                      ; ---- establish a current task
   523                                  
   524 000003E4 89C3                        mov  ebx,eax            ; move cpu number to ebx
   525 000003E6 E885000000                  call create_tss_pair
   526 000003EB 53                          push ebx
   527 000003EC C1E304                      shl  ebx,4              ; 16x (selector size x2)
   528 000003EF 83C350                      add  ebx,tasksel_k00
   529 000003F2 0F00DB                      ltr  bx                 ; establish a current task
   530 000003F5 5B                          pop  ebx
   531                                  
   532                                      ; test kernel page fault handler
   533                                      ;mov  [321],eax
   534                                  
   535                                  nb_idle :
   536 000003F6 FB                          sti
   537 000003F7 F4                          hlt                     ; wait for something to do
   538 000003F8 EBFC                        jmp  nb_idle            ; (see new_thread)
   539                                  
   540                                      ; -------- boot cpu idle task --------
   541                                      ; could be combined with nb_idle but separating
   542                                      ; these can allow for easier debug
   543                                  
   544                                  idle :
   545 000003FA FB                          sti
   546 000003FB F4                          hlt                     ; wait for interrupts
   547 000003FC EBFC                        jmp  idle
   548                                  
   549                                  
   550                                  ; ----------------------------
   551                                  ;    puts_vga - write a null delimited string to the VGA controller
   552                                  ;               in protected mode
   553                                  ;    enter:
   554                                  ;         esi - address of string
   555                                  ;         ebx - screen location (2 bytes per char, 160 bytes per line)
   556                                  ;    exit:
   557                                  ;         eax - destroyed
   558                                  ;         ebx - next screen location
   559                                  ;          gs - set to video memory selector
   560                                  bits 32
   561                                  
   562                                  puts_vga :
   563 000003FE 66B82000                    mov  ax,videosel        ; point gs at video memory
   564 00000402 8EE8                        mov  gs,ax
   565                                  puts_vga_loop :
   566 00000404 2E8A06                      mov  al,[cs:esi]        ; use cs so irq handlers don't
   567 00000407 46                          inc  esi                ; have to load kernel ds
   568 00000408 3C00                        cmp  al,0
   569 0000040A 7408                        jz   puts_vga_done
   570 0000040C 658803                      mov  [gs:ebx],al
   571 0000040F 83C302                      add  ebx,2
   572 00000412 EBF0                        jmp  puts_vga_loop
   573                                  puts_vga_done :
   574 00000414 C3                          ret
   575                                  
   576                                  ; ----------------------------
   577                                  ;   putx_vga - write the contents of eax in hex to the VGA controller
   578                                  ;              (in protected mode)
   579                                  ;   putbx_vga - write the contents of al in hex to the VGA controller
   580                                  ;
   581                                  ;   enter:
   582                                  ;       eax - value to convert to hex
   583                                  ;       ebx - screen location (2 bytes per char, 160 bytes per line)
   584                                  ;   exit:
   585                                  ;       ebx - next screen location
   586                                  ;        gs - set to video memory selector
   587                                  bits 32
   588                                  
   589                                  putbx_vga :
   590 00000415 51                          push ecx
   591 00000416 B902000000                  mov  ecx,2
   592 0000041B 25FF000000                  and  eax,0xff
   593 00000420 C1C018                      rol  eax,24
   594 00000423 EB06                        jmp putx_vga_loop
   595                                  
   596                                  putx_vga :
   597 00000425 51                          push ecx
   598 00000426 B908000000                  mov  ecx,8
   599                                  putx_vga_loop :
   600 0000042B C1C004                      rol  eax,4
   601 0000042E 50                          push eax
   602 0000042F 240F                        and  al,0xf
   603 00000431 3C09                        cmp  al,9
   604 00000433 7704                        ja   putx_vga_hexdigit
   605 00000435 0430                        add  al,'0'
   606 00000437 EB02                        jmp short putx_vga_putc
   607                                  putx_vga_hexdigit :
   608 00000439 0457                        add  al,'a'-10
   609                                  putx_vga_putc :
   610 0000043B 658803                      mov  [gs:ebx],al
   611 0000043E 83C302                      add  ebx,2
   612 00000441 58                          pop  eax
   613 00000442 83E0F0                      and  eax,0xfffffff0
   614 00000445 E2E4                        loop putx_vga_loop
   615 00000447 65C60320                    mov  byte [gs:ebx],' '
   616 0000044B 83C302                      add  ebx,2
   617 0000044E 59                          pop  ecx
   618 0000044F C3                          ret
   619                                  
   620                                  ;------------------------------------------------------------------
   621                                  ;   mem_alloc_kernel_page - return the 4k page number of 1 page of memory
   622                                  ;                           from the kernel page pool
   623                                  ;
   624                                  ;   returns:    eax = page number, zero means no pages left
   625                                  
   626                                  mem_alloc_kernel_page :
   627 00000450 A1[19030000]                mov  eax,[next_free_page]
   628 00000455 FF05[19030000]              inc  dword [next_free_page]
   629                                      ; probably should check for the end of something ...
   630 0000045B 50                          push eax
   631 0000045C 51                          push ecx
   632 0000045D 57                          push edi
   633 0000045E C1E00C                      shl  eax,12
   634 00000461 B900040000                  mov  ecx,0x1000/4
   635 00000466 89C7                        mov  edi,eax
   636 00000468 31C0                        xor  eax,eax
   637 0000046A F3AB                        rep stosd                   ; zero the page
   638 0000046C 5F                          pop  edi
   639 0000046D 59                          pop  ecx
   640 0000046E 58                          pop  eax
   641 0000046F C3                          ret
   642                                  
   643                                  ;------------------------------------------------------------------
   644                                  ;   create a pair of tss structs for a new cpu
   645                                  ;
   646                                  ;   enter:
   647                                  ;       ebx - cpu number
   648                                  ;   exit:
   649                                  ;       ebx - cpu number
   650                                  
   651                                  create_tss_pair :
   652 00000470 E8DBFFFFFF                  call mem_alloc_kernel_page
   653 00000475 09C0                        or   eax,eax
   654 00000477 0F8495000000                jz   create_tss_pair_fail
   655 0000047D C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   656 00000480 89C7                        mov  edi,eax
   657                                  
   658 00000482 89FE                        mov  esi,edi
   659 00000484 83C668                      add  esi,(tss0_end-tss0)
   660                                  
   661 00000487 B800300000                  mov  eax,pgdir
   662 0000048C 89471C                      mov  [edi+(tss0_cr3-tss0)],eax
   663 0000048F 89461C                      mov  [esi+(tss0_cr3-tss0)],eax
   664                                  
   665 00000492 B817000000                  mov  eax,datasel1+7
   666 00000497 894648                      mov  [esi+(tss0_es-tss0)],eax
   667 0000049A 894650                      mov  [esi+(tss0_ss-tss0)],eax
   668 0000049D 894654                      mov  [esi+(tss0_ds-tss0)],eax
   669 000004A0 B80F000000                  mov  eax,codesel1+7
   670 000004A5 89464C                      mov  [esi+(tss0_cs-tss0)],eax
   671 000004A8 B83B000000                  mov  eax,ldtsel1+3
   672 000004AD 894660                      mov  [esi+(tss0_ldt-tss0)],eax
   673                                  
   674                                      ; setup the tss structs (edi = kernel, esi = user).
   675                                      ; there are three stacks total
   676                                      ;   (1) kernel tss esp0 - placed at the end of this page
   677                                      ;   (2) user tss esp0 (for interrupt handling) - end minus 1k
   678                                      ;   (3) user tss esp3 (esp) - will be set up by new_thread
   679                                  
   680 000004B0 89F8                        mov  eax,edi
   681 000004B2 0500100000                  add  eax,0x1000
   682 000004B7 894704                      mov  [edi+(tss0_esp0-tss0)],eax ; (1) kernel tss esp0
   683 000004BA 2D00040000                  sub  eax,0x400
   684 000004BF 894604                      mov  [esi+(tss0_esp0-tss0)],eax ; (2) user tss esp0
   685                                      ;mov  eax,stacksel
   686 000004C2 B810000000                  mov  eax,datasel
   687 000004C7 894708                      mov  [edi+(tss0_ss0-tss0)],eax
   688 000004CA 894608                      mov  [esi+(tss0_ss0-tss0)],eax
   689                                  
   690                                      ; patch the tss addresses into the reserved gdt selectors
   691                                  
   692 000004CD 89DA                        mov  edx,ebx
   693 000004CF C1E204                      shl  edx,4                      ; 16x because selectors are in pairs
   694 000004D2 83C250                      add  edx,tasksel_k00
   695                                  
   696 000004D5 89F8                        mov  eax,edi
   697 000004D7 C1E818                      shr  eax,24
   698 000004DA 8882[07000000]              mov  byte [gdt+edx+7],al        ; base 24-32
   699 000004E0 81E7FFFFFF00                and  edi,0xffffff
   700 000004E6 0BBA[02000000]              or   edi,[gdt+edx+2]            ; or in flags
   701 000004EC 89BA[02000000]              mov  [gdt+edx+2],edi            ; base 0-23 and flags
   702                                  
   703 000004F2 83C208                      add  edx,8                      ; move to tasksel_uxx
   704                                  
   705 000004F5 89F0                        mov  eax,esi
   706 000004F7 C1E818                      shr  eax,24
   707 000004FA 8882[07000000]              mov  byte [gdt+edx+7],al        ; base 24-32
   708 00000500 81E6FFFFFF00                and  esi,0xffffff
   709 00000506 0BB2[02000000]              or   esi,[gdt+edx+2]            ; or in flags
   710 0000050C 89B2[02000000]              mov  [gdt+edx+2],esi            ; base 0-23 and flags
   711                                  
   712                                  create_tss_pair_fail :
   713 00000512 C3                          ret
   714                                  
   715                                  ; -------- interrupt handlers --------
   716                                  %include "ozirq.asm"
   717                              <1> ; OZ - A more utopian OS
   718                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
   719                              <1> ;
   720                              <1> ; IRQ handling
   721                              <1> 
   722 00000513 63707500            <1> cpumsg      db      "cpu",0
   723                              <1> 
   724 00000517 646976696465206279- <1> int00msg    db      "divide by zero ",0
   725 00000520 207A65726F2000      <1>
   726 00000527 646562756720657863- <1> int01msg    db      "debug exception ",0
   727 00000530 657074696F6E2000    <1>
   728 00000538 6E6D692000          <1> int02msg    db      "nmi ",0
   729 0000053D 627265616B706F696E- <1> int03msg    db      "breakpoint exception ",0
   730 00000546 742065786365707469- <1>
   731 0000054F 6F6E2000            <1>
   732 00000553 6F766572666C6F7720- <1> int04msg    db      "overflow exception ",0
   733 0000055C 657863657074696F6E- <1>
   734 00000565 2000                <1>
   735 00000567 626F756E6420657863- <1> int05msg    db      "bound exceeded ",0
   736 00000570 65656465642000      <1>
   737 00000577 696E76616C6964206F- <1> int06msg    db      "invalid opcode ",0
   738 00000580 70636F64652000      <1>
   739 00000587 64657669636520756E- <1> int07msg    db      "device unavailable ",0
   740 00000590 617661696C61626C65- <1>
   741 00000599 2000                <1>
   742 0000059B 646F75626C65206661- <1> int08msg    db      "double fault ",0
   743 000005A4 756C742000          <1>
   744 000005A9 636F70726F63657373- <1> int09msg    db      "coprocessor segment overrun ",0
   745 000005B2 6F72207365676D656E- <1>
   746 000005BB 74206F76657272756E- <1>
   747 000005C4 2000                <1>
   748 000005C6 696E76616C69642074- <1> int10msg    db      "invalid tss ",0
   749 000005CF 73732000            <1>
   750 000005D3 7365676D656E74206E- <1> int11msg    db      "segment not present ",0
   751 000005DC 6F742070726573656E- <1>
   752 000005E5 742000              <1>
   753 000005E8 737461636B20666175- <1> int12msg    db      "stack fault ",0
   754 000005F1 6C742000            <1>
   755 000005F5 67656E6572616C2070- <1> int13msg    db      "general protection fault ",0
   756 000005FE 726F74656374696F6E- <1>
   757 00000607 206661756C742000    <1>
   758 0000060F 6B65726E656C207061- <1> int14kmsg   db      "kernel page fault addr=",0
   759 00000618 6765206661756C7420- <1>
   760 00000621 616464723D00        <1>
   761 00000627 617070207061676520- <1> int14umsg   db      "app page fault addr=",0
   762 00000630 6661756C7420616464- <1>
   763 00000639 723D00              <1>
   764 0000063C 666C6F6174696E6720- <1> int16msg    db      "floating point err ",0
   765 00000645 706F696E7420657272- <1>
   766 0000064E 2000                <1>
   767 00000650 616C69676E6D656E74- <1> int17msg    db      "alignment check ",0
   768 00000659 20636865636B2000    <1>
   769 00000661 6D616368696E652063- <1> int18msg    db      "machine check ",0
   770 0000066A 6865636B2000        <1>
   771 00000670 73696D6420666C6F61- <1> int19msg    db      "simd floating point err ",0
   772 00000679 74696E6720706F696E- <1>
   773 00000682 74206572722000      <1>
   774                              <1> 
   775 00000689 687720696E74303220- <1> int34msg    db      "hw int02 ",0
   776 00000692 00                  <1>
   777 00000693 687720696E74303320- <1> int35msg    db      "hw int03 ",0
   778 0000069C 00                  <1>
   779 0000069D 687720696E74303420- <1> int36msg    db      "hw int04 ",0
   780 000006A6 00                  <1>
   781 000006A7 687720696E74303520- <1> int37msg    db      "hw int05 ",0
   782 000006B0 00                  <1>
   783 000006B1 687720696E74303620- <1> int38msg    db      "hw int06 ",0
   784 000006BA 00                  <1>
   785 000006BB 687720696E74303720- <1> int39msg    db      "hw int07 ",0
   786 000006C4 00                  <1>
   787 000006C5 687720696E74303820- <1> int40msg    db      "hw int08 ",0
   788 000006CE 00                  <1>
   789 000006CF 687720696E74303920- <1> int41msg    db      "hw int09 ",0
   790 000006D8 00                  <1>
   791 000006D9 687720696E74313020- <1> int42msg    db      "hw int10 ",0
   792 000006E2 00                  <1>
   793 000006E3 687720696E74313120- <1> int43msg    db      "hw int11 ",0
   794 000006EC 00                  <1>
   795 000006ED 687720696E74313220- <1> int44msg    db      "hw int12 ",0
   796 000006F6 00                  <1>
   797 000006F7 687720696E74313320- <1> int45msg    db      "hw int13 ",0
   798 00000700 00                  <1>
   799 00000701 687720696E74313420- <1> int46msg    db      "hw int14 ",0
   800 0000070A 00                  <1>
   801 0000070B 687720696E74313520- <1> int47msg    db      "hw int15 ",0
   802 00000714 00                  <1>
   803                              <1> 
   804 00000715 73707572696F757320- <1> spuriousmsg db      "spurious int ",0
   805 0000071E 696E742000          <1>
   806 00000723 617069636572722069- <1> apicerrmsg  db      "apicerr int ",0
   807 0000072C 6E742000            <1>
   808 00000730 68692000            <1> himsg       db      "hi ",0
   809 00000734 756E6B6E6F776E2073- <1> int255msg           db  "unknown system call ",0
   810 0000073D 797374656D2063616C- <1>
   811 00000746 6C2000              <1>
   812                              <1> 
   813 00000749 766D206661756C743A- <1> intvmmsg            db  "vm fault: ",0
   814 00000752 2000                <1>
   815                              <1> 
   816                              <1> ; ---- IRQ hardware initialization ----
   817                              <1> 
   818                              <1> bits 16
   819                              <1> 
   820                              <1> irq_init_hardware :
   821                              <1> 
   822                              <1>     ; re-program the 8259's to move the hardware vectors out of the
   823                              <1>     ; soft int range ... C'mon, Intel was pretty clear about this!
   824                              <1> 
   825 00000754 B011                <1>     mov  al,0x11
   826 00000756 E620                <1>     out  0x20,al            ; init the 1st 8259
   827 00000758 B011                <1>     mov  al,0x11
   828 0000075A E6A0                <1>     out  0xA0,al            ; init the 2nd 8259
   829 0000075C B020                <1>     mov  al,apic0_irqbase
   830 0000075E E621                <1>     out  0x21,al            ; base for the 1st 8259
   831 00000760 B028                <1>     mov  al,apic1_irqbase
   832 00000762 E6A1                <1>     out  0xA1,al            ; base for the 2nd 8259
   833 00000764 B004                <1>     mov  al,0x04
   834 00000766 E621                <1>     out  0x21,al            ; set 1st 8259 as master
   835 00000768 B002                <1>     mov  al,0x02
   836 0000076A E6A1                <1>     out  0xA1,al            ; set 2nd 8259 as slave
   837 0000076C B001                <1>     mov  al,0x01
   838 0000076E E621                <1>     out  0x21,al
   839 00000770 B001                <1>     mov  al,0x01
   840 00000772 E6A1                <1>     out  0xA1,al
   841 00000774 B000                <1>     mov  al,0x00
   842 00000776 E621                <1>     out  0x21,al
   843 00000778 B000                <1>     mov  al,0x00
   844 0000077A E6A1                <1>     out  0xA1,al
   845 0000077C C3                  <1>     ret
   846                              <1> 
   847                              <1> bits 32
   848                              <1> 
   849                              <1> ; ----------
   850                              <1> 
   851                              <1> irq_init_bsp_apic_hardware :
   852                              <1>     ;jmp  no_apic
   853                              <1> 
   854                              <1>     ; ---- test for an apic
   855                              <1> 
   856 0000077D B801000000          <1>     mov  eax,1
   857 00000782 0FA2                <1>     cpuid
   858 00000784 83F801              <1>     cmp  eax,1
   859 00000787 724A                <1>     jb   no_apic
   860 00000789 81E200020000        <1>     and  edx,1 << 9         ; apic feature
   861 0000078F 7442                <1>     jz   no_apic
   862                              <1> 
   863                              <1> ;   mov  eax,[0xfee00370]
   864                              <1> ;   and  eax,0xffffff00
   865                              <1> ;   or   eax,apicerr_int
   866                              <1> ;   mov  [0xfee00370],eax   ; setup LVT3 error vector
   867                              <1> 
   868 00000791 A13000E0FE          <1>     mov  eax,[0xfee00030]
   869 00000796 25F0000000          <1>     and  eax,0xf0           ; see if it is a local apic
   870 0000079B 83F810              <1>     cmp  eax,0x10
   871 0000079E 7533                <1>     jnz  no_lapic
   872 000007A0 C605[18030000]01    <1>     mov  byte [enabled_lapic],0x1
   873                              <1> 
   874 000007A7 B8F0010000          <1>     mov  eax,0x000001f0     ; enable lapic, use spurious int 0xf0
   875 000007AC A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
   876 000007B1 B800000001          <1>     mov  eax,0x01000000
   877 000007B6 A3D000E0FE          <1>     mov  [0xfee000d0],eax   ; set our LDR
   878 000007BB B8FFFFFFFF          <1>     mov  eax,0xffffffff
   879 000007C0 A3E000E0FE          <1>     mov  [0xfee000e0],eax   ; set our DFR
   880                              <1> 
   881                              <1> ;    ; ---- enable the local apic via msr
   882                              <1> ; but apparently not needed ...
   883                              <1> ;    mov  ecx,0x1b
   884                              <1> ;    xor  edx,edx
   885                              <1> ; ;  mov  eax,0xfffff800
   886                              <1> ;    mov  eax,0x00000800
   887                              <1> ;    wrmsr
   888                              <1> ;    mov  eax,[0xfffff030]
   889                              <1> 
   890                              <1>     ; ---- visual indicator: lapic active
   891                              <1> 
   892 000007C5 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
   893 000007C9 8EE8                <1>     mov  gs,ax          
   894 000007CB 65C605320000002B    <1>     mov  byte [gs:25*2],'+'
   895                              <1> 
   896                              <1> no_apic :
   897                              <1> no_lapic :
   898 000007D3 C3                  <1>     ret
   899                              <1> 
   900                              <1> ; ----------
   901                              <1> 
   902                              <1> irq_init_ap_apic_hardware :
   903                              <1> 
   904                              <1>     ; ---- mtrr for 0xfee00000 -> strong uncachable (UC) ?
   905                              <1> 
   906 000007D4 50                  <1>     push eax                ; save cpu number
   907 000007D5 89C1                <1>     mov  ecx,eax
   908 000007D7 A0[18030000]        <1>     mov  al,[enabled_lapic]
   909 000007DC 08C0                <1>     or   al,al
   910 000007DE 7432                <1>     jz  no_lapic_init2
   911                              <1> 
   912 000007E0 BB00000001          <1>     mov  ebx,0x01000000
   913 000007E5 D3E3                <1>     shl  ebx,cl             ; bit mask based on cpu number
   914 000007E7 891DD000E0FE        <1>     mov  [0xfee000d0],ebx   ; set our LDR
   915                              <1> 
   916 000007ED A17003E0FE          <1>     mov  eax,[0xfee00370]
   917 000007F2 2500FFFFFF          <1>     and  eax,0xffffff00
   918 000007F7 0DF1000000          <1>     or   eax,apicerr_int
   919 000007FC A37003E0FE          <1>     mov  [0xfee00370],eax   ; setup LVT3 error vector
   920                              <1> 
   921 00000801 B8F0010000          <1>     mov  eax,0x00000100 + spurious_int  ; enable lapic
   922 00000806 A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
   923 0000080B 31C0                <1>     xor  eax,eax
   924 0000080D A3B000E0FE          <1>     mov  [0xfee000b0],eax   ; eoi anything outstanding
   925                              <1> no_lapic_init2 :
   926 00000812 58                  <1>     pop  eax
   927 00000813 C3                  <1>     ret
   928                              <1> 
   929                              <1> ; ---- IRQ handlers ----
   930                              <1> 
   931                              <1> align 4
   932                              <1> int_handler_div0 :
   933 00000814 56                  <1>     push esi
   934 00000815 BE[17050000]        <1>     mov  esi,int00msg
   935 0000081A E856040000          <1>     call irq_print_msg
   936 0000081F 5E                  <1>     pop  esi
   937 00000820 E9F0000000          <1>     jmp  int_handler_show_eip
   938                              <1> 
   939 00000825 90<rept>            <1> align 4
   940                              <1> int_handler_debug :
   941 00000828 56                  <1>     push esi
   942 00000829 BE[27050000]        <1>     mov  esi,int01msg
   943 0000082E E842040000          <1>     call irq_print_msg
   944 00000833 5E                  <1>     pop  esi
   945 00000834 E9DC000000          <1>     jmp  int_handler_show_eip
   946                              <1> 
   947 00000839 90<rept>            <1> align 4
   948                              <1> int_handler_nmi :
   949 0000083C 56                  <1>     push esi
   950 0000083D BE[38050000]        <1>     mov  esi,int02msg
   951 00000842 E82E040000          <1>     call irq_print_msg
   952 00000847 5E                  <1>     pop  esi
   953 00000848 E958040000          <1>     jmp  reboot_on_alt_key
   954                              <1> 
   955 0000084D 90<rept>            <1> align 4
   956                              <1> int_handler_brkp :
   957 00000850 56                  <1>     push esi
   958 00000851 BE[3D050000]        <1>     mov  esi,int03msg
   959 00000856 E81A040000          <1>     call irq_print_msg
   960 0000085B 5E                  <1>     pop  esi
   961 0000085C E9B4000000          <1>     jmp  int_handler_show_eip
   962                              <1> 
   963 00000861 90<rept>            <1> align 4
   964                              <1> int_handler_ovrflw :
   965 00000864 56                  <1>     push esi
   966 00000865 BE[53050000]        <1>     mov  esi,int04msg
   967 0000086A E806040000          <1>     call irq_print_msg
   968 0000086F 5E                  <1>     pop  esi
   969 00000870 E9A0000000          <1>     jmp  int_handler_show_eip
   970                              <1> 
   971 00000875 90<rept>            <1> align 4
   972                              <1> int_handler_bound :
   973 00000878 56                  <1>     push esi
   974 00000879 BE[67050000]        <1>     mov  esi,int05msg
   975 0000087E E8F2030000          <1>     call irq_print_msg
   976 00000883 5E                  <1>     pop  esi
   977 00000884 E98C000000          <1>     jmp  int_handler_show_eip
   978                              <1> 
   979 00000889 90<rept>            <1> align 4
   980                              <1> int_handler_invop :
   981 0000088C 56                  <1>     push esi
   982 0000088D BE[77050000]        <1>     mov  esi,int06msg
   983 00000892 E8DE030000          <1>     call irq_print_msg
   984 00000897 5E                  <1>     pop  esi
   985 00000898 EB7B                <1>     jmp  int_handler_show_eip
   986                              <1> 
   987 0000089A 90<rept>            <1> align 4
   988                              <1> int_handler_devna :
   989                              <1>     ;push esi
   990                              <1>     ;mov  esi,int07msg
   991                              <1>     ;call irq_print_msg
   992                              <1>     ;pop  esi
   993                              <1>     ; FIXME fxsave/fxrestore the fpu/sse/mmx regs
   994 0000089C 0F06                <1>     clts
   995 0000089E CF                  <1>     iret
   996                              <1> 
   997 0000089F 90                  <1> align 4
   998                              <1> int_handler_cpsego :
   999 000008A0 56                  <1>     push esi
  1000 000008A1 BE[A9050000]        <1>     mov  esi,int09msg
  1001 000008A6 E8CA030000          <1>     call irq_print_msg
  1002 000008AB 5E                  <1>     pop  esi
  1003 000008AC EB67                <1>     jmp  int_handler_show_eip
  1004                              <1> 
  1005 000008AE 90<rept>            <1> align 4
  1006                              <1> int_handler_segnp :
  1007                              <1>     ; ec = seg selector
  1008 000008B0 56                  <1>     push esi
  1009 000008B1 BE[D3050000]        <1>     mov  esi,int11msg
  1010 000008B6 E8BA030000          <1>     call irq_print_msg
  1011 000008BB 5E                  <1>     pop  esi
  1012 000008BC EB32                <1>     jmp  int_handler_show_ec_eip
  1013                              <1> 
  1014 000008BE 90<rept>            <1> align 4
  1015                              <1> int_handler_stkflt :
  1016                              <1>     ; ec = seg selector
  1017 000008C0 56                  <1>     push esi
  1018 000008C1 BE[E8050000]        <1>     mov  esi,int12msg
  1019 000008C6 E8AA030000          <1>     call irq_print_msg
  1020 000008CB 5E                  <1>     pop  esi
  1021 000008CC B904000000          <1>     mov  ecx,4
  1022 000008D1 83C302              <1>     add  ebx,2
  1023                              <1> int_handler_show_stack_loop :
  1024 000008D4 58                  <1>     pop  eax
  1025 000008D5 E84BFBFFFF          <1>     call putx_vga
  1026 000008DA E2F8                <1>     loop int_handler_show_stack_loop
  1027 000008DC E9C4030000          <1>     jmp  reboot_on_alt_key
  1028                              <1> 
  1029 000008E1 90<rept>            <1> align 4
  1030                              <1> int_handler_gpf :
  1031                              <1>     ; ec = various ...
  1032                              <1>     ;test dword [esp+0xc],1 << 17    ; check the eflags vm bit
  1033                              <1>     ;jnz  int_handler_vm_gpf
  1034                              <1> 
  1035 000008E4 56                  <1>     push esi
  1036 000008E5 BE[F5050000]        <1>     mov  esi,int13msg
  1037 000008EA E886030000          <1>     call irq_print_msg
  1038 000008EF 5E                  <1>     pop  esi
  1039                              <1> int_handler_show_ec_eip :
  1040 000008F0 65C60365            <1>     mov  byte [gs:ebx],'e'
  1041 000008F4 83C302              <1>     add  ebx,2
  1042 000008F7 65C60363            <1>     mov  byte [gs:ebx],'c'
  1043 000008FB 83C302              <1>     add  ebx,2
  1044 000008FE 65C6033D            <1>     mov  byte [gs:ebx],'='
  1045 00000902 83C302              <1>     add  ebx,2
  1046 00000905 58                  <1>     pop  eax                ; ec
  1047 00000906 E80AFBFFFF          <1>     call putbx_vga
  1048 0000090B 83EB02              <1>     sub  ebx,2
  1049 0000090E 65C60320            <1>     mov  byte [gs:ebx],' '
  1050 00000912 83C302              <1>     add  ebx,2
  1051                              <1> int_handler_show_eip :
  1052 00000915 65C60363            <1>     mov  byte [gs:ebx],'c'
  1053 00000919 83C302              <1>     add  ebx,2
  1054 0000091C 65C60373            <1>     mov  byte [gs:ebx],'s'
  1055 00000920 83C302              <1>     add  ebx,2
  1056 00000923 65C6033A            <1>     mov  byte [gs:ebx],':'
  1057 00000927 83C302              <1>     add  ebx,2
  1058 0000092A 65C60365            <1>     mov  byte [gs:ebx],'e'
  1059 0000092E 83C302              <1>     add  ebx,2
  1060 00000931 65C60369            <1>     mov  byte [gs:ebx],'i'
  1061 00000935 83C302              <1>     add  ebx,2
  1062 00000938 65C60370            <1>     mov  byte [gs:ebx],'p'
  1063 0000093C 83C302              <1>     add  ebx,2
  1064 0000093F 65C6033D            <1>     mov  byte [gs:ebx],'='
  1065 00000943 83C302              <1>     add  ebx,2
  1066 00000946 5A                  <1>     pop  edx                ; eip
  1067 00000947 58                  <1>     pop  eax                ; cs
  1068 00000948 E8D8FAFFFF          <1>     call putx_vga
  1069 0000094D 83EB02              <1>     sub  ebx,2
  1070 00000950 65C6033A            <1>     mov  byte [gs:ebx],':'
  1071 00000954 83C302              <1>     add  ebx,2
  1072 00000957 89D0                <1>     mov  eax,edx
  1073 00000959 E8C7FAFFFF          <1>     call putx_vga
  1074 0000095E E942030000          <1>     jmp  reboot_on_alt_key
  1075                              <1> 
  1076                              <1> int_handler_vm_gpf :
  1077 00000963 53                  <1>     push ebx
  1078                              <1>     ;mov  ebx,[esp+8]        ; faulter's eip
  1079 00000964 2E8A1B              <1>     mov  bl,[cs:ebx]        ; get the opcode that caused the fault
  1080 00000967 80FBF4              <1>     cmp  bl,0xf4            ; 'hlt' is ok
  1081 0000096A 7452                <1>     jz   int_handler_vm_normal_return
  1082                              <1> 
  1083 0000096C 56                  <1>     push esi
  1084 0000096D 50                  <1>     push eax
  1085 0000096E 53                  <1>     push ebx
  1086 0000096F BE[49070000]        <1>     mov  esi,intvmmsg
  1087 00000974 E8FC020000          <1>     call irq_print_msg
  1088 00000979 65C6036F            <1>     mov  byte [gs:ebx],'o'
  1089 0000097D 83C302              <1>     add  ebx,2
  1090 00000980 65C60370            <1>     mov  byte [gs:ebx],'p'
  1091 00000984 83C302              <1>     add  ebx,2
  1092 00000987 65C60363            <1>     mov  byte [gs:ebx],'c'
  1093 0000098B 83C302              <1>     add  ebx,2
  1094 0000098E 65C6036F            <1>     mov  byte [gs:ebx],'o'
  1095 00000992 83C302              <1>     add  ebx,2
  1096 00000995 65C60364            <1>     mov  byte [gs:ebx],'d'
  1097 00000999 83C302              <1>     add  ebx,2
  1098 0000099C 65C60365            <1>     mov  byte [gs:ebx],'e'
  1099 000009A0 83C302              <1>     add  ebx,2
  1100 000009A3 65C60328            <1>     mov  byte [gs:ebx],'('
  1101 000009A7 83C302              <1>     add  ebx,2
  1102 000009AA 58                  <1>     pop  eax
  1103 000009AB 25FF000000          <1>     and  eax,0xff
  1104 000009B0 E860FAFFFF          <1>     call putbx_vga
  1105 000009B5 83C302              <1>     add  ebx,2
  1106 000009B8 65C60329            <1>     mov  byte [gs:ebx],')'
  1107 000009BC 58                  <1>     pop  eax
  1108 000009BD 5E                  <1>     pop  esi
  1109                              <1> int_handler_vm_normal_return :
  1110 000009BE 5B                  <1>     pop  ebx
  1111                              <1> 
  1112 000009BF FF74240C            <1>     push dword [esp+0xc]    ; eflags
  1113 000009C3 9D                  <1>     popf                    ; restore the VM and NT flags
  1114 000009C4 CF                  <1>     iret                    ; chain back via nested task
  1115                              <1>                             ; from v86 tss to original caller
  1116                              <1> 
  1117 000009C5 90<rept>            <1> align 4
  1118                              <1> int_handler_pgflt :
  1119 000009C8 58                  <1>     pop  eax
  1120 000009C9 50                  <1>     push eax
  1121 000009CA A904000000          <1>     test eax,0x4                        ; user mode or supervisor?
  1122 000009CF 7407                <1>     jz   int_handler_pgflt_bad_kaddr    ; if not, kernel failed
  1123                              <1> 
  1124                              <1> int_handler_pgflt_bad_uaddr :
  1125 000009D1 BE[27060000]        <1>     mov  esi,int14umsg
  1126 000009D6 EB05                <1>     jmp  int_handler_pgflt_msg
  1127                              <1> 
  1128                              <1> int_handler_pgflt_bad_kaddr :
  1129 000009D8 BE[0F060000]        <1>     mov  esi,int14kmsg
  1130                              <1> 
  1131                              <1> int_handler_pgflt_msg :
  1132 000009DD E893020000          <1>     call irq_print_msg
  1133 000009E2 0F20D0              <1>     mov  eax,cr2
  1134 000009E5 E83BFAFFFF          <1>     call putx_vga                       ; print the addres of the fault
  1135 000009EA E901FFFFFF          <1>     jmp  int_handler_show_ec_eip
  1136                              <1> 
  1137 000009EF 90                  <1> align 4
  1138                              <1> int_handler_fpuerr :
  1139 000009F0 56                  <1>     push esi
  1140 000009F1 BE[3C060000]        <1>     mov  esi,int16msg
  1141 000009F6 E87A020000          <1>     call irq_print_msg
  1142                              <1>     ; FIXME flags identify error
  1143                              <1>     ;   IS - FPU stack overflow
  1144                              <1>     ;   IA - Invalid arithmetic operation
  1145                              <1>     ;   Z  - Divide by zero
  1146                              <1>     ;   D  - Source operand is a denormal number
  1147                              <1>     ;   O  - Overflow in result
  1148                              <1>     ;   U  - Underflow in result
  1149                              <1>     ;   P  - Inexact result
  1150 000009FB E915FFFFFF          <1>     jmp  int_handler_show_eip
  1151                              <1> 
  1152                              <1> align 4
  1153                              <1> int_handler_algnchk :
  1154                              <1>     ; ec = zero
  1155 00000A00 56                  <1>     push esi
  1156 00000A01 BE[50060000]        <1>     mov  esi,int17msg
  1157 00000A06 E86A020000          <1>     call irq_print_msg
  1158 00000A0B 5E                  <1>     pop  esi
  1159 00000A0C 58                  <1>     pop  eax                    ; toss the ec
  1160 00000A0D E903FFFFFF          <1>     jmp  int_handler_show_eip
  1161                              <1> 
  1162 00000A12 90<rept>            <1> align 4
  1163                              <1> int_handler_machchk :
  1164 00000A14 56                  <1>     push esi
  1165 00000A15 BE[61060000]        <1>     mov  esi,int18msg
  1166 00000A1A E856020000          <1>     call irq_print_msg
  1167 00000A1F 5E                  <1>     pop  esi
  1168 00000A20 E9F0FEFFFF          <1>     jmp  int_handler_show_eip
  1169                              <1> 
  1170 00000A25 90<rept>            <1> align 4
  1171                              <1> int_handler_simdfpe :
  1172 00000A28 56                  <1>     push esi
  1173 00000A29 BE[70060000]        <1>     mov  esi,int19msg
  1174 00000A2E E842020000          <1>     call irq_print_msg
  1175 00000A33 5E                  <1>     pop  esi
  1176 00000A34 E9DCFEFFFF          <1>     jmp  int_handler_show_eip
  1177                              <1> 
  1178 00000A39 90<rept>            <1> align 4
  1179                              <1> int_handler_timer :     
  1180                              <1>     ;cli
  1181 00000A3C 60                  <1>     pusha
  1182 00000A3D 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
  1183 00000A41 8EE8                <1>     mov  gs,ax          
  1184 00000A43 658A1D01000000      <1>     mov  bl,byte [gs:1]     ; inc the color of the first two chars
  1185 00000A4A FEC3                <1>     inc  bl
  1186 00000A4C 80E30F              <1>     and  bl,0xf             ; just the foreground
  1187 00000A4F 65881D01000000      <1>     mov  byte [gs:1],bl
  1188 00000A56 65881D03000000      <1>     mov  byte [gs:3],bl
  1189                              <1> 
  1190                              <1>     ; ---- wakeup any sleeping cpus (see syscall_sleep)
  1191                              <1> 
  1192 00000A5D A0[18030000]        <1>     mov  al,[enabled_lapic]
  1193 00000A62 08C0                <1>     or   al,al
  1194 00000A64 741B                <1>     jz   no_sleepers
  1195                              <1> 
  1196                              <1>     ; the race here is not important, we'll catch them on the next tick
  1197                              <1> 
  1198 00000A66 A1[1D030000]        <1>     mov  eax,[sleepers]
  1199 00000A6B 09C0                <1>     or   eax,eax
  1200 00000A6D 7412                <1>     jz   no_sleepers
  1201 00000A6F C1E018              <1>     shl  eax,24                     ; FIXME can only handle 8 cpus
  1202 00000A72 A31003E0FE          <1>     mov  dword [0xfee00310],eax     ; via the destination register ...
  1203 00000A77 B8FE480000          <1>     mov  eax,0x04800 + wakeup_int   ; no shrthnd, fixed, logical, edge
  1204 00000A7C A30003E0FE          <1>     mov  dword [0xfee00300],eax
  1205                              <1> 
  1206                              <1> no_sleepers :
  1207 00000A81 B020                <1>     mov  al,0x20        
  1208 00000A83 E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1209 00000A85 61                  <1>     popa
  1210 00000A86 CF                  <1>     iret                
  1211                              <1> 
  1212 00000A87 90                  <1> align 4
  1213                              <1> int_handler_kbd :
  1214                              <1>     ;cli
  1215 00000A88 B020                <1>     mov  al,0x20
  1216 00000A8A E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1217                              <1> 
  1218 00000A8C 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
  1219 00000A90 8EE8                <1>     mov  gs,ax          
  1220                              <1> 
  1221 00000A92 53                  <1>     push ebx
  1222 00000A93 BB3C000000          <1>     mov  ebx,30*2
  1223 00000A98 E460                <1>     in   al,0x60
  1224 00000A9A 50                  <1>     push eax
  1225 00000A9B E875F9FFFF          <1>     call putbx_vga
  1226 00000AA0 58                  <1>     pop  eax
  1227                              <1> 
  1228 00000AA1 3C5B                <1>     cmp  al,0x5b            ; scan code for "the windows key"
  1229 00000AA3 0F8403020000        <1>     jz   reboot
  1230                              <1> 
  1231 00000AA9 65A044000000        <1>     mov  al,[gs:34*2]
  1232 00000AAF FEC0                <1>     inc  al
  1233 00000AB1 65A244000000        <1>     mov  [gs:34*2],al       ; change a character on screen
  1234                              <1> 
  1235 00000AB7 5B                  <1>     pop  ebx
  1236 00000AB8 CF                  <1>     iret
  1237                              <1> 
  1238 00000AB9 90<rept>            <1> align 4
  1239                              <1> int_handler_hw02 :
  1240 00000ABC 56                  <1>     push esi
  1241 00000ABD BE[89060000]        <1>     mov  esi,int34msg
  1242 00000AC2 E8AE010000          <1>     call irq_print_msg
  1243 00000AC7 5E                  <1>     pop  esi
  1244 00000AC8 E9D8010000          <1>     jmp  reboot_on_alt_key
  1245                              <1> 
  1246 00000ACD 90<rept>            <1> align 4
  1247                              <1> int_handler_hw03 :
  1248 00000AD0 56                  <1>     push esi
  1249 00000AD1 BE[93060000]        <1>     mov  esi,int35msg
  1250 00000AD6 E89A010000          <1>     call irq_print_msg
  1251 00000ADB 5E                  <1>     pop  esi
  1252 00000ADC E9C4010000          <1>     jmp  reboot_on_alt_key
  1253                              <1> 
  1254 00000AE1 90<rept>            <1> align 4
  1255                              <1> int_handler_hw04 :
  1256 00000AE4 56                  <1>     push esi
  1257 00000AE5 BE[9D060000]        <1>     mov  esi,int36msg
  1258 00000AEA E886010000          <1>     call irq_print_msg
  1259 00000AEF 5E                  <1>     pop  esi
  1260 00000AF0 E9B0010000          <1>     jmp  reboot_on_alt_key
  1261                              <1> 
  1262 00000AF5 90<rept>            <1> align 4
  1263                              <1> int_handler_hw05 :
  1264 00000AF8 56                  <1>     push esi
  1265 00000AF9 BE[A7060000]        <1>     mov  esi,int37msg
  1266 00000AFE E872010000          <1>     call irq_print_msg
  1267 00000B03 5E                  <1>     pop  esi
  1268 00000B04 E99C010000          <1>     jmp  reboot_on_alt_key
  1269                              <1> 
  1270 00000B09 90<rept>            <1> align 4
  1271                              <1> int_handler_hw06 :
  1272 00000B0C 56                  <1>     push esi
  1273 00000B0D BE[B1060000]        <1>     mov  esi,int38msg
  1274 00000B12 E85E010000          <1>     call irq_print_msg
  1275 00000B17 5E                  <1>     pop  esi
  1276 00000B18 E988010000          <1>     jmp  reboot_on_alt_key
  1277                              <1> 
  1278 00000B1D 90<rept>            <1> align 4
  1279                              <1> int_handler_hw07 :
  1280 00000B20 56                  <1>     push esi
  1281 00000B21 BE[BB060000]        <1>     mov  esi,int39msg
  1282 00000B26 E84A010000          <1>     call irq_print_msg
  1283 00000B2B 5E                  <1>     pop  esi
  1284 00000B2C E974010000          <1>     jmp  reboot_on_alt_key
  1285                              <1> 
  1286 00000B31 90<rept>            <1> align 4
  1287                              <1> int_handler_hw08 :
  1288 00000B34 56                  <1>     push esi
  1289 00000B35 BE[C5060000]        <1>     mov  esi,int40msg
  1290 00000B3A E836010000          <1>     call irq_print_msg
  1291 00000B3F 5E                  <1>     pop  esi
  1292 00000B40 E960010000          <1>     jmp  reboot_on_alt_key
  1293                              <1> 
  1294 00000B45 90<rept>            <1> align 4
  1295                              <1> int_handler_hw09 :
  1296 00000B48 56                  <1>     push esi
  1297 00000B49 BE[CF060000]        <1>     mov  esi,int41msg
  1298 00000B4E E822010000          <1>     call irq_print_msg
  1299 00000B53 5E                  <1>     pop  esi
  1300 00000B54 E94C010000          <1>     jmp  reboot_on_alt_key
  1301                              <1> 
  1302 00000B59 90<rept>            <1> align 4
  1303                              <1> int_handler_hw10 :
  1304 00000B5C 56                  <1>     push esi
  1305 00000B5D BE[D9060000]        <1>     mov  esi,int42msg
  1306 00000B62 E80E010000          <1>     call irq_print_msg
  1307 00000B67 5E                  <1>     pop  esi
  1308 00000B68 E938010000          <1>     jmp  reboot_on_alt_key
  1309                              <1> 
  1310 00000B6D 90<rept>            <1> align 4
  1311                              <1> int_handler_hw11 :
  1312 00000B70 56                  <1>     push esi
  1313 00000B71 BE[E3060000]        <1>     mov  esi,int43msg
  1314 00000B76 E8FA000000          <1>     call irq_print_msg
  1315 00000B7B 5E                  <1>     pop  esi
  1316 00000B7C E924010000          <1>     jmp  reboot_on_alt_key
  1317                              <1> 
  1318 00000B81 90<rept>            <1> align 4
  1319                              <1> int_handler_hw12 :
  1320 00000B84 56                  <1>     push esi
  1321 00000B85 BE[ED060000]        <1>     mov  esi,int44msg
  1322 00000B8A E8E6000000          <1>     call irq_print_msg
  1323 00000B8F 5E                  <1>     pop  esi
  1324 00000B90 E910010000          <1>     jmp  reboot_on_alt_key
  1325                              <1> 
  1326 00000B95 90<rept>            <1> align 4
  1327                              <1> int_handler_hw13 :
  1328 00000B98 56                  <1>     push esi
  1329 00000B99 BE[F7060000]        <1>     mov  esi,int45msg
  1330 00000B9E E8D2000000          <1>     call irq_print_msg
  1331 00000BA3 5E                  <1>     pop  esi
  1332 00000BA4 E9FC000000          <1>     jmp  reboot_on_alt_key
  1333                              <1> 
  1334 00000BA9 90<rept>            <1> align 4
  1335                              <1> int_handler_hw14 :
  1336 00000BAC 56                  <1>     push esi
  1337 00000BAD BE[01070000]        <1>     mov  esi,int46msg
  1338 00000BB2 E8BE000000          <1>     call irq_print_msg
  1339 00000BB7 5E                  <1>     pop  esi
  1340 00000BB8 E9E8000000          <1>     jmp  reboot_on_alt_key
  1341                              <1> 
  1342 00000BBD 90<rept>            <1> align 4
  1343                              <1> int_handler_hw15 :
  1344 00000BC0 56                  <1>     push esi
  1345 00000BC1 BE[0B070000]        <1>     mov  esi,int47msg
  1346 00000BC6 E8AA000000          <1>     call irq_print_msg
  1347 00000BCB 5E                  <1>     pop  esi
  1348 00000BCC E9D4000000          <1>     jmp  reboot_on_alt_key
  1349                              <1> 
  1350                              <1> ; called via the double fault task
  1351 00000BD1 90<rept>            <1> align 4
  1352                              <1> int_handler_tg_dblflt :
  1353 00000BD4 56                  <1>     push esi
  1354 00000BD5 BE[9B050000]        <1>     mov  esi,int08msg
  1355 00000BDA E896000000          <1>     call irq_print_msg
  1356 00000BDF 5E                  <1>     pop  esi
  1357 00000BE0 E9C0000000          <1>     jmp  reboot_on_alt_key
  1358                              <1> 
  1359                              <1> ; called via the invalid tss task
  1360 00000BE5 90<rept>            <1> align 4
  1361                              <1> int_handler_tg_invtss :
  1362 00000BE8 56                  <1>     push esi
  1363 00000BE9 BE[C6050000]        <1>     mov  esi,int10msg
  1364 00000BEE E882000000          <1>     call irq_print_msg
  1365 00000BF3 5E                  <1>     pop  esi
  1366                              <1>     ; FIXME need to go back to previous tss to get ec via that stack
  1367 00000BF4 83C302              <1>     add  ebx,2
  1368 00000BF7 58                  <1>     pop  eax                ; ec == invalid tss selector
  1369 00000BF8 E828F8FFFF          <1>     call putx_vga
  1370 00000BFD E9A3000000          <1>     jmp  reboot_on_alt_key
  1371                              <1> 
  1372 00000C02 90<rept>            <1> align 4
  1373                              <1> int_handler_spurious :
  1374 00000C04 56                  <1>     push esi
  1375 00000C05 BE[15070000]        <1>     mov  esi,spuriousmsg
  1376 00000C0A E866000000          <1>     call irq_print_msg
  1377 00000C0F 5E                  <1>     pop  esi
  1378 00000C10 CF                  <1>     iret
  1379                              <1> 
  1380 00000C11 90<rept>            <1> align 4
  1381                              <1> int_handler_apicerr :
  1382 00000C14 56                  <1>     push esi
  1383 00000C15 BE[23070000]        <1>     mov  esi,apicerrmsg
  1384 00000C1A E856000000          <1>     call irq_print_msg
  1385 00000C1F 5E                  <1>     pop  esi
  1386 00000C20 CF                  <1>     iret
  1387                              <1> 
  1388                              <1> ; serves only to eoi the fixed ipi used for sleep wakeup
  1389 00000C21 90<rept>            <1> align 4
  1390                              <1> wakeup :
  1391 00000C24 50                  <1>     push eax
  1392 00000C25 31C0                <1>     xor  eax,eax
  1393 00000C27 A3B000E0FE          <1>     mov  [0xfee000b0],eax    ; lapic eoi
  1394 00000C2C 58                  <1>     pop  eax
  1395 00000C2D CF                  <1>     iret
  1396                              <1> 
  1397                              <1> 
  1398 00000C2E 90<rept>            <1> align 4
  1399                              <1> ; %if ($ >= 0x8000) bomb
  1400                              <1> sysent :
  1401 00000C30 3D00020000          <1>     cmp  eax,0x0200
  1402 00000C35 0F84A9020000        <1>     jz   syscall_klog
  1403 00000C3B 3D00100000          <1>     cmp  eax,0x1000
  1404 00000C40 0F84AD020000        <1>     jz   syscall_ncpus
  1405 00000C46 3D00200000          <1>     cmp  eax,0x2000
  1406 00000C4B 0F8407030000        <1>     jz   syscall_sleep
  1407 00000C51 3D00210000          <1>     cmp  eax,0x2100
  1408 00000C56 0F849D020000        <1>     jz   syscall_new_thread
  1409 00000C5C 3D00270000          <1>     cmp  eax,0x2700
  1410 00000C61 0F8426030000        <1>     jz   syscall_request_pmem_access
  1411 00000C67 BE[34070000]        <1>     mov  esi,int255msg
  1412 00000C6C E804000000          <1>     call irq_print_msg
  1413 00000C71 31C0                <1>     xor  eax,eax
  1414 00000C73 48                  <1>     dec  eax
  1415 00000C74 CF                  <1>     iret
  1416                              <1> 
  1417                              <1> 
  1418                              <1> ; ---- IRQ support code ---- 
  1419                              <1> 
  1420                              <1> irq_print_msg :
  1421 00000C75 BBA0000000          <1>     mov  ebx,160            ; line 2
  1422 00000C7A A0[18030000]        <1>     mov  al,[enabled_lapic]
  1423 00000C7F 08C0                <1>     or   al,al
  1424 00000C81 741D                <1>     jz   skip_cpumsg
  1425                              <1> 
  1426 00000C83 56                  <1>     push esi
  1427 00000C84 BE[13050000]        <1>     mov  esi,cpumsg
  1428 00000C89 E870F7FFFF          <1>     call puts_vga
  1429 00000C8E A12000E0FE          <1>     mov  eax,[0xfee00020]   ; print our apic id
  1430 00000C93 C1E818              <1>     shr  eax,24
  1431 00000C96 83C030              <1>     add  eax,'0'
  1432 00000C99 658803              <1>     mov  [gs:ebx],al
  1433 00000C9C 83C304              <1>     add  ebx,4
  1434 00000C9F 5E                  <1>     pop  esi
  1435                              <1> 
  1436                              <1> skip_cpumsg :
  1437 00000CA0 E959F7FFFF          <1>     jmp  puts_vga
  1438                              <1> 
  1439                              <1> 
  1440                              <1> reboot_on_alt_key :
  1441 00000CA5 FA                  <1>     cli
  1442                              <1> reboot_on_alt_key_loop :
  1443 00000CA6 E460                <1>     in   al,0x60
  1444 00000CA8 3C38                <1>     cmp  al,'8'             ; part of the scan code for ALT
  1445 00000CAA 75FA                <1>     jnz  reboot_on_alt_key_loop
  1446                              <1> reboot :
  1447 00000CAC FA                  <1>     cli
  1448 00000CAD 0F011D[D90C0000]    <1>     lidt [reboot_idt]       ; restore boot idt (helps qemu ...)
  1449 00000CB4 EA[BB0C0000]2800    <1>     jmp  rmcssel:reboot_exit_pmode      ; thankyou hpa
  1450                              <1> reboot_exit_pmode :
  1451                              <1> bits 16
  1452 00000CBB B83000              <1>     mov  ax,rmdssel
  1453 00000CBE 8ED8                <1>     mov  ds,ax
  1454 00000CC0 8EC0                <1>     mov  es,ax
  1455 00000CC2 8ED0                <1>     mov  ss,ax
  1456 00000CC4 8EE0                <1>     mov  fs,ax
  1457 00000CC6 8EE8                <1>     mov  gs,ax
  1458                              <1> 
  1459 00000CC8 0F20C0              <1>     mov  eax,cr0
  1460 00000CCB 6625FEFFFF7F        <1>     and  eax,0x7ffffffe
  1461 00000CD1 0F22C0              <1>     mov  cr0,eax            ; disable pmode and paging
  1462 00000CD4 EA0000FFFF          <1>     jmp  0xffff:0           ; jump to the warm start vector and
  1463                              <1>                             ; flush the I prefetch queue all at once
  1464                              <1> 
  1465                              <1> reboot_idt :
  1466 00000CD9 FFFF                <1>     dw 0xffff
  1467 00000CDB 00000000            <1>     dd 0
  1468                              <1> 
  1469                              <1> 
  1470                              <1> ; ---- IDT initialization table ---- 
  1471                              <1> ;
  1472                              <1> ; One dw (2 bytes per vector) is used which means that all
  1473                              <1> ; int_handler entry points must reside below 0x10000!
  1474                              <1> ;
  1475                              <1> ; And since all int_handler routines are 4 byte aligned,
  1476                              <1> ; the bottom two bits are available to indicate type.
  1477                              <1> ; These bits index into the irq_types table below.
  1478                              <1> 
  1479 00000CDF 90                  <1> align 4
  1480                              <1> 
  1481                              <1> ; note: these are not gdt/ldt descriptors (see swdev3a 6.11 pg 228)
  1482                              <1> 
  1483 00000CE0 8E                  <1> irq_types   db  0x8e            ; dpl=0 32bit interrupt gate (sets IF flag)
  1484 00000CE1 EE                  <1>             db  0xee            ; dpl=3 32bit app (ring3) interrupt gate
  1485 00000CE2 85                  <1>             db  0x85            ; dpl=0 32bit task gate
  1486 00000CE3 8F                  <1>             db  0x8f            ; dpl=0 32bit trap gate (does not set IF flag)
  1487                              <1> 
  1488                              <1> ; all handlers/selectors are 4 byte aligned - this gives us
  1489                              <1> ; two bits to use to designate 1 of 4 types of idt descriptors ...
  1490                              <1> 
  1491                              <1> irqt_intr   equ 0
  1492                              <1> irqt_app    equ 1
  1493                              <1> irqt_task   equ 2
  1494                              <1> irqt_trap   equ 3
  1495                              <1> 
  1496                              <1> irq_setup_table:
  1497                              <1>     ; cpu defined
  1498 00000CE4 [1708]              <1>     dw  int_handler_div0      + irqt_trap ; 0
  1499 00000CE6 [2B08]              <1>     dw  int_handler_debug     + irqt_trap ; 1
  1500 00000CE8 [3C08]              <1>     dw  int_handler_nmi       + irqt_intr ; 2
  1501 00000CEA [5108]              <1>     dw  int_handler_brkp      + irqt_app  ; 3
  1502 00000CEC [6508]              <1>     dw  int_handler_ovrflw    + irqt_app  ; 4
  1503 00000CEE [7908]              <1>     dw  int_handler_bound     + irqt_app  ; 5
  1504 00000CF0 [8F08]              <1>     dw  int_handler_invop     + irqt_trap ; 6
  1505 00000CF2 [9F08]              <1>     dw  int_handler_devna     + irqt_trap ; 7
  1506 00000CF4 4200                <1>     dw  tasksel_f08           + irqt_task ; 8   double fault
  1507 00000CF6 [A308]              <1>     dw  int_handler_cpsego    + irqt_trap ; 9
  1508 00000CF8 4A00                <1>     dw  tasksel_f10           + irqt_task ; 10  invalid tss
  1509 00000CFA [B308]              <1>     dw  int_handler_segnp     + irqt_trap ; 11
  1510 00000CFC [C308]              <1>     dw  int_handler_stkflt    + irqt_trap ; 12
  1511 00000CFE [E708]              <1>     dw  int_handler_gpf       + irqt_trap ; 13
  1512 00000D00 [C809]              <1>     dw  int_handler_pgflt     + irqt_intr ; 14
  1513 00000D02 0000                <1>     dw  0                                 ; 15  Intel reserved
  1514 00000D04 [F309]              <1>     dw  int_handler_fpuerr    + irqt_trap ; 16
  1515 00000D06 [030A]              <1>     dw  int_handler_algnchk   + irqt_trap ; 17
  1516 00000D08 [170A]              <1>     dw  int_handler_machchk   + irqt_trap ; 18
  1517 00000D0A [2B0A]              <1>     dw  int_handler_simdfpe   + irqt_trap ; 19
  1518 00000D0C 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0
  1519 00000D15 000000000000000000- <1>
  1520 00000D1E 000000000000        <1>
  1521                              <1>     ; hw defined
  1522                              <1> apic0_irqbase equ ($ - irq_setup_table)/2
  1523 00000D24 [3C0A]              <1>     dw  int_handler_timer     + irqt_intr ; 32  0x20
  1524 00000D26 [880A]              <1>     dw  int_handler_kbd       + irqt_intr ; 33
  1525 00000D28 [BC0A]              <1>     dw  int_handler_hw02      + irqt_intr ; 34
  1526 00000D2A [D00A]              <1>     dw  int_handler_hw03      + irqt_intr ; 35
  1527 00000D2C [E40A]              <1>     dw  int_handler_hw04      + irqt_intr ; 36
  1528 00000D2E [F80A]              <1>     dw  int_handler_hw05      + irqt_intr ; 37
  1529 00000D30 [0C0B]              <1>     dw  int_handler_hw06      + irqt_intr ; 38
  1530 00000D32 [200B]              <1>     dw  int_handler_hw07      + irqt_intr ; 39
  1531                              <1> apic1_irqbase equ ($ - irq_setup_table)/2
  1532 00000D34 [340B]              <1>     dw  int_handler_hw08      + irqt_intr ; 40
  1533 00000D36 [480B]              <1>     dw  int_handler_hw09      + irqt_intr ; 41
  1534 00000D38 [5C0B]              <1>     dw  int_handler_hw10      + irqt_intr ; 42
  1535 00000D3A [700B]              <1>     dw  int_handler_hw11      + irqt_intr ; 43
  1536 00000D3C [840B]              <1>     dw  int_handler_hw12      + irqt_intr ; 44
  1537 00000D3E [980B]              <1>     dw  int_handler_hw13      + irqt_intr ; 45
  1538 00000D40 [AC0B]              <1>     dw  int_handler_hw14      + irqt_intr ; 46
  1539 00000D42 [C00B]              <1>     dw  int_handler_hw15      + irqt_intr ; 47  0x2f
  1540                              <1>     ; undefined - hw can expand here
  1541 00000D44 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x30
  1542 00000D4D 000000000000000000- <1>
  1543 00000D56 000000000000000000- <1>
  1544 00000D5F 0000000000          <1>
  1545 00000D64 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x40
  1546 00000D6D 000000000000000000- <1>
  1547 00000D76 000000000000000000- <1>
  1548 00000D7F 0000000000          <1>
  1549 00000D84 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x50
  1550 00000D8D 000000000000000000- <1>
  1551 00000D96 000000000000000000- <1>
  1552 00000D9F 0000000000          <1>
  1553 00000DA4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x60
  1554 00000DAD 000000000000000000- <1>
  1555 00000DB6 000000000000000000- <1>
  1556 00000DBF 0000000000          <1>
  1557 00000DC4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x70
  1558 00000DCD 000000000000000000- <1>
  1559 00000DD6 000000000000000000- <1>
  1560 00000DDF 0000000000          <1>
  1561 00000DE4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x80
  1562 00000DED 000000000000000000- <1>
  1563 00000DF6 000000000000000000- <1>
  1564 00000DFF 0000000000          <1>
  1565 00000E04 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x90
  1566 00000E0D 000000000000000000- <1>
  1567 00000E16 000000000000000000- <1>
  1568 00000E1F 0000000000          <1>
  1569 00000E24 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xa0
  1570 00000E2D 000000000000000000- <1>
  1571 00000E36 000000000000000000- <1>
  1572 00000E3F 0000000000          <1>
  1573                              <1>     ; set up cpu thread management tss gates
  1574                              <1>     ; these map 1-to-1 to cpus
  1575                              <1> first_thread_tss_gate equ ($ - irq_setup_table)/2
  1576 00000E44 5A00                <1>     dw  tasksel_u00           + irqt_task
  1577 00000E46 6A00                <1>     dw  tasksel_u01           + irqt_task
  1578 00000E48 7A00                <1>     dw  tasksel_u02           + irqt_task
  1579 00000E4A 8A00                <1>     dw  tasksel_u03           + irqt_task
  1580 00000E4C 9A00                <1>     dw  tasksel_u04           + irqt_task
  1581 00000E4E AA00                <1>     dw  tasksel_u05           + irqt_task
  1582 00000E50 BA00                <1>     dw  tasksel_u06           + irqt_task
  1583 00000E52 CA00                <1>     dw  tasksel_u07           + irqt_task
  1584                              <1> %ifdef FOO
  1585                              <1>     dw  tasksel_u08           + irqt_task
  1586                              <1>     dw  tasksel_u09           + irqt_task
  1587                              <1>     dw  tasksel_u10           + irqt_task
  1588                              <1>     dw  tasksel_u11           + irqt_task
  1589                              <1>     dw  tasksel_u12           + irqt_task
  1590                              <1>     dw  tasksel_u13           + irqt_task
  1591                              <1>     dw  tasksel_u14           + irqt_task
  1592                              <1>     dw  tasksel_u15           + irqt_task
  1593                              <1> %endif
  1594 00000E54 000000000000000000- <1>     dw                  0,0,0,0,0,0,0,0   ; 0xb0
  1595 00000E5D 00000000000000      <1>
  1596 00000E64 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xc0
  1597 00000E6D 000000000000000000- <1>
  1598 00000E76 000000000000000000- <1>
  1599 00000E7F 0000000000          <1>
  1600 00000E84 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xd0
  1601 00000E8D 000000000000000000- <1>
  1602 00000E96 000000000000000000- <1>
  1603 00000E9F 0000000000          <1>
  1604 00000EA4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xe0
  1605 00000EAD 000000000000000000- <1>
  1606 00000EB6 000000000000000000- <1>
  1607 00000EBF 0000000000          <1>
  1608                              <1> spurious_int equ ($ - irq_setup_table)/2
  1609 00000EC4 [040C]              <1>     dw  int_handler_spurious  + irqt_intr
  1610                              <1> apicerr_int equ ($ - irq_setup_table)/2
  1611 00000EC6 [150C]              <1>     dw  int_handler_apicerr   + irqt_app
  1612 00000EC8 000000000000000000- <1>     dw      0,0,0,0,0,0,0,0,0,0,0,0       ; 0xf0
  1613 00000ED1 000000000000000000- <1>
  1614 00000EDA 000000000000        <1>
  1615                              <1>     ; sw defined - expand down if needed
  1616                              <1> wakeup_int equ ($ - irq_setup_table)/2
  1617 00000EE0 [250C]              <1>     dw  wakeup                + irqt_app
  1618 00000EE2 [310C]              <1>     dw  sysent                + irqt_app  ; 256  0xff
  1619                              <1> irq_setup_table_size equ ($ - irq_setup_table)/2
  1620                              <1> 
  1621                                  
  1622                                  ; -------- system calls --------
  1623                                  %include "ozsys.asm"
  1624                              <1> ; OZ - A more utopian OS
  1625                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
  1626                              <1> ;
  1627                              <1> ; OZ System Calls  (for ozapps)
  1628                              <1> 
  1629                              <1> bits 32
  1630                              <1> 
  1631                              <1> ;------------------------------------------------------------------
  1632                              <1> ;   syscall_klog : place a message on the vga line reserved for klog  :D
  1633                              <1> ;
  1634                              <1> ;   entry:
  1635                              <1> ;       esi = message address
  1636                              <1> ;   exit:
  1637                              <1> 
  1638                              <1> syscall_klog :
  1639 00000EE4 60                  <1>     pusha
  1640 00000EE5 BB40010000          <1>     mov  ebx,2 * 160        ; line 3
  1641 00000EEA E80FF5FFFF          <1>     call puts_vga
  1642 00000EEF 61                  <1>     popa
  1643 00000EF0 31C0                <1>     xor  eax,eax
  1644 00000EF2 CF                  <1>     iret
  1645                              <1> 
  1646                              <1> ;------------------------------------------------------------------
  1647                              <1> ;   syscall_ncpus : get how many cpu threads are running
  1648                              <1> ;
  1649                              <1> ;   entry:
  1650                              <1> ;   exit:
  1651                              <1> ;       eax = N cpus
  1652                              <1> 
  1653                              <1> syscall_ncpus :
  1654 00000EF3 A1[14030000]        <1>     mov  eax,[ncpus]
  1655 00000EF8 CF                  <1>     iret
  1656                              <1> 
  1657                              <1> ;------------------------------------------------------------------
  1658                              <1> ;   syscall_new_thread : ask for another cpu to execute code in
  1659                              <1> ;                        the current app
  1660                              <1> ;
  1661                              <1> ;   This implementation is quite a bit of a hack - apps can basically
  1662                              <1> ;   commendere any specific non-boot cpu they want ...
  1663                              <1> ;
  1664                              <1> ;   entry:
  1665                              <1> ;       edx = function start address in the app
  1666                              <1> ;       ecx = address of the top of the app's new thread stack
  1667                              <1> ;       ebx = app's new thread index
  1668                              <1> ;   exit:
  1669                              <1> ;       eax = 0 success, -1 failure
  1670                              <1> 
  1671                              <1> syscall_new_thread :
  1672 00000EF9 09DB                <1>     or   ebx,ebx
  1673 00000EFB 7459                <1>     jz   new_thread_fail        ; don't get to ask for cpu 0
  1674                              <1> 
  1675 00000EFD 31C0                <1>     xor  eax,eax
  1676 00000EFF A0[18030000]        <1>     mov  al,[enabled_lapic]     ; if the lapics are not enabled,
  1677 00000F04 08C0                <1>     or   al,al                  ; none of this is useful
  1678 00000F06 744E                <1>     jz   new_thread_fail
  1679                              <1> 
  1680                              <1>     ; setup the tss
  1681                              <1>     ; slightly squirly - get the tss address from the task selector
  1682                              <1>     ; but there could be a race here: ncpus is updated before
  1683                              <1>     ; create_tss_pair is called, so the task selector could be zero!
  1684                              <1> 
  1685 00000F08 89DF                <1>     mov  edi,ebx
  1686 00000F0A C1E704              <1>     shl  edi,4                  ; 8 byte selectors in pairs
  1687 00000F0D 83C758              <1>     add  edi,tasksel_u00
  1688 00000F10 8BB7[02000000]      <1>     mov  esi,[gdt+edi+2]
  1689 00000F16 81E6FFFFFF00        <1>     and  esi,0xffffff
  1690 00000F1C 31C0                <1>     xor  eax,eax
  1691 00000F1E 8A87[07000000]      <1>     mov  al,[gdt+edi+7]
  1692 00000F24 C1E018              <1>     shl  eax,24
  1693 00000F27 09C6                <1>     or   esi,eax
  1694 00000F29 742B                <1>     jz   new_thread_fail        ; cpu isn't yet ready ...
  1695                              <1> 
  1696                              <1>     ; really should check the previous task link to see if this
  1697                              <1>     ; cpu is busy ...
  1698                              <1> 
  1699 00000F2B 894E38              <1>     mov  [esi+(tss0_esp-tss0)],ecx  ; set the app's stack
  1700 00000F2E 895620              <1>     mov  [esi+(tss0_eip-tss0)],edx  ; set the ip to the entry point
  1701                              <1> 
  1702                              <1>     ; lookup the requested cpu's int/taskgate gdt selector
  1703                              <1> 
  1704 00000F31 89DF                <1>     mov  edi,ebx
  1705 00000F33 81C7B0000000        <1>     add  edi,first_thread_tss_gate  ; convert ebx to int/taskgate number
  1706                              <1> 
  1707                              <1>     ; ipi a cpu.  no fancy affinity scheduling yet,
  1708                              <1>     ; just let the app ask for a specific cpu to do the work
  1709                              <1> 
  1710 00000F39 B800000001          <1>     mov  eax,0x01000000
  1711 00000F3E 89D9                <1>     mov  ecx,ebx                    ; recover requested cpu number
  1712 00000F40 D3E0                <1>     shl  eax,cl                     ; form the icr destination field
  1713                              <1> 
  1714                              <1>     ; poke the cpu that matches our thread index - we only get 8 :/
  1715                              <1> 
  1716 00000F42 A31003E0FE          <1>     mov  dword [0xfee00310],eax
  1717 00000F47 B800480000          <1>     mov  eax,0x4800                 ; no shorthand, fixed, logical, edge
  1718 00000F4C 09F8                <1>     or   eax,edi                    ; make int/taskgate number the vector
  1719 00000F4E A30003E0FE          <1>     mov  dword [0xfee00300],eax
  1720                              <1> 
  1721 00000F53 31C0                <1>     xor  eax,eax
  1722 00000F55 CF                  <1>     iret
  1723                              <1> 
  1724                              <1> new_thread_fail :
  1725 00000F56 48                  <1>     dec  eax                    ; -1
  1726 00000F57 C3                  <1>     ret
  1727                              <1> 
  1728                              <1> ;------------------------------------------------------------------
  1729                              <1> ;   syscall_sleep : wait for N timer interrupts
  1730                              <1> ;
  1731                              <1> ;   entry:
  1732                              <1> ;       edx = N ticks
  1733                              <1> ;   exit:
  1734                              <1> 
  1735                              <1> syscall_sleep :
  1736 00000F58 A0[18030000]        <1>     mov  al,[enabled_lapic]
  1737 00000F5D 08C0                <1>     or   al,al
  1738 00000F5F 7415                <1>     jz   sleep_loop
  1739                              <1> 
  1740 00000F61 A12000E0FE          <1>     mov  eax,[0xfee00020]
  1741 00000F66 C1E818              <1>     shr  eax,24
  1742 00000F69 09C0                <1>     or   eax,eax
  1743 00000F6B 7409                <1>     jz   sleep_loop         ; the boot cpu services the timer int
  1744 00000F6D 88C1                <1>     mov  cl,al              ; so don't add it to the sleeper list
  1745 00000F6F B801000000          <1>     mov  eax,1
  1746 00000F74 D3E0                <1>     shl  eax,cl
  1747                              <1> 
  1748                              <1> sleep_loop :
  1749 00000F76 F00905[1D030000]    <1>     lock or [sleepers],eax  ; announce we are sleeping
  1750 00000F7D FB                  <1>     sti
  1751 00000F7E F4                  <1>     hlt                     ; wait for an int to wake us up
  1752 00000F7F 4A                  <1>     dec  edx                ; decrement the tick count
  1753 00000F80 75F4                <1>     jnz  sleep_loop
  1754                              <1> 
  1755 00000F82 83F0FF              <1>     xor  eax,-1
  1756 00000F85 F02105[1D030000]    <1>     lock and [sleepers],eax ; renounce sleepiness
  1757 00000F8C CF                  <1>     iret
  1758                              <1> 
  1759                              <1> ;------------------------------------------------------------------
  1760                              <1> ;   syscall_request_pmem_access : ask for access to a physical
  1761                              <1> ;            memory address
  1762                              <1> ;
  1763                              <1> ;   entry:
  1764                              <1> ;       edx = phys memory address
  1765                              <1> ;
  1766                              <1> ;   exit:
  1767                              <1> ;       (need to return a logical address in eax)  For now just
  1768                              <1> ;       direct maps the physical address into logical addr space.
  1769                              <1> 
  1770                              <1> syscall_request_pmem_access :
  1771 00000F8D E801000000          <1>     call map_pmem
  1772 00000F92 CF                  <1>     iret
  1773                              <1> 
  1774                              <1> ;------------------------------------------------------------------
  1775                              <1> ;   map_pmem - add entries to the current page directory/table
  1776                              <1> ;              to direct map the requested physical memory address
  1777                              <1> ;
  1778                              <1> ;   entry:
  1779                              <1> ;       edx = phys memory address
  1780                              <1> ;
  1781                              <1> ;   returns:
  1782                              <1> ;       (need to return a logical address in eax)  For now just
  1783                              <1> ;       direct maps the physical address into logical addr space.
  1784                              <1> ;       eax =  0 success
  1785                              <1> ;       eax = -1 fail
  1786                              <1> 
  1787                              <1> map_pmem :
  1788 00000F93 60                  <1>     pusha
  1789 00000F94 52                  <1>     push edx
  1790 00000F95 0F20DB              <1>     mov  ebx,cr3
  1791 00000F98 81E300F0FFFF        <1>     and  ebx,0xfffff000
  1792 00000F9E 89D7                <1>     mov  edi,edx
  1793 00000FA0 81E70000C0FF        <1>     and  edi,0xffc00000
  1794 00000FA6 C1EF14              <1>     shr  edi,(22 - 2)           ; calc page directory index
  1795 00000FA9 81E200F03F00        <1>     and  edx,0x003ff000
  1796 00000FAF C1EA0A              <1>     shr  edx,(12 - 2)           ; calc page table index
  1797                              <1> 
  1798 00000FB2 8B043B              <1>     mov  eax,[ebx+edi]
  1799 00000FB5 09C0                <1>     or   eax,eax                ; is there a page table here?
  1800 00000FB7 750F                <1>     jnz  map_pmem_have_pgtbl
  1801 00000FB9 E892F4FFFF          <1>     call mem_alloc_kernel_page
  1802 00000FBE 09C0                <1>     or   eax,eax
  1803 00000FC0 741E                <1>     jz   map_pmem_fail
  1804 00000FC2 C1E00C              <1>     shl  eax,12                 ; convert pgno to pgtbl entry
  1805 00000FC5 89043B              <1>     mov  [ebx+edi],eax          ; update page table
  1806                              <1> 
  1807                              <1> map_pmem_have_pgtbl :
  1808                              <1>     ; for now, no security check, just direct map the address
  1809                              <1>     ; and mark the pages and the page table r/w by all
  1810 00000FC8 830C3B07            <1>     or   dword [ebx+edi],7      ; user, r/w, present
  1811                              <1> 
  1812 00000FCC 8B1C3B              <1>     mov  ebx,[ebx+edi]
  1813 00000FCF 81E300F0FFFF        <1>     and  ebx,0xfffff000
  1814 00000FD5 58                  <1>     pop  eax                    ; recover requested phys mem addr
  1815                              <1>     ; FIXME yup, big security hole if called by ring 0! And it is ...
  1816 00000FD6 83C807              <1>     or   eax,7                  ; user, r/w, present
  1817 00000FD9 890413              <1>     mov  [ebx+edx],eax          ; update page directory
  1818 00000FDC 61                  <1>     popa
  1819 00000FDD 31C0                <1>     xor  eax,eax                ; 0
  1820 00000FDF C3                  <1>     ret
  1821                              <1> 
  1822                              <1> map_pmem_fail :
  1823 00000FE0 48                  <1>     dec  eax                    ; -1
  1824 00000FE1 C3                  <1>     ret
  1825                              <1> 
  1826                                  
  1827 00000FE2 00<rept>                align 16, db 0
  1828                                  kernel_text_size equ ($-textstart)
  1829                                  
  1830                                  ; ---------------------------------------------------------------------------
  1831                                  section .data
  1832                                  datastart :
  1833                                  
  1834                                  ; -------- descriptors --------------
  1835                                  ; Intel SW dev manual 3a, 3.4.5, pg 103
  1836                                  ;
  1837                                  ; In my opinion, macros for descriptor entries
  1838                                  ; don't make the code that much more readable.
  1839                                  
  1840                                  gdt :
  1841                                  nullsel equ $-gdt           ; nullsel = 0h
  1842 00000000 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
  1843                                  
  1844                                  codesel equ $-gdt           ; codesel = 8h  4Gb flat over all logical mem
  1845 00000008 FFFF                        dw 0xffff               ; limit 0-15
  1846 0000000A 0000                        dw 0x0000               ; base  0-15
  1847 0000000C 00                          db 0x00                 ; base 16-23
  1848 0000000D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  1849 0000000E CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  1850 0000000F 00                          db 0x00                 ; base 24-31
  1851                                  
  1852                                  datasel equ $-gdt           ; datasel = 10h  4Gb flat over all logical mem
  1853 00000010 FFFF                        dw 0xffff               ; limit 0-15
  1854 00000012 0000                        dw 0x0000               ; base  0-15
  1855 00000014 00                          db 0x00                 ; base 16-23
  1856 00000015 92                          db 0x92                 ; present, dpl=0, data r/w
  1857 00000016 CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  1858 00000017 00                          db 0x00                 ; base 24-31
  1859                                  
  1860                                  stacksel equ $-gdt          ; stacksel = 18h  small limited stack
  1861 00000018 FF1F                        dw kstack_size-1        ; limit
  1862 0000001A 0010                        dw kstack_loc           ; base
  1863 0000001C 00                          db 0
  1864 0000001D 92                          db 0x92                 ; present, dpl=0, data, r/w
  1865 0000001E 40                          db 0x40                 ; byte granular, 32bit/8bit
  1866 0000001F 00                          db 0
  1867                                  
  1868                                  videosel equ $-gdt          ; videosel = 20h
  1869 00000020 9F0F                        dw 3999                 ; limit 80*25*2-1
  1870 00000022 0080                        dw 0x8000               ; base 0xb8000
  1871 00000024 0B                          db 0x0b
  1872 00000025 92                          db 0x92                 ; present, dpl=0, data, r/w
  1873 00000026 40                          db 0x40                 ; byte granular, 32bit/8bit
  1874 00000027 00                          db 0
  1875                                  
  1876                                  rmcssel equ $-gdt           ; real mode CS selector = 28h
  1877 00000028 FFFF                        dw 0x0ffff              ; limit 0-15
  1878 0000002A 0000                        dw 0x0000               ; base  0-15
  1879 0000002C 00                          db 0x00                 ; base 16-23
  1880 0000002D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  1881 0000002E 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  1882 0000002F 00                          db 0x00                 ; base 24-31
  1883                                  
  1884                                  rmdssel equ $-gdt           ; real mode DS selector = 30h
  1885 00000030 FFFF                        dw 0x0ffff              ; limit 0-15
  1886 00000032 0000                        dw 0x0000               ; base  0-15
  1887 00000034 00                          db 0x00                 ; base 16-23
  1888 00000035 92                          db 0x92                 ; present, dpl=0, data r/w
  1889 00000036 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  1890 00000037 00                          db 0x00                 ; base 24-31
  1891                                  
  1892                                  ldtsel1 equ $-gdt
  1893 00000038 1800                        dw ldt1_len             ; length of the ldt
  1894 0000003A [5001]                      dw ldt1                 ; address of the ldt
  1895 0000003C 00                          db 0
  1896 0000003D 82                          db 0x82                 ; present, dpl=0, ldt
  1897 0000003E 40                          db 0x40                 ; byte granular, 32bit/8bit
  1898 0000003F 00                          db 0
  1899                                  
  1900                                  tasksel_f08 equ $-gdt       ; the double fault task selector
  1901 00000040 6800                        dw tss_len              ; tss length
  1902 00000042 [6801]                      dw tss_f08              ; tss physical address
  1903 00000044 00                          db 0
  1904 00000045 89                          db 0x89                 ; present, dpl=0, tss32
  1905 00000046 40                          db 0x40                 ; byte granular, 32bit/8bit
  1906 00000047 00                          db 0
  1907                                  
  1908                                  tasksel_f10 equ $-gdt       ; the invalid tss task selector
  1909 00000048 6800                        dw tss_len              ; tss length
  1910 0000004A [D001]                      dw tss_f10              ; tss physical address
  1911 0000004C 00                          db 0
  1912 0000004D 89                          db 0x89                 ; present, dpl=0, tss32
  1913 0000004E 40                          db 0x40                 ; byte granular, 32bit/8bit
  1914 0000004F 00                          db 0
  1915                                  
  1916                                  ; there is one kernel thread tss (ring 0) and one user thread tss (ring 1)
  1917                                  ; per cpu.  memory for tss structs for the non-boot cpus are allocated as
  1918                                  ; each non-boot cpu comes online (see create_tss_pair).  tasksel_uXX tss
  1919                                  ; gates are installed in the idt (starting at first_thread_tss_gate),
  1920                                  ; they also map 1-to-1 with cpus.  (the thread is launched via an lapic
  1921                                  ; vectored interrupt that jumps immediately into user space - and to call a
  1922                                  ; task gate from an interrupt requires an existing ring 0 tss to be active)
  1923                                  ; tasksel_uXX tsses are initialized in new_thread.
  1924                                  
  1925                                  tasksel_k00 equ $-gdt
  1926 00000050 6800[3802]00894000                              dw tss_len, tss0, 0x8900, 0x40
  1927                                  tasksel_u00 equ $-gdt
  1928 00000058 6800[A002]00894000                              dw tss_len, tss1, 0x8900, 0x40
  1929                                  tasksel_k01 equ $-gdt
  1930 00000060 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1931                                  tasksel_u01 equ $-gdt
  1932 00000068 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1933                                  tasksel_k02 equ $-gdt
  1934 00000070 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1935                                  tasksel_u02 equ $-gdt
  1936 00000078 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1937                                  tasksel_k03 equ $-gdt
  1938 00000080 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1939                                  tasksel_u03 equ $-gdt
  1940 00000088 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1941                                  tasksel_k04 equ $-gdt
  1942 00000090 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1943                                  tasksel_u04 equ $-gdt
  1944 00000098 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1945                                  tasksel_k05 equ $-gdt
  1946 000000A0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1947                                  tasksel_u05 equ $-gdt
  1948 000000A8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1949                                  tasksel_k06 equ $-gdt
  1950 000000B0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1951                                  tasksel_u06 equ $-gdt
  1952 000000B8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1953                                  tasksel_k07 equ $-gdt
  1954 000000C0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1955                                  tasksel_u07 equ $-gdt
  1956 000000C8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1957                                  ;%ifdef FOO
  1958                                  tasksel_k08 equ $-gdt
  1959 000000D0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1960                                  tasksel_u08 equ $-gdt
  1961 000000D8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1962                                  tasksel_k09 equ $-gdt
  1963 000000E0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1964                                  tasksel_u09 equ $-gdt
  1965 000000E8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1966                                  tasksel_k10 equ $-gdt
  1967 000000F0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1968                                  tasksel_u10 equ $-gdt
  1969 000000F8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1970                                  tasksel_k11 equ $-gdt
  1971 00000100 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1972                                  tasksel_u11 equ $-gdt
  1973 00000108 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1974                                  tasksel_k12 equ $-gdt
  1975 00000110 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1976                                  tasksel_u12 equ $-gdt
  1977 00000118 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1978                                  tasksel_k13 equ $-gdt
  1979 00000120 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1980                                  tasksel_u13 equ $-gdt
  1981 00000128 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1982                                  tasksel_k14 equ $-gdt
  1983 00000130 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1984                                  tasksel_u14 equ $-gdt
  1985 00000138 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1986                                  tasksel_k15 equ $-gdt
  1987 00000140 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1988                                  tasksel_u15 equ $-gdt
  1989 00000148 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1990                                  ;%endif
  1991                                  gdt_end :
  1992                                  
  1993                                  ; ---------------------
  1994                                  
  1995                                  ldt1 :
  1996                                  nullsel1 equ $-ldt1         ; nullsel1 = 07h
  1997 00000150 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
  1998                                  
  1999                                  codesel1 equ $-ldt1         ; codesel1 = 0fh  4Gb flat over all logical mem
  2000 00000158 FFFF                        dw 0xffff               ; limit 0-15
  2001 0000015A 0000                        dw 0x0000               ; base  0-15
  2002 0000015C 00                          db 0x00                 ; base 16-23
  2003 0000015D FA                          db 0xfa                 ; present, dpl=3, code e/r
  2004 0000015E CF                          db 0xcf                 ; 4k granular, 32bit, limit 16-19
  2005 0000015F 00                          db 0x00                 ; base 24-31
  2006                                  
  2007                                  datasel1 equ $-ldt1         ; datasel1 = 17h  4Gb flat over all logical mem
  2008 00000160 FFFF                        dw 0xffff               ; limit 0-15
  2009 00000162 0000                        dw 0x0000               ; base  0-15
  2010 00000164 00                          db 0x00                 ; base 16-23
  2011 00000165 F2                          db 0xf2                 ; present, dpl=3, data r/w
  2012 00000166 CF                          db 0xcf                 ; 4k granular, 32bit, limit 16-19
  2013 00000167 00                          db 0x00                 ; base 24-31
  2014                                  
  2015                                  ; gcc wants the ds, es, and ss segment registers to match
  2016                                  ;stacksel1 equ $-ldt1        ; stacksel = 1ch  small limited stack
  2017                                  ;    dw 0xffff               ; limit
  2018                                  ;    dw 0x0000               ; base  0-15
  2019                                  ;    db 0x00
  2020                                  ;    db 0xf2                 ; present, dpl=3, data, r/w
  2021                                  ;    db 0                    ; byte granular, 16 bit
  2022                                  ;    db 0
  2023                                  
  2024                                  ldt1_end :
  2025                                  
  2026                                  ldt1_len equ ldt1_end-ldt1
  2027                                  
  2028                                  ; ---------------------
  2029                                  ; the tss that handles double fault exceptions
  2030                                  
  2031                                  tss_f08 :                   ; intel sw 3a 7.6  pg 287 of 756
  2032 00000168 00000000                    dw 0,0                  ; previous task link
  2033 0000016C 00000000                    dd 0                    ; esp0
  2034 00000170 00000000                    dw 0,0                  ; ss0
  2035 00000174 00000000                    dd 0                    ; esp1
  2036 00000178 00000000                    dw 0,0                  ; ss1
  2037 0000017C 00000000                    dd 0                    ; esp2
  2038 00000180 00000000                    dw 0,0                  ; ss2
  2039 00000184 00300000                    dd pgdir                ; cr3
  2040 00000188 [D40B0000]                  dd int_handler_tg_dblflt ; eip
  2041 0000018C 00000000                    dd 0                    ; eflags
  2042 00000190 00000000                    dd 0                    ; eax
  2043 00000194 00000000                    dd 0                    ; ecx
  2044 00000198 00000000                    dd 0                    ; edx
  2045 0000019C 00000000                    dd 0                    ; ebx
  2046 000001A0 00080000                    dd kstack_size/4        ; esp
  2047 000001A4 00000000                    dd 0                    ; ebp
  2048 000001A8 00000000                    dd 0                    ; esi
  2049 000001AC 00000000                    dd 0                    ; edi
  2050 000001B0 10000000                    dw datasel,0            ; es
  2051 000001B4 08000000                    dw codesel,0            ; cs
  2052 000001B8 10000000                    dw datasel,0            ; ss
  2053 000001BC 10000000                    dw datasel,0            ; ds
  2054 000001C0 00000000                    dw 0,0                  ; fs
  2055 000001C4 20000000                    dw videosel,0           ; gs
  2056 000001C8 00000000                    dw 0,0                  ; ldt
  2057 000001CC 0000                        dw 0                    ; trap
  2058 000001CE 0000                        dw 0                    ; iomap
  2059                                  
  2060                                  ; ---------------------
  2061                                  ; the tss that handles invalid tss exceptions
  2062                                  
  2063                                  tss_f10 :                   ; intel sw 3a 7.6  pg 287 of 756
  2064 000001D0 00000000                    dw 0,0                  ; previous task link
  2065 000001D4 00000000                    dd 0                    ; esp0
  2066 000001D8 00000000                    dw 0,0                  ; ss0
  2067 000001DC 00000000                    dd 0                    ; esp1
  2068 000001E0 00000000                    dw 0,0                  ; ss1
  2069 000001E4 00000000                    dd 0                    ; esp2
  2070 000001E8 00000000                    dw 0,0                  ; ss2
  2071 000001EC 00300000                    dd pgdir                ; cr3
  2072 000001F0 [E80B0000]                  dd int_handler_tg_invtss ; eip
  2073 000001F4 00000000                    dd 0                    ; eflags
  2074 000001F8 00000000                    dd 0                    ; eax
  2075 000001FC 00000000                    dd 0                    ; ecx
  2076 00000200 00000000                    dd 0                    ; edx
  2077 00000204 00000000                    dd 0                    ; ebx
  2078 00000208 00100000                    dd kstack_size/2        ; esp
  2079 0000020C 00000000                    dd 0                    ; ebp
  2080 00000210 00000000                    dd 0                    ; esi
  2081 00000214 00000000                    dd 0                    ; edi
  2082 00000218 10000000                    dw datasel,0            ; es
  2083 0000021C 08000000                    dw codesel,0            ; cs
  2084 00000220 10000000                    dw datasel,0            ; ss
  2085 00000224 10000000                    dw datasel,0            ; ds
  2086 00000228 00000000                    dw 0,0                  ; fs
  2087 0000022C 20000000                    dw videosel,0           ; gs
  2088 00000230 00000000                    dw 0,0                  ; ldt
  2089 00000234 0000                        dw 0                    ; trap
  2090 00000236 0000                        dw 0                    ; iomap
  2091                                  
  2092                                  ; ---------------------
  2093                                  ; tss0 and tss1 are cpu0's pair, these are also templates for other
  2094                                  ; cpus that come online.
  2095                                  
  2096                                  tss0 :                      ; intel swdev3a 7.6  pg 287 of 756
  2097 00000238 00000000                    dw 0,0                  ; previous task link
  2098                                  tss0_esp0 :
  2099 0000023C 00000000                    dd 0                    ; esp0
  2100                                  tss0_ss0 :
  2101 00000240 00000000                    dw 0,0                  ; ss0
  2102 00000244 00000000                    dd 0                    ; esp1
  2103 00000248 00000000                    dw 0,0                  ; ss1
  2104 0000024C 00000000                    dd 0                    ; esp2
  2105 00000250 00000000                    dw 0,0                  ; ss2
  2106                                  tss0_cr3 :
  2107 00000254 00300000                    dd pgdir                ; cr3
  2108                                  tss0_eip :
  2109 00000258 00000000                    dd 0                    ; eip
  2110 0000025C 00000000                    dd 0                    ; eflags
  2111                                  tss0_eax :
  2112 00000260 00000000                    dd 0                    ; eax
  2113 00000264 00000000                    dd 0                    ; ecx
  2114 00000268 00000000                    dd 0                    ; edx
  2115 0000026C 00000000                    dd 0                    ; ebx
  2116                                  tss0_esp :
  2117 00000270 00000000                    dd 0                    ; esp
  2118 00000274 00000000                    dd 0                    ; ebp
  2119 00000278 00000000                    dd 0                    ; esi
  2120 0000027C 00000000                    dd 0                    ; edi
  2121                                  tss0_es :
  2122 00000280 00000000                    dw 0,0                  ; es
  2123                                  tss0_cs :
  2124 00000284 00000000                    dw 0,0                  ; cs
  2125                                  tss0_ss :
  2126 00000288 00000000                    dw 0,0                  ; ss
  2127                                  tss0_ds :
  2128 0000028C 00000000                    dw 0,0                  ; ds
  2129 00000290 00000000                    dw 0,0                  ; fs
  2130 00000294 20000000                    dw videosel,0           ; gs
  2131                                  tss0_ldt :
  2132 00000298 00000000                    dw 0,0                  ; ldt
  2133 0000029C 0000                        dw 0                    ; trap
  2134 0000029E 0000                        dw 0                    ; iomap
  2135                                  tss0_end :
  2136                                  
  2137                                  tss_len equ tss0_end-tss0
  2138                                  
  2139                                  ; user tss
  2140                                  
  2141                                  tss1 :                      ; intel sw 3a 7.6  pg 287 of 756
  2142 000002A0 00000000                    dw 0,0                  ; previous task link
  2143 000002A4 E01F0000                    dd kstack_size-32       ; esp0  (int and irq support)
  2144 000002A8 10000000                    dw datasel,0            ; ss0   (-32 leaves some stack space for main)
  2145 000002AC 00000000                    dd 0                    ; esp1
  2146 000002B0 00000000                    dw 0,0                  ; ss1
  2147 000002B4 00000000                    dd 0                    ; esp2
  2148 000002B8 00000000                    dw 0,0                  ; ss2
  2149 000002BC 00300000                    dd pgdir                ; cr3
  2150                                  tss1_eip :
  2151 000002C0 00000000                    dd 0                    ; eip
  2152 000002C4 00000000                    dd 0                    ; eflags
  2153 000002C8 00000000                    dd 0                    ; eax
  2154 000002CC 00000000                    dd 0                    ; ecx
  2155 000002D0 00000000                    dd 0                    ; edx
  2156 000002D4 00000000                    dd 0                    ; ebx
  2157 000002D8 00000000                    dd 0                    ; esp
  2158 000002DC 00000000                    dd 0                    ; ebp
  2159 000002E0 00000000                    dd 0                    ; esi
  2160 000002E4 00000000                    dd 0                    ; edi
  2161 000002E8 17000000                    dw datasel1+7,0         ; es
  2162 000002EC 0F000000                    dw codesel1+7,0         ; cs
  2163 000002F0 17000000                    dw datasel1+7,0         ; ss
  2164 000002F4 17000000                    dw datasel1+7,0         ; ds
  2165 000002F8 00000000                    dw 0,0                  ; fs
  2166 000002FC 00000000                    dw 0,0                  ; gs
  2167 00000300 3B000000                    dw ldtsel1+3,0          ; ldt
  2168 00000304 0000                        dw 0                    ; trap
  2169 00000306 0000                        dw 0                    ; iomap
  2170                                  
  2171                                  ; ---------------------
  2172                                  
  2173                                  gdtr :
  2174 00000308 4F01                        dw gdt_end - gdt - 1    ; gdt length
  2175 0000030A [00000000]                  dd gdt                  ; gdt physical address
  2176                                  
  2177                                  idtr :
  2178                                      ; irq_setup_table_size == the number of gates in the idt
  2179 0000030E FF07                        dw irq_setup_table_size * 8 - 1     ; idt limit (should be 2k)
  2180 00000310 00700000                    dd idt                              ; address of the idt
  2181                                  
  2182 00000314 00000000                ncpus           dd 0        ; number of running cpus
  2183                                  
  2184 00000318 00                      enabled_lapic   db 0        ; set to 1 if an lapic is present and in use
  2185                                  
  2186 00000319 00000000                next_free_page  dd 0        ; initialized after page tables are setup
  2187                                  
  2188 0000031D 0000000000000000        sleepers        dq 0        ; one bit per cpu
  2189                                  
  2190 00000325 00<rept>                align 16, db 0
  2191                                  kernel_data_size equ ($-datastart)
  2192                                  
  2193                                  
  2194                                  ; ---------------------
  2195                                  ; Need to align to a physical page boundary here so that appended init apps
  2196                                  ; are always page aligned.  The problem is our text section starts 1k below
  2197                                  ; a page boundary, and so an 'align 4096' doesn't match up with physical
  2198                                  ; memory.
  2199                                  
  2200                                  ; Add larger tests here if the times expression turns up negative, to make
  2201                                  ; the kernel image size right, but your next problem will be that the boot
  2202                                  ; loader will likely refuse to load all these sectors in one pass.
  2203                                  
  2204                                  section .fill
  2205                                  
  2206                                  fill :
  2207                                  
  2208                                  %if total_size > 4096+1024
  2209                                      times (4096+4096+1024-total_size) db 0
  2210                                  %elif total_size > 1024
  2211 00000000 00<rept>                    times (4096+1024-total_size) db 0
  2212                                  %endif
  2213                                  
  2214                                  kend :
  2215                                  
