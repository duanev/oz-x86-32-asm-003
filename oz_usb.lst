     1                                  ; OZ - A more utopian OS   x86-32 startup
     2                                  ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
     3                                  ;
     4                                  ; Copyright (C) 2015  Duane Voth
     5                                  ;
     6                                  ;   This program is free software: you can redistribute it and/or modify
     7                                  ;   it under the terms of the GNU Affero General Public License as
     8                                  ;   published by the Free Software Foundation, either version 3 of the
     9                                  ;   License, or (at your option) any later version.
    10                                  ;
    11                                  ;   This program is distributed in the hope that it will be useful,
    12                                  ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
    13                                  ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    14                                  ;   GNU Affero General Public License for more details.
    15                                  ;
    16                                  ;   You should have received a copy of the GNU Affero General Public License
    17                                  ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
    18                                  ;
    19                                  ;
    20                                  ;
    21                                  ; usage:
    22                                  ;	$ qemu-system-i386 -boot a -fda oz_fd -monitor stdio
    23                                  ;
    24                                  ; requires: nasm-2.07  or later from: http://www.nasm.us
    25                                  ;
    26                                  ; credits:
    27                                  ;       many thanks to the folks at wiki.osdev.org who archive great info.
    28                                  ;
    29                                  ; contributors:
    30                                  ;        djv - Duane Voth
    31                                  ;
    32                                  ; history:
    33                                  ; 2007/03/03 - 0.00.01 - djv - begin with various web examples
    34                                  ;                      http://linuxgazette.net/issue82/misc/raghu/code.asm.txt
    35                                  ;                      http://www.osdever.net/tutorials/brunmar/simple_asm.txt
    36                                  ; 2007/03/04 - 0.00.02 - djv - add timer interrupt support with stray int dbg
    37                                  ; 2007/03/05 - 0.00.03 - djv - remove stray int dbg, add mbr data struc back
    38                                  ; 2007/03/11 - 0.00.04 - djv - debug USB boot problem
    39                                  ; 2007/03/28 - 0.01.00 - djv - add a real-mode stage2 loader in the mbr to
    40                                  ;                              load the sectors past the mbr on the boot
    41                                  ;                              device into the memory behind the mbr.  so even
    42                                  ;                              tho the read from the device happens in two
    43                                  ;                              parts, memory contains a linear image of the
    44                                  ;                              first few sectors of the boot device.
    45                                  ; 2009/02/01 - 0.02.00 - djv - begin to define application and dynamic library
    46                                  ;                              binary formats with headers detailing size and
    47                                  ;                              entry points.
    48                                  ; 2009/08/01 - 0.03.00 - djv - create the OZ app execution container using
    49                                  ;                              TSSes, paging, and rings 0 and 3.  begin to
    50                                  ;                              play with system calls.
    51                                  ; 2015/10/26 - 0.03.01 - djv - cleanup, add smp usermode tss structs, sleep,
    52                                  ;                              wakeup, and ipi for user thread creation.
    53                                  
    54                                  %ifdef USB
    55                                  [map symbols oz_usb.map]
    56                                  %else
    57                                  [map symbols oz_fd.map]
    58                                  %endif
    59                                  
    60                                  ; -------- stage 1 ---------------------------------------------------------
    61                                  ; A classic x86 Master Boot Record
    62                                  
    63                                  section .text start=0x7c00  ; PC BIOS boot loader entry point
    64                                  textstart :
    65                                  
    66                                  bios_entry :
    67 00000000 FA                          cli
    68 00000001 EA[2400]0000                jmp 0:load_stage2       ; load cs, skip over mbr data struct
    69                                  
    70                                  times 6-($-$$)  db 0
    71 00000006 6F7A                    oemid db "oz"
    72                                  
    73 00000008 00<rept>                times 11-($-$$)  db 0
    74                                  
    75                                  ; compute the size of the kernel image in 512 byte sectors
    76                                  total_size equ (kernel_text_size + kernel_data_size)
    77                                  kisectors  equ (total_size)/512 + (APP_SIZE + 512)/512
    78                                  ; compute the end of the kernel image (with apps attached)
    79                                  kilast equ 0x7c00 + kisectors * 512
    80                                  
    81                                  ; MS MBR  (http://support.microsoft.com/kb/140418)
    82                                  %ifdef FLOPPY
    83                                      dw 512                  ; Bytes per sector
    84                                      db 1                    ; Sectors per cluster
    85                                      dw kisectors            ; Number of reserved sectors
    86                                      db 2                    ; Number of FATs
    87                                      dw 0x00e0               ; Number of dirs in root
    88                                      dw 0x0b40               ; Number of sectors in volume
    89                                      db 0xf0                 ; Media descriptor
    90                                      dw 9                    ; Number of sectors per FAT
    91                                      dw 18                   ; Number of sectors per track
    92                                      dw 2                    ; Number of heads
    93                                      dd 0                    ; Number of hidden sectors
    94                                      dd 0                    ; Large Sectors
    95                                  %endif
    96                                  
    97                                  %ifdef USB
    98 0000000B 0000                        dw 0                    ; Bytes per sector
    99 0000000D 00                          db 0                    ; Sectors per cluster
   100 0000000E 3A00                        dw kisectors            ; Number of reserved sectors
   101 00000010 00                          db 0                    ; Number of FATs
   102 00000011 0000                        dw 0                    ; Number of dirs in root
   103 00000013 0000                        dw 0                    ; Number of sectors in volume
   104 00000015 00                          db 0                    ; Media descriptor
   105 00000016 0000                        dw 0                    ; Number of sectors per FAT
   106 00000018 0000                        dw 0                    ; Number of sectors per track
   107 0000001A 0000                        dw 0                    ; Number of heads
   108 0000001C 00000000                    dd 0                    ; Number of hidden sectors
   109 00000020 00000000                    dd 0                    ; Large Sectors
   110                                  %endif
   111                                  
   112                                  ; -------- stage 2 loader ------------
   113                                  bits 16
   114                                  alignb 2
   115                                  
   116                                  load_stage2 :
   117 00000024 B80030                      mov  ax,kstack_loc+kstack_size
   118 00000027 89C4                        mov  sp,ax
   119 00000029 31C0                        xor  ax,ax
   120 0000002B 8ED0                        mov  ss,ax
   121 0000002D 8EC0                        mov  es,ax
   122 0000002F 8ED8                        mov  ds,ax
   123 00000031 8EE0                        mov  fs,ax
   124 00000033 8EE8                        mov  gs,ax
   125 00000035 FC                          cld
   126                                  
   127                                      ; debug - pattern the stack so we can see what gets used
   128 00000036 66B811111111                mov  eax,0x11111111
   129 0000003C BF0010                      mov  di,kstack_loc
   130 0000003F B90008                      mov  cx,kstack_size/4
   131 00000042 F366AB                      rep stosd
   132                                  
   133 00000045 52                          push dx                 ; save BIOS drive number
   134                                  
   135 00000046 B80006                      mov  ax,0x0600          ; ah=06h : scroll window up, if al = 0 clrscr
   136 00000049 B90000                      mov  cx,0x0000          ; clear window from 0,0 
   137 0000004C BA4F17                      mov  dx,0x174f          ; to 23,79
   138 0000004F B70F                        mov  bh,0xf             ; fill with hi white
   139 00000051 CD10                        int  0x10               ; clear screen for direct writes to video memory
   140                                  
   141 00000053 BE[C600]                    mov  si,bootmsg
   142 00000056 31DB                        xor  bx,bx
   143 00000058 E85700                      call puts_vga_rm
   144                                                              ; puts_vga_rm leaves gs pointing at video mem
   145 0000005B 65C60601000E                mov  byte [gs:1],0xE    ; turn the first two chars yellow
   146 00000061 65C60603000E                mov  byte [gs:3],0xE
   147                                  
   148                                      ;F - white              
   149                                      ;E - yellow             
   150                                      ;D - magenta            
   151                                      ;C - red                
   152                                      ;B - cyan               
   153                                      ;A - green              
   154                                      ;9 - blue               
   155                                      ;8 - dark grey          
   156                                  
   157 00000067 A1[0002]                    mov  ax,[stage2]        ; check the signature byte
   158 0000006A 0306[0202]                  add  ax,[stage2+2]      ; stage2 might already have been loaded
   159 0000006E 3DA17A                      cmp  ax,0x7a6f+0x32
   160 00000071 741D                        jz   stage2_present
   161                                  
   162                                      ; -------- stage2 boot loader --------
   163                                  
   164                                      ; Assume that the kernel is smaller than whatever space
   165                                      ; is provided prior to file system data structures on the
   166                                      ; boot device, and that it can immediately follow the MBR.
   167                                  
   168 00000073 B402                        mov  ah,02h
   169 00000075 B03A                        mov  al,kisectors       ; number of sectors to load
   170 00000077 BB[0002]                    mov  bx,stage2
   171 0000007A B90200                      mov  cx,2
   172 0000007D 5A                          pop  dx                 ; recover BIOS drive number
   173 0000007E 0E                          push cs
   174 0000007F 07                          pop  es
   175 00000080 CD13                        int  13h
   176 00000082 7211                        jc   ioerr
   177                                  
   178                                      ; ---- make sure second stage actually got loaded
   179                                  
   180 00000084 A1[0002]                    mov  ax,[stage2]        ; check the signature byte
   181 00000087 0306[0202]                  add  ax,[stage2+2]
   182 0000008B 3DA17A                      cmp  ax,0x7a6f+0x32
   183 0000008E 750A                        jnz  s2err
   184                                  stage2_present :
   185 00000090 EA[0902]0000                jmp  0:start_stage2     ; use an absolute jump so stage 1
   186                                                              ; can be position independent
   187                                  
   188                                  ioerr :                     ; ah has status...
   189 00000095 BE[F600]                    mov  si,ioerrmsg
   190 00000098 EB03                        jmp  print_err
   191                                  
   192                                  s2err :
   193 0000009A BE[E000]                    mov  si,s2errmsg
   194                                  print_err :
   195 0000009D BBA000                      mov  bx,160
   196 000000A0 E80F00                      call puts_vga_rm
   197 000000A3 65C60601000C                mov  byte [gs:1],0xC    ; turn the first two vga chars red
   198 000000A9 65C60603000C                mov  byte [gs:3],0xC
   199                                  
   200                                  hang :
   201 000000AF F4                          hlt
   202 000000B0 EBFD                        jmp  hang
   203                                  
   204                                  ; ----------------------------
   205                                  ;   puts_vga_rm - write a null delimited string to the VGA controller
   206                                  ;                 in real mode
   207                                  ;
   208                                  ;    enter:
   209                                  ;            esi - address of string
   210                                  ;            ebx - screen location (2 bytes per char, 160 bytes per line)
   211                                  ;    exit:
   212                                  ;            eax - destroyed
   213                                  ;             gs - set to video memory selector
   214                                  
   215                                  puts_vga_rm :
   216 000000B2 B800B8                      mov  ax,0xb800      ; point gs at video memory
   217 000000B5 8EE8                        mov  gs,ax          
   218                                  puts_vga_rm_loop :
   219 000000B7 AC                          lodsb
   220 000000B8 3C00                        cmp  al,0
   221 000000BA 7409                        jz   puts_vga_rm_done
   222 000000BC 658807                      mov  [gs:bx],al
   223 000000BF 6683C302                    add  ebx,2
   224 000000C3 EBF2                        jmp  puts_vga_rm_loop
   225                                  puts_vga_rm_done :
   226 000000C5 C3                          ret
   227                                  
   228 000000C6 4F5A2076302E30332E-     bootmsg     db      "OZ v0.03.01 - 2015/10/26 ",0
   229 000000CF 3031202D2032303135-
   230 000000D8 2F31302F32362000   
   231 000000E0 73746167652032206C-     s2errmsg    db      "stage 2 load failure ",0
   232 000000E9 6F6164206661696C75-
   233 000000F2 72652000           
   234 000000F6 692F6F206572726F72-     ioerrmsg    db      "i/o error loading stage 2 ",0
   235 000000FF 206C6F6164696E6720-
   236 00000108 737461676520322000 
   237                                  
   238 00000111 00<rept>                times 446-($-$$) db 0       ; fill with zeros up to partition table
   239                                  
   240                                  ; If the kernel is loaded from a disk (including usb) the MBR
   241                                  ; must include a partition table based on the device geometry.
   242                                  ; This gets fed into oz.asm here via usbptbl.inc
   243                                  %ifdef USB
   244                                  %include "usbptbl.inc"
   245 000001BE 80000200060FFEFD    <1> db 0x80,0x00,0x02,0x00,0x06,0x0f,0xfe,0xfd
   246 000001C6 010000003F780F00    <1> db 0x01,0x00,0x00,0x00,0x3f,0x78,0x0f,0x00
   247 000001CE 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   248 000001D6 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   249 000001DE 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   250 000001E6 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   251 000001EE 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   252 000001F6 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   253                                  %else
   254                                      ; If the kernel is placed in memory by some other means
   255                                      ; (PXE, pxelinux, etc.) the partition table is irrelevant
   256                                      ; but the space is still required.  Make the default ptbl
   257                                      ; match a 1.44MB floppy.
   258                                      db 0x80,0x01,0x01,0x00,0x06,0x01,0x12,0x4f
   259                                      db 0x12,0x00,0x00,0x00,0x2e,0x0b,0x00,0x00
   260                                      db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   261                                      db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   262                                      db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   263                                  %endif
   264                                  
   265                                  %ifdef NEWUSB
   266                                  new usb?  gpt correct?
   267                                  0000 01B0: 00 00 00 00 00 2C 44 63  E0 36 03 00 00 00 80 20  .....,Dc .6.....
   268                                  0000 01C0: 21 00 83 9D 11 4C 00 08  00 00 00 C0 12 00 00 9D  !....L.. ........
   269                                  0000 01D0: 12 4C 83 57 25 F2 00 C8  12 00 00 A0 28 00 00 00  .L.W%... ....(...
   270                                  0000 01E0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ........ ........
   271                                  0000 01F0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 AA  ........ ......U.
   272                                  %endif
   273                                  
   274                                  
   275                                  times 510-($-$$) db 0       ; fill with zeros up to MBR signature
   276                                  
   277 000001FE 55AA                                dw 0x0aa55      ; write aa55 in bytes 511,512 to indicate
   278                                                              ; that it is a boot sector. 
   279                                  
   280                                  ; end of MBR
   281                                  ;
   282                                  ; -------- stage 2 ---------------------------------------------------------
   283                                  ;
   284                                  ; If a boot loader only loads 512 bytes in the first pass, the following
   285                                  ; code won't appear in memory until the code above has completed.  Other
   286                                  ; loaders however can load the entire OZ kernel image into memory in one
   287                                  ; shot. (pxe)
   288                                  
   289                                  bits 16
   290                                  
   291                                  stage2 :
   292 00000200 6F7A3200                    db "oz2",0                      ; stage2 signature
   293                                  
   294                                  non_boot_cpu_ljmp_instruction :     ; place this in 16 bit code land
   295 00000204 EA00000000                  jmp word 0:0                    ; so we get the right opcode
   296                                  
   297                                  ; adjust this if you want to change the supported number of cpus
   298                                  max_ncpus_l2   equ 7        ; log2(max_ncpus) (128 => 7)
   299                                  
   300                                  ; adjust this to change the total stack size for all cpus
   301                                  kstack_size_l2 equ 13       ; log2 stack space for all cpus (13 => 8k)
   302                                  
   303                                  kstack_size    equ (1 << kstack_size_l2)
   304                                  
   305                                  ; adjust these if you want to move things around
   306                                  kstack_loc  equ 0x1000      ; base for cpu stacks
   307                                  tss_f08_stk equ 0x6000      ; stack for double fault (grows down from ...)
   308                                  tss_f10_stk equ 0x7000      ; stack for tss fault (grows down from ...)
   309                                  sipi_vector equ 0x7000      ; where the non-boot cpus will start
   310                                  
   311                                  ; ---------------------
   312                                  
   313                                  start_stage2 :
   314                                  
   315                                      ; ---- initialize the 8259's while in real mode
   316                                  
   317 00000209 E8D805                      call irq_init_hardware
   318                                  
   319                                  ; ------------ main kernel entry point ------------
   320                                  ; all cpus enter here
   321                                  main :
   322 0000020C FA                          cli                     ; appears to stabilize recent machines a bit
   323                                  
   324                                      ; -------- enter protected mode --------
   325                                  
   326 0000020D 0F0116[0803]                lgdt [gdtr]             ; initialize the gdt
   327 00000212 0F20C0                      mov  eax,cr0
   328 00000215 0C21                        or   al,0x21            ; set the protected mode bit (lsb of cr0)
   329 00000217 0F22C0                      mov  cr0,eax            ;   and enable the native FPU exceptions ...
   330 0000021A EA[1F02]0800                jmp  codesel:flush_ip1  ; flush the cpu instruction pipeline
   331                                  flush_ip1: 
   332                                  bits 32                     ; instructions after this point are 32bit
   333                                  
   334 0000021F 66B81000                    mov  ax,datasel
   335 00000223 8ED8                        mov  ds,ax              ; initialize the data segments
   336 00000225 8EC0                        mov  es,ax
   337                                  
   338 00000227 B801000000                  mov  eax,1
   339 0000022C 0FC105[14030000]            xadd [ncpus],eax        ; get our unique cpu number
   340                                                              ; could use the lapic id if available
   341 00000233 89C6                        mov  esi,eax
   342 00000235 66B81800                    mov  ax,stacksel        ; setup a restricted stack segment
   343 00000239 8ED0                        mov  ss,ax
   344 0000023B BC00200000                  mov  esp,kstack_size    ; start at the top of the reserved stack space
   345 00000240 89F0                        mov  eax,esi
   346 00000242 C1E006                      shl  eax,(kstack_size_l2 - max_ncpus_l2)    ; kstack_size/max_ncpus * cpu#
   347 00000245 29C4                        sub  esp,eax            ; divvy up the stack
   348                                  
   349 00000247 89F0                        mov  eax,esi
   350 00000249 50                          push eax                ; save cpu index
   351 0000024A 89C3                        mov  ebx,eax
   352 0000024C 80C330                      add  bl,'0'             ; boot cpu announces via ascii 0
   353 0000024F BF9E000000                  mov  edi,160-2          ; last chracter on first line of vga
   354 00000254 D1E0                        shl  eax,1
   355 00000256 29C7                        sub  edi,eax
   356 00000258 66B82000                    mov  ax,videosel        ; point gs at video memory
   357 0000025C 8EE8                        mov  gs,ax
   358 0000025E 65881F                      mov  [gs:edi],bl        ; announce cpu presence
   359 00000261 58                          pop  eax
   360                                  
   361 00000262 09C0                        or   eax,eax            ; are we the boot cpu?
   362 00000264 0F8FD4010000                jg   non_boot_init      ; if not, do non_boot_init
   363                                  
   364                                      ; ---- establish a "pool" of free pyhsical memory
   365                                  
   366 0000026A B810000000                  mov  eax,((kilast+0x1000) >> 12)    ; include a buffer zone
   367 0000026F A3[18030000]                mov  [next_free_page],eax
   368                                  
   369                                      ; ---- setup the paging tables
   370                                  
   371 00000274 E85A020000                  call mem_alloc_kernel_page  ; get a page for pgdir
   372 00000279 C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   373 0000027C 89C7                        mov  edi,eax
   374 0000027E A3[24030000]                mov  [pgdirp],eax
   375 00000283 A3[84010000]                mov  [tss_f08_cr3],eax
   376 00000288 A3[EC010000]                mov  [tss_f10_cr3],eax
   377 0000028D A3[54020000]                mov  [tss0_cr3],eax
   378 00000292 A3[BC020000]                mov  [tss1_cr3],eax
   379 00000297 E837020000                  call mem_alloc_kernel_page  ; get a page for pgtb0
   380 0000029C C1E00C                      shl  eax,12
   381 0000029F 89C2                        mov  edx,eax
   382 000002A1 A3[28030000]                mov  [pgtb0p],eax
   383 000002A6 E828020000                  call mem_alloc_kernel_page  ; get a page for pgtb1
   384 000002AB C1E00C                      shl  eax,12
   385 000002AE 89C1                        mov  ecx,eax
   386 000002B0 A3[2C030000]                mov  [pgtb1p],eax
   387                                  
   388                                              ; first the page directory
   389                                  
   390 000002B5 0F22DF                      mov  cr3,edi            ; install the page directory
   391 000002B8 89D0                        mov  eax,edx
   392 000002BA 83C007                      add  eax,7              ; page table 0: present, pl=3, r/w
   393 000002BD AB                          stosd                   ; ... pl=3 for now (simplify vga access)
   394 000002BE 89C8                        mov  eax,ecx
   395 000002C0 83C007                      add  eax,7              ; page table 1: present, pl=3, r/w
   396 000002C3 AB                          stosd                   ; ... app memory
   397 000002C4 31C0                        xor  eax,eax            ; invalidate the rest of the app laddr space
   398 000002C6 B9FE030000                  mov  ecx,0x400-2        ; (yeah, only one pgdir for kernel+apps for now)
   399 000002CB F3AB                        rep stosd
   400                                  
   401                                              ; pgtb0 is the page table for kernel memory
   402                                  
   403 000002CD 89D7                        mov  edi,edx
   404 000002CF AB                          stosd                   ; access to page 0 will always cause a fault
   405 000002D0 B803100000                  mov  eax,0x1000 + 3     ; rest are direct map: present, pl=0, r/w
   406 000002D5 B9FF030000                  mov  ecx,0x400-1
   407                                  pgtb0_fill :
   408 000002DA AB                          stosd                   ; kernel gets to touch anything it wants < 4MB
   409 000002DB 0500100000                  add  eax,0x1000
   410 000002E0 E2F8                        loop pgtb0_fill
   411                                  
   412                                              ; pgtb1 is the first page table for app code/data/stack it is
   413                                              ; already all zeros (invalid - we'll fill in what we need later)
   414                                  
   415                                              ; enable paging - if we've done it all right, we won't crash
   416                                  
   417 000002E2 0F20C0                      mov  eax,cr0
   418 000002E5 0D00000080                  or   eax,0x80000000     ; msb of cr0
   419 000002EA 0F22C0                      mov  cr0,eax
   420 000002ED EB00                        jmp  flush_ip2          ; flush the cpu instruction pipeline
   421                                  flush_ip2: 
   422                                  
   423                                      ; ---- build the interrupt descriptor table
   424                                  
   425 000002EF E8DF010000                  call mem_alloc_kernel_page  ; get a page for the idt
   426 000002F4 C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   427 000002F7 89C2                        mov  edx,eax
   428 000002F9 A3[10030000]                mov  [idtr_addr],eax
   429                                  
   430 000002FE BE[940D0000]                mov  esi,irq_setup_table
   431 00000303 B900010000                  mov  ecx,irq_setup_table_size
   432                                  irq_init :
   433 00000308 31C0                        xor  eax,eax
   434 0000030A 8902                        mov  [edx],eax                  ; clear the idt entry
   435 0000030C 894202                      mov  [edx+2],eax
   436 0000030F 66AD                        lodsw
   437 00000311 6689C3                      mov  bx,ax
   438 00000314 6625FCFF                    and  ax,strict 0xfffc           ; separate config flags
   439 00000318 6683E303                    and  bx,3                       ; from selector/offset value
   440 0000031C 6683FB02                    cmp  bx,irqt_task               ; task gates are different
   441 00000320 7407                        jz   irq_init_task_gate
   442 00000322 668902                      mov  [edx],ax                   ; store the handler offset
   443 00000325 66B80800                    mov  ax,codesel
   444                                  irq_init_task_gate :
   445 00000329 66894202                    mov  word [edx+2],ax
   446 0000032D 678AA7[900D]                mov  ah,byte [bx+irq_types]
   447 00000332 30C0                        xor  al,al
   448 00000334 66894204                    mov  word [edx+4],ax
   449 00000338 83C208                      add  edx,8
   450 0000033B E2CB                        loop irq_init
   451                                  
   452 0000033D 0F011D[0E030000]            lidt [idtr]                     ; install the idt
   453                                  
   454                                      ; ---- let's see what kind of interrupt hardware we've got
   455                                  
   456 00000344 C605[30030000]00            mov  byte [enabled_lapic],0x0
   457 0000034B B801000000                  mov  eax,1
   458 00000350 0FA2                        cpuid
   459 00000352 83F801                      cmp  eax,1
   460 00000355 720F                        jb   no_lapic
   461 00000357 81E200020000                and  edx,1 << 9         ; lapic feature
   462 0000035D 7407                        jz   no_lapic
   463 0000035F C605[30030000]01            mov  byte [enabled_lapic],0x1
   464                                  no_lapic :
   465                                  
   466                                              ; if enabled, create page table entry for the lapic
   467                                  
   468 00000366 A0[30030000]                mov  al,[enabled_lapic]
   469 0000036B 08C0                        or   al,al
   470 0000036D 7430                        jz   no_lapic_init
   471                                  
   472 0000036F BA0000E0FE                  mov  edx,0xfee00000     ; phys address
   473 00000374 B900100000                  mov  ecx,0x1000         ; length
   474 00000379 E8CB0C0000                  call map_pmem
   475                                  
   476                                      ; do the ioapic while we're at it
   477 0000037E BA0000C0FE                  mov  edx,0xfec00000     ; phys address
   478 00000383 52                          push edx
   479 00000384 B900100000                  mov  ecx,0x1000         ; length
   480 00000389 E8BB0C0000                  call map_pmem
   481 0000038E 5A                          pop  edx
   482 0000038F C70201000000                mov  dword [edx],1
   483 00000395 A11000C0FE                  mov  eax,[0xfec00010]
   484                                  
   485 0000039A E86E040000                  call irq_init_bsp_apic_hardware
   486                                  
   487                                  no_lapic_init :
   488                                  
   489                                      ; ---- setup entry point for non_boot_cpus
   490                                  
   491 0000039F A0[04020000]                mov  al,[non_boot_cpu_ljmp_instruction]     ; get the ljmp instruction
   492 000003A4 A200700000                  mov  [sipi_vector],al                       ; place it at a 4k phys mem boundary
   493 000003A9 C70501700000-               mov  dword [sipi_vector+1],main
   494 000003AF [0C020000]         
   495                                  
   496                                      ; ---- establish a current task
   497                                  
   498 000003B3 31C0                        xor  eax,eax
   499 000003B5 B050                        mov  al,tasksel_k00
   500 000003B7 0F00D8                      ltr  ax
   501                                  
   502                                      ; ---- check for init apps
   503                                  
   504 000003BA BB[20000000]                mov  ebx, kend
   505                                  app_loop :
   506 000003BF 8B4318                      mov  eax, [ebx+0x18]    ; load the entry address
   507 000003C2 813B6F7A6170                cmp  dword [ebx], 0x70617a6f  ; check for "ozap"
   508 000003C8 7402                        jz   have_an_app
   509 000003CA 31C0                        xor  eax, eax           ; no app
   510                                  have_an_app :
   511                                  
   512 000003CC 83F800                      cmp  eax, 0             ; is there an app to run?
   513 000003CF 0F84A8000000                jz   idle               ; if not, idle right away
   514                                  
   515                                      ; ---- setup the init task entry point
   516                                  
   517 000003D5 BF[C0020000]                mov  edi,tss1_eip
   518 000003DA AB                          stosd
   519                                  
   520                                      ; cheat: reuse the same tss, ldt, and page tables for all
   521                                      ; the init apps - this means they run serialy - each has
   522                                      ; to exit for the next one to run
   523                                  
   524 000003DB 31C0                        xor   eax,eax
   525 000003DD A3[A0020000]                mov   [tss1],eax        ; clear out previous task link
   526 000003E2 AB                          stosd                   ; and some registers (flags)
   527 000003E3 AB                          stosd                   ; (eax)
   528 000003E4 AB                          stosd                   ; (ecx)
   529 000003E5 AB                          stosd                   ; (edx)
   530 000003E6 AB                          stosd                   ; (ebx)
   531 000003E7 8B4310                      mov   eax, [ebx+0x10]   ; get the end of the app
   532                                      ;add   eax,0x8001000     ; (this tests app stack page faults)
   533 000003EA AB                          stosd                   ; (esp)
   534 000003EB 31C0                        xor   eax,eax
   535 000003ED AB                          stosd                   ; (ebp)
   536 000003EE AB                          stosd                   ; (esi)
   537 000003EF AB                          stosd                   ; (edi)
   538                                  
   539 000003F0 8B3D[2C030000]              mov  edi,[pgtb1p]       ; rewrite the app's page table
   540 000003F6 89D8                        mov  eax,ebx
   541 000003F8 83C805                      or   eax,5              ; init app code at 0x400000 (4Mb) present and r/o
   542 000003FB AB                          stosd                   ; assume all the init apps are < 4k
   543 000003FC 0502100000                  add  eax,0x1000 + 2     ; add one page for data/bss/stack
   544 00000401 AB                          stosd
   545                                  
   546                                      ; ---- debug marker
   547 00000402 65C605010000000A            mov  byte [gs:1],0xA    ; turn the first two chars green
   548 0000040A 65C605030000000A            mov  byte [gs:3],0xA
   549                                  
   550                                      ; ---- use our current stack for system interrupts during the app
   551                                  
   552 00000412 53                          push ebx
   553 00000413 BF[A4020000]                mov  edi,tss1_esp0
   554 00000418 89E0                        mov  eax,esp
   555 0000041A AB                          stosd
   556                                  
   557                                      ; ---- start the app
   558                                  
   559 0000041B FB                          sti
   560 0000041C 9A000000005800              call tasksel_u00:0
   561 00000423 5B                          pop  ebx
   562                                  
   563                                      ; ---- point to the end of this init app
   564                                  
   565 00000424 0F013D00004000              invlpg [0x400000]       ; FIXME 80386 needs to reload cr3
   566 0000042B 0F013D00104000              invlpg [0x401000]
   567                                  
   568 00000432 8B4310                      mov  eax, [ebx+0x10]    ; load the app end address
   569 00000435 2D00004000                  sub  eax,0x400000
   570 0000043A 01C3                        add  ebx,eax            ; point ebx to the next app
   571 0000043C EB81                        jmp  app_loop
   572                                  
   573                                  ; -------- non-boot cpu initialization --------
   574                                  
   575                                  non_boot_init :
   576                                  
   577 0000043E 0F011D[0E030000]            lidt [idtr]             ; install the global idt
   578                                  
   579                                      ; ---- enable paging
   580                                  
   581 00000445 8B3D[24030000]              mov  edi,[pgdirp]       ; load this cpu's paging register
   582 0000044B 0F22DF                      mov  cr3,edi
   583                                  
   584 0000044E 50                          push eax
   585 0000044F 0F20C0                      mov  eax,cr0            ; enable paging
   586 00000452 0D00000080                  or   eax,0x80000000
   587 00000457 0F22C0                      mov  cr0,eax
   588 0000045A EB00                        jmp  flush_ip3          ; flush the cpu instruction pipeline
   589                                  flush_ip3 : 
   590 0000045C 58                          pop  eax
   591                                  
   592                                      ; ---- limit the number of threads we support here
   593                                  
   594 0000045D 83F810                      cmp  eax,max_threads
   595 00000460 7317                        jae  nb_idle
   596                                  
   597                                      ; ---- init the lapic
   598                                  
   599 00000462 E8EE030000                  call irq_init_ap_apic_hardware
   600                                  
   601                                      ; setup smbase?
   602                                  
   603                                      ; ---- establish a current task
   604                                  
   605 00000467 89C3                        mov  ebx,eax            ; move cpu number to ebx
   606 00000469 E886000000                  call create_tss_pair
   607 0000046E 53                          push ebx
   608 0000046F C1E304                      shl  ebx,4              ; 16x (descriptor_size x2)
   609 00000472 83C350                      add  ebx,tasksel_k00
   610 00000475 0F00DB                      ltr  bx                 ; establish a current task
   611 00000478 5B                          pop  ebx
   612                                  
   613                                      ; test kernel page fault handler
   614                                      ;mov  [321],eax
   615                                  
   616                                  nb_idle :
   617 00000479 FB                          sti
   618 0000047A F4                          hlt                     ; wait for something to do
   619 0000047B EBFC                        jmp  nb_idle            ; (see new_thread)
   620                                  
   621                                      ; -------- boot cpu idle task --------
   622                                      ; could be combined with nb_idle but separating
   623                                      ; these can allow for easier debug
   624                                  
   625                                  idle :
   626 0000047D FB                          sti
   627 0000047E F4                          hlt                     ; wait for interrupts
   628 0000047F EBFC                        jmp  idle
   629                                  
   630                                  
   631                                  ; ----------------------------
   632                                  ;    puts_vga - write a null delimited string to the VGA controller
   633                                  ;               in protected mode
   634                                  ;    enter:
   635                                  ;         esi - address of string
   636                                  ;         ebx - screen location (2 bytes per char, 160 bytes per line)
   637                                  ;    exit:
   638                                  ;         eax - destroyed
   639                                  ;         ebx - next screen location
   640                                  ;          gs - set to video memory selector
   641                                  bits 32
   642                                  
   643                                  puts_vga :
   644 00000481 66B82000                    mov  ax,videosel        ; point gs at video memory
   645 00000485 8EE8                        mov  gs,ax
   646                                  puts_vga_loop :
   647 00000487 2E8A06                      mov  al,[cs:esi]        ; use cs so irq handlers don't
   648 0000048A 46                          inc  esi                ; have to load kernel ds
   649 0000048B 3C00                        cmp  al,0
   650 0000048D 7408                        jz   puts_vga_done
   651 0000048F 658803                      mov  [gs:ebx],al
   652 00000492 83C302                      add  ebx,2
   653 00000495 EBF0                        jmp  puts_vga_loop
   654                                  puts_vga_done :
   655 00000497 C3                          ret
   656                                  
   657                                  ; ----------------------------
   658                                  ;   putx_vga - write the contents of eax in hex to the VGA controller
   659                                  ;              (in protected mode)
   660                                  ;   putbx_vga - write the contents of al in hex to the VGA controller
   661                                  ;
   662                                  ;   enter:
   663                                  ;       eax - value to convert to hex
   664                                  ;       ebx - screen location (2 bytes per char, 160 bytes per line)
   665                                  ;   exit:
   666                                  ;       ebx - next screen location
   667                                  ;        gs - set to video memory selector
   668                                  bits 32
   669                                  
   670                                  putbx_vga :
   671 00000498 51                          push ecx
   672 00000499 B902000000                  mov  ecx,2
   673 0000049E 25FF000000                  and  eax,0xff
   674 000004A3 C1C018                      rol  eax,24
   675 000004A6 EB06                        jmp putx_vga_loop
   676                                  
   677                                  putx_vga :
   678 000004A8 51                          push ecx
   679 000004A9 B908000000                  mov  ecx,8
   680                                  putx_vga_loop :
   681 000004AE C1C004                      rol  eax,4
   682 000004B1 50                          push eax
   683 000004B2 240F                        and  al,0xf
   684 000004B4 3C09                        cmp  al,9
   685 000004B6 7704                        ja   putx_vga_hexdigit
   686 000004B8 0430                        add  al,'0'
   687 000004BA EB02                        jmp short putx_vga_putc
   688                                  putx_vga_hexdigit :
   689 000004BC 0457                        add  al,'a'-10
   690                                  putx_vga_putc :
   691 000004BE 658803                      mov  [gs:ebx],al
   692 000004C1 83C302                      add  ebx,2
   693 000004C4 58                          pop  eax
   694 000004C5 83E0F0                      and  eax,0xfffffff0
   695 000004C8 E2E4                        loop putx_vga_loop
   696 000004CA 65C60320                    mov  byte [gs:ebx],' '
   697 000004CE 83C302                      add  ebx,2
   698 000004D1 59                          pop  ecx
   699 000004D2 C3                          ret
   700                                  
   701                                  ;------------------------------------------------------------------
   702                                  ;   mem_alloc_kernel_page - return the 4k page number of 1 page of memory
   703                                  ;                           from the kernel page pool
   704                                  ;
   705                                  ;   smp safe
   706                                  ;
   707                                  ;   returns:    eax = page number, zero means no pages left
   708                                  
   709                                  mem_alloc_kernel_page :
   710 000004D3 B801000000                  mov  eax,1
   711 000004D8 0FC105[18030000]            xadd [next_free_page],eax   ; atomic, making this re-entrant
   712                                      ; FIXME probably should check for the end of something and return 0
   713 000004DF 50                          push eax
   714 000004E0 51                          push ecx
   715 000004E1 57                          push edi
   716 000004E2 C1E00C                      shl  eax,12
   717 000004E5 B900040000                  mov  ecx,0x1000/4
   718 000004EA 89C7                        mov  edi,eax
   719 000004EC 31C0                        xor  eax,eax
   720 000004EE F3AB                        rep stosd                   ; zero the page
   721 000004F0 5F                          pop  edi
   722 000004F1 59                          pop  ecx
   723 000004F2 58                          pop  eax
   724 000004F3 C3                          ret
   725                                  
   726                                  ;------------------------------------------------------------------
   727                                  ;   create a pair of tss structs for a new cpu
   728                                  ;
   729                                  ;   enter:
   730                                  ;       ebx - cpu number
   731                                  ;   exit:
   732                                  ;       ebx - cpu number
   733                                  
   734                                  create_tss_pair :
   735 000004F4 E8DAFFFFFF                  call mem_alloc_kernel_page
   736 000004F9 09C0                        or   eax,eax
   737 000004FB 0F849C000000                jz   create_tss_pair_fail
   738 00000501 C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   739 00000504 89C7                        mov  edi,eax                ; first tss is the kernel ring 0 thread
   740                                  
   741 00000506 89FE                        mov  esi,edi
   742 00000508 83C668                      add  esi,(tss0_end-tss0)    ; second tss is the user ring 3 thread
   743                                  
   744 0000050B A1[24030000]                mov  eax,[pgdirp]
   745 00000510 89471C                      mov  [edi+(tss0_cr3-tss0)],eax
   746 00000513 89461C                      mov  [esi+(tss0_cr3-tss0)],eax
   747                                  
   748                                      ; user tss gets ldt selectors
   749 00000516 B817000000                  mov  eax,datasel1+7
   750 0000051B 894648                      mov  [esi+(tss0_es-tss0)],eax
   751 0000051E 894650                      mov  [esi+(tss0_ss-tss0)],eax
   752 00000521 894654                      mov  [esi+(tss0_ds-tss0)],eax
   753 00000524 B80F000000                  mov  eax,codesel1+7
   754 00000529 89464C                      mov  [esi+(tss0_cs-tss0)],eax
   755 0000052C B83B000000                  mov  eax,ldtsel1+3
   756 00000531 894660                      mov  [esi+(tss0_ldt-tss0)],eax
   757                                  
   758                                      ; there are three stacks total
   759                                      ;   (1) kernel tss esp0 - placed at the end of this page
   760                                      ;   (2) user tss esp0 (for interrupt handling) - end minus 1k
   761                                      ;   (3) user tss esp - will be set up by new_thread
   762                                  
   763                                      ;mov  eax,stacksel
   764                                      ;mov  [edi+(tss0_ss0-tss0)],eax
   765                                      ;mov  [edi+(tss0_esp0-tss0)],esp ; (1) kernel tss esp0
   766                                  
   767 00000534 B810000000                  mov  eax,datasel
   768 00000539 894708                      mov  [edi+(tss0_ss0-tss0)],eax
   769 0000053C 89F8                        mov  eax,edi
   770 0000053E 0500080000                  add  eax,0x0800                 ; end of the tss page
   771 00000543 894704                      mov  [edi+(tss0_esp0-tss0)],eax ; (1) kernel tss esp0
   772                                  
   773                                      ; sloppy (datasel maps all of physical ram), but better than
   774                                      ; having to set up a separate gdt stacksel for each cpu
   775 00000546 B810000000                  mov  eax,datasel
   776 0000054B 894608                      mov  [esi+(tss0_ss0-tss0)],eax
   777 0000054E 89F8                        mov  eax,edi
   778 00000550 0500100000                  add  eax,0x1000                 ; end of the tss page
   779 00000555 894604                      mov  [esi+(tss0_esp0-tss0)],eax ; (2) user tss esp0
   780                                  
   781                                      ; patch the tss addresses into the reserved gdt selectors
   782                                  
   783 00000558 89DA                        mov  edx,ebx
   784 0000055A C1E204                      shl  edx,4                      ; 16x because selectors are in pairs
   785 0000055D 83C250                      add  edx,tasksel_k00
   786                                  
   787 00000560 89F8                        mov  eax,edi
   788 00000562 C1E818                      shr  eax,24
   789 00000565 8882[07000000]              mov  byte [gdt+edx+7],al        ; base 24-32
   790 0000056B 81E7FFFFFF00                and  edi,0xffffff
   791 00000571 0BBA[02000000]              or   edi,[gdt+edx+2]            ; or in flags
   792 00000577 89BA[02000000]              mov  [gdt+edx+2],edi            ; base 0-23 and flags
   793                                  
   794 0000057D 83C208                      add  edx,8                      ; move to tasksel_uxx
   795                                  
   796 00000580 89F0                        mov  eax,esi
   797 00000582 C1E818                      shr  eax,24
   798 00000585 8882[07000000]              mov  byte [gdt+edx+7],al        ; base 24-32
   799 0000058B 81E6FFFFFF00                and  esi,0xffffff
   800 00000591 0BB2[02000000]              or   esi,[gdt+edx+2]            ; or in flags
   801 00000597 89B2[02000000]              mov  [gdt+edx+2],esi            ; base 0-23 and flags
   802                                  
   803                                  create_tss_pair_fail :
   804 0000059D C3                          ret
   805                                  
   806                                  ; -------- interrupt handlers --------
   807                                  %include "ozirq.asm"
   808                              <1> ; OZ - A more utopian OS    x86-32 interrupts
   809                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
   810                              <1> ;
   811                              <1> ; Copyright (C) 2015  Duane Voth
   812                              <1> ;
   813                              <1> ;   This program is free software: you can redistribute it and/or modify
   814                              <1> ;   it under the terms of the GNU Affero General Public License as
   815                              <1> ;   published by the Free Software Foundation, either version 3 of the
   816                              <1> ;   License, or (at your option) any later version.
   817                              <1> ;
   818                              <1> ;   This program is distributed in the hope that it will be useful,
   819                              <1> ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
   820                              <1> ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   821                              <1> ;   GNU Affero General Public License for more details.
   822                              <1> ;
   823                              <1> ;   You should have received a copy of the GNU Affero General Public License
   824                              <1> ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
   825                              <1> ;
   826                              <1> ;
   827                              <1> ; IRQ handling
   828                              <1> ;
   829                              <1> ; resources:
   830                              <1> ;       http://forum.osdev.org/viewtopic.php?p=107868#107868
   831                              <1> 
   832 0000059E 63707500            <1> cpumsg      db      "cpu",0
   833                              <1> 
   834 000005A2 646976696465206279- <1> int00msg    db      "divide by zero ",0
   835 000005AB 207A65726F2000      <1>
   836 000005B2 646562756720657863- <1> int01msg    db      "debug exception ",0
   837 000005BB 657074696F6E2000    <1>
   838 000005C3 6E6D692000          <1> int02msg    db      "nmi ",0
   839 000005C8 627265616B706F696E- <1> int03msg    db      "breakpoint exception ",0
   840 000005D1 742065786365707469- <1>
   841 000005DA 6F6E2000            <1>
   842 000005DE 6F766572666C6F7720- <1> int04msg    db      "overflow exception ",0
   843 000005E7 657863657074696F6E- <1>
   844 000005F0 2000                <1>
   845 000005F2 626F756E6420657863- <1> int05msg    db      "bound exceeded ",0
   846 000005FB 65656465642000      <1>
   847 00000602 696E76616C6964206F- <1> int06msg    db      "invalid opcode ",0
   848 0000060B 70636F64652000      <1>
   849 00000612 64657669636520756E- <1> int07msg    db      "device unavailable ",0
   850 0000061B 617661696C61626C65- <1>
   851 00000624 2000                <1>
   852 00000626 646F75626C65206661- <1> int08msg    db      "double fault ",0
   853 0000062F 756C742000          <1>
   854 00000634 636F70726F63657373- <1> int09msg    db      "coprocessor segment overrun ",0
   855 0000063D 6F72207365676D656E- <1>
   856 00000646 74206F76657272756E- <1>
   857 0000064F 2000                <1>
   858 00000651 696E76616C69642074- <1> int10msg    db      "invalid tss ",0
   859 0000065A 73732000            <1>
   860 0000065E 7365676D656E74206E- <1> int11msg    db      "segment not present ",0
   861 00000667 6F742070726573656E- <1>
   862 00000670 742000              <1>
   863 00000673 737461636B20666175- <1> int12msg    db      "stack fault ",0
   864 0000067C 6C742000            <1>
   865 00000680 67656E6572616C2070- <1> int13msg    db      "general protection fault ",0
   866 00000689 726F74656374696F6E- <1>
   867 00000692 206661756C742000    <1>
   868 0000069A 6B65726E656C207061- <1> int14kmsg   db      "kernel page fault addr=",0
   869 000006A3 6765206661756C7420- <1>
   870 000006AC 616464723D00        <1>
   871 000006B2 617070207061676520- <1> int14umsg   db      "app page fault addr=",0
   872 000006BB 6661756C7420616464- <1>
   873 000006C4 723D00              <1>
   874 000006C7 666C6F6174696E6720- <1> int16msg    db      "floating point err ",0
   875 000006D0 706F696E7420657272- <1>
   876 000006D9 2000                <1>
   877 000006DB 616C69676E6D656E74- <1> int17msg    db      "alignment check ",0
   878 000006E4 20636865636B2000    <1>
   879 000006EC 6D616368696E652063- <1> int18msg    db      "machine check ",0
   880 000006F5 6865636B2000        <1>
   881 000006FB 73696D6420666C6F61- <1> int19msg    db      "simd floating point err ",0
   882 00000704 74696E6720706F696E- <1>
   883 0000070D 74206572722000      <1>
   884                              <1> 
   885 00000714 687720696E74303220- <1> int34msg    db      "hw int02 ",0
   886 0000071D 00                  <1>
   887 0000071E 687720696E74303320- <1> int35msg    db      "hw int03 ",0
   888 00000727 00                  <1>
   889 00000728 687720696E74303420- <1> int36msg    db      "hw int04 ",0
   890 00000731 00                  <1>
   891 00000732 687720696E74303520- <1> int37msg    db      "hw int05 ",0
   892 0000073B 00                  <1>
   893 0000073C 687720696E74303620- <1> int38msg    db      "hw int06 ",0
   894 00000745 00                  <1>
   895 00000746 687720696E74303720- <1> int39msg    db      "hw int07 ",0
   896 0000074F 00                  <1>
   897 00000750 687720696E74303820- <1> int40msg    db      "hw int08 ",0
   898 00000759 00                  <1>
   899 0000075A 687720696E74303920- <1> int41msg    db      "hw int09 ",0
   900 00000763 00                  <1>
   901 00000764 687720696E74313020- <1> int42msg    db      "hw int10 ",0
   902 0000076D 00                  <1>
   903 0000076E 687720696E74313120- <1> int43msg    db      "hw int11 ",0
   904 00000777 00                  <1>
   905 00000778 687720696E74313220- <1> int44msg    db      "hw int12 ",0
   906 00000781 00                  <1>
   907 00000782 687720696E74313320- <1> int45msg    db      "hw int13 ",0
   908 0000078B 00                  <1>
   909 0000078C 687720696E74313420- <1> int46msg    db      "hw int14 ",0
   910 00000795 00                  <1>
   911 00000796 687720696E74313520- <1> int47msg    db      "hw int15 ",0
   912 0000079F 00                  <1>
   913                              <1> 
   914 000007A0 73707572696F757320- <1> spuriousmsg db      "spurious int ",0
   915 000007A9 696E742000          <1>
   916 000007AE 617069636572722069- <1> apicerrmsg  db      "apicerr int ",0
   917 000007B7 6E742000            <1>
   918 000007BB 68692000            <1> himsg       db      "hi ",0
   919 000007BF 756E6B6E6F776E2073- <1> int255msg           db  "unknown system call ",0
   920 000007C8 797374656D2063616C- <1>
   921 000007D1 6C2000              <1>
   922                              <1> 
   923 000007D4 766D206661756C743A- <1> intvmmsg            db  "vm fault: ",0
   924 000007DD 2000                <1>
   925                              <1> 
   926 000007DF 90                  <1>   align 4
   927 000007E0 00000000            <1> irq_err_lno dd 0
   928                              <1> 
   929                              <1> ; ---- IRQ hardware initialization ----
   930                              <1> 
   931                              <1> bits 16
   932                              <1> 
   933                              <1> irq_init_hardware :
   934                              <1> 
   935                              <1>     ; re-program the 8259's to move the hardware vectors out of the
   936                              <1>     ; soft int range ... C'mon, Intel was pretty clear about this!
   937                              <1> 
   938 000007E4 B011                <1>     mov  al,0x11
   939 000007E6 E620                <1>     out  0x20,al            ; init the 1st 8259
   940 000007E8 B011                <1>     mov  al,0x11
   941 000007EA E6A0                <1>     out  0xA0,al            ; init the 2nd 8259
   942 000007EC B020                <1>     mov  al,apic0_irqbase
   943 000007EE E621                <1>     out  0x21,al            ; base for the 1st 8259
   944 000007F0 B028                <1>     mov  al,apic1_irqbase
   945 000007F2 E6A1                <1>     out  0xA1,al            ; base for the 2nd 8259
   946 000007F4 B004                <1>     mov  al,0x04
   947 000007F6 E621                <1>     out  0x21,al            ; set 1st 8259 as master
   948 000007F8 B002                <1>     mov  al,0x02
   949 000007FA E6A1                <1>     out  0xA1,al            ; set 2nd 8259 as slave
   950 000007FC B001                <1>     mov  al,0x01
   951 000007FE E621                <1>     out  0x21,al
   952 00000800 B001                <1>     mov  al,0x01
   953 00000802 E6A1                <1>     out  0xA1,al
   954 00000804 B0FC                <1>     mov  al,0xfc            ; PIC1 disable all but the timer and kbd
   955 00000806 E621                <1>     out  0x21,al
   956 00000808 B0FF                <1>     mov  al,0xff            ; PIC2 disable everything
   957 0000080A E6A1                <1>     out  0xA1,al
   958 0000080C C3                  <1>     ret
   959                              <1> 
   960                              <1> bits 32
   961                              <1> 
   962                              <1> ; ----------
   963                              <1> 
   964                              <1> irq_init_bsp_apic_hardware :
   965                              <1>     ;jmp  no_apic
   966                              <1> 
   967                              <1>     ; ---- test for an apic
   968                              <1> 
   969 0000080D A17003E0FE          <1>     mov  eax,[0xfee00370]
   970 00000812 2500FFFFFF          <1>     and  eax,0xffffff00
   971 00000817 0DF0000000          <1>     or   eax,apicerr_int
   972 0000081C A37003E0FE          <1>     mov  [0xfee00370],eax   ; setup LVT3 error vector
   973                              <1> 
   974 00000821 B8EF010000          <1>     mov  eax,0x00000100 + spurious_int    ; enable + spurious int
   975 00000826 A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
   976 0000082B B800000001          <1>     mov  eax,0x01000000
   977 00000830 A3D000E0FE          <1>     mov  [0xfee000d0],eax   ; set our LDR
   978 00000835 B8FFFFFFFF          <1>     mov  eax,0xffffffff
   979 0000083A A3E000E0FE          <1>     mov  [0xfee000e0],eax   ; set our DFR
   980 0000083F 31C0                <1>     xor  eax,eax
   981 00000841 A3B000E0FE          <1>     mov  [0xfee000b0],eax   ; eoi anything outstanding
   982                              <1> 
   983                              <1> ;    ; ---- enable the local apic via msr
   984                              <1> ; but apparently not needed ...
   985                              <1> ;    mov  ecx,0x1b
   986                              <1> ;    xor  edx,edx
   987                              <1> ; ;  mov  eax,0xfffff800
   988                              <1> ;    mov  eax,0x00000800
   989                              <1> ;    wrmsr
   990                              <1> ;    mov  eax,[0xfffff030]
   991                              <1> 
   992                              <1>     ; ---- visual indicator: lapic active
   993                              <1> 
   994 00000846 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
   995 0000084A 8EE8                <1>     mov  gs,ax          
   996 0000084C 65C605320000002B    <1>     mov  byte [gs:25*2],'+'
   997                              <1> 
   998 00000854 C3                  <1>     ret
   999                              <1> 
  1000                              <1> ; ----------
  1001                              <1> 
  1002                              <1> irq_init_ap_apic_hardware :
  1003                              <1>     ; eax = cpu number
  1004                              <1> 
  1005                              <1>     ; ---- mtrr for 0xfee00000 -> strong uncachable (UC) ?
  1006                              <1> 
  1007 00000855 50                  <1>     push eax                ; save cpu number
  1008 00000856 89C1                <1>     mov  ecx,eax
  1009 00000858 A0[30030000]        <1>     mov  al,[enabled_lapic]
  1010 0000085D 08C0                <1>     or   al,al
  1011 0000085F 7432                <1>     jz  no_lapic_init2
  1012                              <1> 
  1013 00000861 BB00000001          <1>     mov  ebx,0x01000000
  1014 00000866 D3E3                <1>     shl  ebx,cl             ; bit mask based on cpu number
  1015 00000868 891DD000E0FE        <1>     mov  [0xfee000d0],ebx   ; set our LDR
  1016                              <1> 
  1017 0000086E A17003E0FE          <1>     mov  eax,[0xfee00370]
  1018 00000873 2500FFFFFF          <1>     and  eax,0xffffff00
  1019 00000878 0DF0000000          <1>     or   eax,apicerr_int
  1020 0000087D A37003E0FE          <1>     mov  [0xfee00370],eax   ; setup LVT3 error vector
  1021                              <1> 
  1022 00000882 B8EF010000          <1>     mov  eax,0x00000100 + spurious_int  ; enable + spurious int
  1023 00000887 A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
  1024 0000088C 31C0                <1>     xor  eax,eax
  1025 0000088E A3B000E0FE          <1>     mov  [0xfee000b0],eax   ; eoi anything outstanding
  1026                              <1> no_lapic_init2 :
  1027 00000893 58                  <1>     pop  eax
  1028 00000894 C3                  <1>     ret
  1029                              <1> 
  1030                              <1> ; ---- IRQ handlers ----
  1031                              <1> 
  1032 00000895 90<rept>            <1> align 4
  1033                              <1> int_handler_div0 :
  1034 00000898 56                  <1>     push esi
  1035 00000899 BE[A2050000]        <1>     mov  esi,int00msg
  1036 0000089E E861040000          <1>     call irq_print_msg
  1037 000008A3 5E                  <1>     pop  esi
  1038 000008A4 E9EC000000          <1>     jmp  int_handler_show_eip
  1039                              <1> 
  1040 000008A9 90<rept>            <1> align 4
  1041                              <1> int_handler_debug :
  1042 000008AC 56                  <1>     push esi
  1043 000008AD BE[B2050000]        <1>     mov  esi,int01msg
  1044 000008B2 E84D040000          <1>     call irq_print_msg
  1045 000008B7 5E                  <1>     pop  esi
  1046 000008B8 E9D8000000          <1>     jmp  int_handler_show_eip
  1047                              <1> 
  1048 000008BD 90<rept>            <1> align 4
  1049                              <1> int_handler_nmi :
  1050 000008C0 56                  <1>     push esi
  1051 000008C1 BE[C3050000]        <1>     mov  esi,int02msg
  1052 000008C6 E839040000          <1>     call irq_print_msg
  1053 000008CB 5E                  <1>     pop  esi
  1054 000008CC CF                  <1>     iret
  1055                              <1>     ;jmp  reboot_on_alt_key
  1056                              <1> 
  1057 000008CD 90<rept>            <1> align 4
  1058                              <1> int_handler_brkp :
  1059 000008D0 56                  <1>     push esi
  1060 000008D1 BE[C8050000]        <1>     mov  esi,int03msg
  1061 000008D6 E829040000          <1>     call irq_print_msg
  1062 000008DB 5E                  <1>     pop  esi
  1063 000008DC E9B4000000          <1>     jmp  int_handler_show_eip
  1064                              <1> 
  1065 000008E1 90<rept>            <1> align 4
  1066                              <1> int_handler_ovrflw :
  1067 000008E4 56                  <1>     push esi
  1068 000008E5 BE[DE050000]        <1>     mov  esi,int04msg
  1069 000008EA E815040000          <1>     call irq_print_msg
  1070 000008EF 5E                  <1>     pop  esi
  1071 000008F0 E9A0000000          <1>     jmp  int_handler_show_eip
  1072                              <1> 
  1073 000008F5 90<rept>            <1> align 4
  1074                              <1> int_handler_bound :
  1075 000008F8 56                  <1>     push esi
  1076 000008F9 BE[F2050000]        <1>     mov  esi,int05msg
  1077 000008FE E801040000          <1>     call irq_print_msg
  1078 00000903 5E                  <1>     pop  esi
  1079 00000904 E98C000000          <1>     jmp  int_handler_show_eip
  1080                              <1> 
  1081 00000909 90<rept>            <1> align 4
  1082                              <1> int_handler_invop :
  1083 0000090C 56                  <1>     push esi
  1084 0000090D BE[02060000]        <1>     mov  esi,int06msg
  1085 00000912 E8ED030000          <1>     call irq_print_msg
  1086 00000917 5E                  <1>     pop  esi
  1087 00000918 EB7B                <1>     jmp  int_handler_show_eip
  1088                              <1> 
  1089 0000091A 90<rept>            <1> align 4
  1090                              <1> int_handler_devna :
  1091                              <1>     ;push esi
  1092                              <1>     ;mov  esi,int07msg
  1093                              <1>     ;call irq_print_msg
  1094                              <1>     ;pop  esi
  1095                              <1>     ; FIXME fxsave/fxrestore the fpu/sse/mmx regs
  1096 0000091C 0F06                <1>     clts                ; sure! you can use the fpu
  1097 0000091E CF                  <1>     iret
  1098                              <1> 
  1099 0000091F 90                  <1> align 4
  1100                              <1> int_handler_cpsego :
  1101 00000920 56                  <1>     push esi
  1102 00000921 BE[34060000]        <1>     mov  esi,int09msg
  1103 00000926 E8D9030000          <1>     call irq_print_msg
  1104 0000092B 5E                  <1>     pop  esi
  1105 0000092C EB67                <1>     jmp  int_handler_show_eip
  1106                              <1> 
  1107 0000092E 90<rept>            <1> align 4
  1108                              <1> int_handler_segnp :
  1109                              <1>     ; ec = seg selector
  1110 00000930 56                  <1>     push esi
  1111 00000931 BE[5E060000]        <1>     mov  esi,int11msg
  1112 00000936 E8C9030000          <1>     call irq_print_msg
  1113 0000093B 5E                  <1>     pop  esi
  1114 0000093C EB32                <1>     jmp  int_handler_show_ec_eip
  1115                              <1> 
  1116 0000093E 90<rept>            <1> align 4
  1117                              <1> int_handler_stkflt :
  1118                              <1>     ; ec = seg selector
  1119 00000940 56                  <1>     push esi
  1120 00000941 BE[73060000]        <1>     mov  esi,int12msg
  1121 00000946 E8B9030000          <1>     call irq_print_msg
  1122 0000094B 5E                  <1>     pop  esi
  1123 0000094C B904000000          <1>     mov  ecx,4
  1124 00000951 83C302              <1>     add  ebx,2
  1125                              <1> int_handler_show_stack_loop :
  1126 00000954 58                  <1>     pop  eax
  1127 00000955 E84EFBFFFF          <1>     call putx_vga
  1128 0000095A E2F8                <1>     loop int_handler_show_stack_loop
  1129 0000095C E9F7030000          <1>     jmp  reboot_on_alt_key
  1130                              <1> 
  1131 00000961 90<rept>            <1> align 4
  1132                              <1> int_handler_gpf :
  1133                              <1>     ; ec = various ...
  1134                              <1>     ;test dword [esp+0xc],1 << 17    ; check the eflags vm bit
  1135                              <1>     ;jnz  int_handler_vm_gpf
  1136                              <1> 
  1137 00000964 56                  <1>     push esi
  1138 00000965 BE[80060000]        <1>     mov  esi,int13msg
  1139 0000096A E895030000          <1>     call irq_print_msg
  1140 0000096F 5E                  <1>     pop  esi
  1141                              <1> int_handler_show_ec_eip :
  1142 00000970 65C60365            <1>     mov  byte [gs:ebx],'e'
  1143 00000974 83C302              <1>     add  ebx,2
  1144 00000977 65C60363            <1>     mov  byte [gs:ebx],'c'
  1145 0000097B 83C302              <1>     add  ebx,2
  1146 0000097E 65C6033D            <1>     mov  byte [gs:ebx],'='
  1147 00000982 83C302              <1>     add  ebx,2
  1148 00000985 58                  <1>     pop  eax                ; ec
  1149 00000986 E80DFBFFFF          <1>     call putbx_vga
  1150 0000098B 83EB02              <1>     sub  ebx,2
  1151 0000098E 65C60320            <1>     mov  byte [gs:ebx],' '
  1152 00000992 83C302              <1>     add  ebx,2
  1153                              <1> int_handler_show_eip :
  1154 00000995 65C60363            <1>     mov  byte [gs:ebx],'c'
  1155 00000999 83C302              <1>     add  ebx,2
  1156 0000099C 65C60373            <1>     mov  byte [gs:ebx],'s'
  1157 000009A0 83C302              <1>     add  ebx,2
  1158 000009A3 65C6033A            <1>     mov  byte [gs:ebx],':'
  1159 000009A7 83C302              <1>     add  ebx,2
  1160 000009AA 65C60365            <1>     mov  byte [gs:ebx],'e'
  1161 000009AE 83C302              <1>     add  ebx,2
  1162 000009B1 65C60369            <1>     mov  byte [gs:ebx],'i'
  1163 000009B5 83C302              <1>     add  ebx,2
  1164 000009B8 65C60370            <1>     mov  byte [gs:ebx],'p'
  1165 000009BC 83C302              <1>     add  ebx,2
  1166 000009BF 65C6033D            <1>     mov  byte [gs:ebx],'='
  1167 000009C3 83C302              <1>     add  ebx,2
  1168 000009C6 5A                  <1>     pop  edx                ; eip
  1169 000009C7 58                  <1>     pop  eax                ; cs
  1170 000009C8 E8DBFAFFFF          <1>     call putx_vga
  1171 000009CD 83EB02              <1>     sub  ebx,2
  1172 000009D0 65C6033A            <1>     mov  byte [gs:ebx],':'
  1173 000009D4 83C302              <1>     add  ebx,2
  1174 000009D7 89D0                <1>     mov  eax,edx
  1175 000009D9 E8CAFAFFFF          <1>     call putx_vga
  1176 000009DE E975030000          <1>     jmp  reboot_on_alt_key
  1177                              <1> 
  1178                              <1> int_handler_vm_gpf :
  1179 000009E3 53                  <1>     push ebx
  1180                              <1>     ;mov  ebx,[esp+8]        ; faulter's eip
  1181 000009E4 2E8A1B              <1>     mov  bl,[cs:ebx]        ; get the opcode that caused the fault
  1182 000009E7 80FBF4              <1>     cmp  bl,0xf4            ; 'hlt' is ok
  1183 000009EA 7452                <1>     jz   int_handler_vm_normal_return
  1184                              <1> 
  1185 000009EC 56                  <1>     push esi
  1186 000009ED 50                  <1>     push eax
  1187 000009EE 53                  <1>     push ebx
  1188 000009EF BE[D4070000]        <1>     mov  esi,intvmmsg
  1189 000009F4 E80B030000          <1>     call irq_print_msg
  1190 000009F9 65C6036F            <1>     mov  byte [gs:ebx],'o'
  1191 000009FD 83C302              <1>     add  ebx,2
  1192 00000A00 65C60370            <1>     mov  byte [gs:ebx],'p'
  1193 00000A04 83C302              <1>     add  ebx,2
  1194 00000A07 65C60363            <1>     mov  byte [gs:ebx],'c'
  1195 00000A0B 83C302              <1>     add  ebx,2
  1196 00000A0E 65C6036F            <1>     mov  byte [gs:ebx],'o'
  1197 00000A12 83C302              <1>     add  ebx,2
  1198 00000A15 65C60364            <1>     mov  byte [gs:ebx],'d'
  1199 00000A19 83C302              <1>     add  ebx,2
  1200 00000A1C 65C60365            <1>     mov  byte [gs:ebx],'e'
  1201 00000A20 83C302              <1>     add  ebx,2
  1202 00000A23 65C60328            <1>     mov  byte [gs:ebx],'('
  1203 00000A27 83C302              <1>     add  ebx,2
  1204 00000A2A 58                  <1>     pop  eax
  1205 00000A2B 25FF000000          <1>     and  eax,0xff
  1206 00000A30 E863FAFFFF          <1>     call putbx_vga
  1207 00000A35 83C302              <1>     add  ebx,2
  1208 00000A38 65C60329            <1>     mov  byte [gs:ebx],')'
  1209 00000A3C 58                  <1>     pop  eax
  1210 00000A3D 5E                  <1>     pop  esi
  1211                              <1> int_handler_vm_normal_return :
  1212 00000A3E 5B                  <1>     pop  ebx
  1213                              <1> 
  1214 00000A3F FF74240C            <1>     push dword [esp+0xc]    ; eflags
  1215 00000A43 9D                  <1>     popf                    ; restore the VM and NT flags
  1216 00000A44 CF                  <1>     iret                    ; chain back via nested task
  1217                              <1>                             ; from v86 tss to original caller
  1218                              <1> 
  1219 00000A45 90<rept>            <1> align 4
  1220                              <1> int_handler_pgflt :
  1221 00000A48 58                  <1>     pop  eax
  1222 00000A49 50                  <1>     push eax
  1223 00000A4A A904000000          <1>     test eax,0x4                        ; user mode or supervisor?
  1224 00000A4F 7407                <1>     jz   int_handler_pgflt_bad_kaddr    ; if not, kernel failed
  1225                              <1> 
  1226                              <1> int_handler_pgflt_bad_uaddr :
  1227 00000A51 BE[B2060000]        <1>     mov  esi,int14umsg
  1228 00000A56 EB05                <1>     jmp  int_handler_pgflt_msg
  1229                              <1> 
  1230                              <1> int_handler_pgflt_bad_kaddr :
  1231 00000A58 BE[9A060000]        <1>     mov  esi,int14kmsg
  1232                              <1> 
  1233                              <1> int_handler_pgflt_msg :
  1234 00000A5D E8A2020000          <1>     call irq_print_msg
  1235 00000A62 0F20D0              <1>     mov  eax,cr2
  1236 00000A65 E83EFAFFFF          <1>     call putx_vga                       ; print the addres of the fault
  1237 00000A6A E901FFFFFF          <1>     jmp  int_handler_show_ec_eip
  1238                              <1> 
  1239 00000A6F 90                  <1> align 4
  1240                              <1> int_handler_fpuerr :
  1241 00000A70 56                  <1>     push esi
  1242 00000A71 BE[C7060000]        <1>     mov  esi,int16msg
  1243 00000A76 E889020000          <1>     call irq_print_msg
  1244                              <1>     ; FIXME flags identify error
  1245                              <1>     ;   IS - FPU stack overflow
  1246                              <1>     ;   IA - Invalid arithmetic operation
  1247                              <1>     ;   Z  - Divide by zero
  1248                              <1>     ;   D  - Source operand is a denormal number
  1249                              <1>     ;   O  - Overflow in result
  1250                              <1>     ;   U  - Underflow in result
  1251                              <1>     ;   P  - Inexact result
  1252 00000A7B E915FFFFFF          <1>     jmp  int_handler_show_eip
  1253                              <1> 
  1254                              <1> align 4
  1255                              <1> int_handler_algnchk :
  1256                              <1>     ; ec = zero
  1257 00000A80 56                  <1>     push esi
  1258 00000A81 BE[DB060000]        <1>     mov  esi,int17msg
  1259 00000A86 E879020000          <1>     call irq_print_msg
  1260 00000A8B 5E                  <1>     pop  esi
  1261 00000A8C 58                  <1>     pop  eax                    ; toss the ec
  1262 00000A8D E903FFFFFF          <1>     jmp  int_handler_show_eip
  1263                              <1> 
  1264 00000A92 90<rept>            <1> align 4
  1265                              <1> int_handler_machchk :
  1266 00000A94 56                  <1>     push esi
  1267 00000A95 BE[EC060000]        <1>     mov  esi,int18msg
  1268 00000A9A E865020000          <1>     call irq_print_msg
  1269 00000A9F 5E                  <1>     pop  esi
  1270 00000AA0 E9F0FEFFFF          <1>     jmp  int_handler_show_eip
  1271                              <1> 
  1272 00000AA5 90<rept>            <1> align 4
  1273                              <1> int_handler_simdfpe :
  1274 00000AA8 56                  <1>     push esi
  1275 00000AA9 BE[FB060000]        <1>     mov  esi,int19msg
  1276 00000AAE E851020000          <1>     call irq_print_msg
  1277 00000AB3 5E                  <1>     pop  esi
  1278 00000AB4 E9DCFEFFFF          <1>     jmp  int_handler_show_eip
  1279                              <1> 
  1280 00000AB9 90<rept>            <1> align 4
  1281                              <1> int_handler_timer :     
  1282 00000ABC 50                  <1>     push eax
  1283 00000ABD 53                  <1>     push ebx
  1284 00000ABE 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
  1285 00000AC2 8EE8                <1>     mov  gs,ax          
  1286 00000AC4 658A1D01000000      <1>     mov  bl,byte [gs:1]     ; inc the color of the first two chars
  1287 00000ACB FEC3                <1>     inc  bl
  1288 00000ACD 80E30F              <1>     and  bl,0xf             ; just the foreground
  1289 00000AD0 65881D01000000      <1>     mov  byte [gs:1],bl
  1290 00000AD7 65881D03000000      <1>     mov  byte [gs:3],bl
  1291 00000ADE 5B                  <1>     pop  ebx
  1292                              <1> 
  1293                              <1>     ; ---- wakeup any sleeping cpus (see syscall_sleep)
  1294                              <1> 
  1295 00000ADF A0[30030000]        <1>     mov  al,[enabled_lapic]
  1296 00000AE4 08C0                <1>     or   al,al
  1297 00000AE6 741B                <1>     jz   no_sleepers
  1298                              <1> 
  1299                              <1>     ; the race here is not important, we'll catch them on the next tick
  1300                              <1> 
  1301 00000AE8 A1[1C030000]        <1>     mov  eax,[sleepers]
  1302 00000AED 09C0                <1>     or   eax,eax
  1303 00000AEF 7412                <1>     jz   no_sleepers
  1304 00000AF1 C1E018              <1>     shl  eax,24                     ; FIXME can only handle 8 cpus
  1305 00000AF4 A31003E0FE          <1>     mov  dword [0xfee00310],eax     ; via the destination register ...
  1306 00000AF9 B8FE480000          <1>     mov  eax,0x04800 + wakeup_int   ; no shrthnd, fixed, logical, edge
  1307 00000AFE A30003E0FE          <1>     mov  dword [0xfee00300],eax
  1308                              <1> 
  1309                              <1> no_sleepers :
  1310 00000B03 B020                <1>     mov  al,0x20        
  1311 00000B05 E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1312 00000B07 58                  <1>     pop  eax
  1313 00000B08 CF                  <1>     iret                
  1314                              <1> 
  1315 00000B09 90<rept>            <1> align 4
  1316                              <1> int_handler_kbd :
  1317 00000B0C 50                  <1>     push eax
  1318 00000B0D 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
  1319 00000B11 8EE8                <1>     mov  gs,ax          
  1320                              <1> 
  1321 00000B13 53                  <1>     push ebx
  1322 00000B14 BB3C000000          <1>     mov  ebx,30*2
  1323 00000B19 E460                <1>     in   al,0x60
  1324 00000B1B 50                  <1>     push eax
  1325 00000B1C E877F9FFFF          <1>     call putbx_vga
  1326 00000B21 58                  <1>     pop  eax
  1327                              <1> 
  1328 00000B22 3C53                <1>     cmp  al,0x53            ; scan code for the DEL key
  1329 00000B24 0F8434020000        <1>     jz   reboot
  1330                              <1> 
  1331 00000B2A 65A044000000        <1>     mov  al,[gs:34*2]
  1332 00000B30 FEC0                <1>     inc  al
  1333 00000B32 65A244000000        <1>     mov  [gs:34*2],al       ; change a character on screen
  1334 00000B38 5B                  <1>     pop  ebx
  1335                              <1> 
  1336 00000B39 B020                <1>     mov  al,0x20
  1337 00000B3B E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1338                              <1> 
  1339 00000B3D 58                  <1>     pop  eax
  1340 00000B3E CF                  <1>     iret
  1341                              <1> 
  1342 00000B3F 90                  <1> align 4
  1343                              <1> int_handler_hw02 :          ; cascade
  1344 00000B40 56                  <1>     push esi
  1345 00000B41 BE[14070000]        <1>     mov  esi,int34msg
  1346 00000B46 E8B9010000          <1>     call irq_print_msg
  1347 00000B4B 5E                  <1>     pop  esi
  1348 00000B4C E907020000          <1>     jmp  reboot_on_alt_key
  1349                              <1> 
  1350 00000B51 90<rept>            <1> align 4
  1351                              <1> int_handler_hw03 :          ; serial port 2
  1352 00000B54 56                  <1>     push esi
  1353 00000B55 BE[1E070000]        <1>     mov  esi,int35msg
  1354 00000B5A E8A5010000          <1>     call irq_print_msg
  1355 00000B5F 5E                  <1>     pop  esi
  1356 00000B60 E9F3010000          <1>     jmp  reboot_on_alt_key
  1357                              <1> 
  1358 00000B65 90<rept>            <1> align 4
  1359                              <1> int_handler_hw04 :          ; serial port 1
  1360 00000B68 56                  <1>     push esi
  1361 00000B69 BE[28070000]        <1>     mov  esi,int36msg
  1362 00000B6E E891010000          <1>     call irq_print_msg
  1363 00000B73 5E                  <1>     pop  esi
  1364 00000B74 E9DF010000          <1>     jmp  reboot_on_alt_key
  1365                              <1> 
  1366 00000B79 90<rept>            <1> align 4
  1367                              <1> int_handler_hw05 :          ; parallel port 2 or sound card
  1368 00000B7C 56                  <1>     push esi
  1369 00000B7D BE[32070000]        <1>     mov  esi,int37msg
  1370 00000B82 E87D010000          <1>     call irq_print_msg
  1371 00000B87 5E                  <1>     pop  esi
  1372 00000B88 E9CB010000          <1>     jmp  reboot_on_alt_key
  1373                              <1> 
  1374 00000B8D 90<rept>            <1> align 4
  1375                              <1> int_handler_hw06 :          ; floppy disk controller
  1376 00000B90 56                  <1>     push esi
  1377 00000B91 BE[3C070000]        <1>     mov  esi,int38msg
  1378 00000B96 E869010000          <1>     call irq_print_msg
  1379 00000B9B 5E                  <1>     pop  esi
  1380 00000B9C E9B7010000          <1>     jmp  reboot_on_alt_key
  1381                              <1> 
  1382 00000BA1 90<rept>            <1> align 4
  1383                              <1> int_handler_hw07 :          ; parallel port 1
  1384 00000BA4 56                  <1>     push esi
  1385 00000BA5 BE[46070000]        <1>     mov  esi,int39msg
  1386 00000BAA E855010000          <1>     call irq_print_msg
  1387 00000BAF 5E                  <1>     pop  esi
  1388 00000BB0 B020                <1>     mov  al,0x20
  1389 00000BB2 E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1390 00000BB4 CF                  <1>     iret
  1391                              <1>     ;jmp  reboot_on_alt_key
  1392                              <1> 
  1393 00000BB5 90<rept>            <1> align 4
  1394                              <1> int_handler_hw08 :          ; RTC
  1395 00000BB8 56                  <1>     push esi
  1396 00000BB9 BE[50070000]        <1>     mov  esi,int40msg
  1397 00000BBE E841010000          <1>     call irq_print_msg
  1398 00000BC3 5E                  <1>     pop  esi
  1399 00000BC4 E98F010000          <1>     jmp  reboot_on_alt_key
  1400                              <1> 
  1401 00000BC9 90<rept>            <1> align 4
  1402                              <1> int_handler_hw09 :          ; acpi
  1403 00000BCC 56                  <1>     push esi
  1404 00000BCD BE[5A070000]        <1>     mov  esi,int41msg
  1405 00000BD2 E82D010000          <1>     call irq_print_msg
  1406 00000BD7 5E                  <1>     pop  esi
  1407 00000BD8 E97B010000          <1>     jmp  reboot_on_alt_key
  1408                              <1> 
  1409 00000BDD 90<rept>            <1> align 4
  1410                              <1> int_handler_hw10 :
  1411 00000BE0 56                  <1>     push esi
  1412 00000BE1 BE[64070000]        <1>     mov  esi,int42msg
  1413 00000BE6 E819010000          <1>     call irq_print_msg
  1414 00000BEB 5E                  <1>     pop  esi
  1415 00000BEC E967010000          <1>     jmp  reboot_on_alt_key
  1416                              <1> 
  1417 00000BF1 90<rept>            <1> align 4
  1418                              <1> int_handler_hw11 :
  1419 00000BF4 56                  <1>     push esi
  1420 00000BF5 BE[6E070000]        <1>     mov  esi,int43msg
  1421 00000BFA E805010000          <1>     call irq_print_msg
  1422 00000BFF 5E                  <1>     pop  esi
  1423 00000C00 E953010000          <1>     jmp  reboot_on_alt_key
  1424                              <1> 
  1425 00000C05 90<rept>            <1> align 4
  1426                              <1> int_handler_hw12 :          ; mouse
  1427 00000C08 56                  <1>     push esi
  1428 00000C09 BE[78070000]        <1>     mov  esi,int44msg
  1429 00000C0E E8F1000000          <1>     call irq_print_msg
  1430 00000C13 5E                  <1>     pop  esi
  1431 00000C14 E93F010000          <1>     jmp  reboot_on_alt_key
  1432                              <1> 
  1433 00000C19 90<rept>            <1> align 4
  1434                              <1> int_handler_hw13 :          ; co-processor
  1435 00000C1C 56                  <1>     push esi
  1436 00000C1D BE[82070000]        <1>     mov  esi,int45msg
  1437 00000C22 E8DD000000          <1>     call irq_print_msg
  1438 00000C27 5E                  <1>     pop  esi
  1439 00000C28 E92B010000          <1>     jmp  reboot_on_alt_key
  1440                              <1> 
  1441 00000C2D 90<rept>            <1> align 4
  1442                              <1> int_handler_hw14 :          ; ata disk controller primary
  1443 00000C30 56                  <1>     push esi
  1444 00000C31 BE[8C070000]        <1>     mov  esi,int46msg
  1445 00000C36 E8C9000000          <1>     call irq_print_msg
  1446 00000C3B 5E                  <1>     pop  esi
  1447 00000C3C E917010000          <1>     jmp  reboot_on_alt_key
  1448                              <1> 
  1449 00000C41 90<rept>            <1> align 4
  1450                              <1> int_handler_hw15 :          ; ata disk controller secondary
  1451 00000C44 56                  <1>     push esi
  1452 00000C45 BE[96070000]        <1>     mov  esi,int47msg
  1453 00000C4A E8B5000000          <1>     call irq_print_msg
  1454 00000C4F 5E                  <1>     pop  esi
  1455 00000C50 E903010000          <1>     jmp  reboot_on_alt_key
  1456                              <1> 
  1457                              <1> ; called via the double fault task
  1458 00000C55 90<rept>            <1> align 4
  1459                              <1> int_handler_tg_dblflt :
  1460 00000C58 56                  <1>     push esi
  1461 00000C59 BE[26060000]        <1>     mov  esi,int08msg
  1462 00000C5E E8A1000000          <1>     call irq_print_msg
  1463 00000C63 5E                  <1>     pop  esi
  1464 00000C64 E9EF000000          <1>     jmp  reboot_on_alt_key
  1465                              <1> 
  1466                              <1> ; called via the invalid tss task
  1467 00000C69 90<rept>            <1> align 4
  1468                              <1> int_handler_tg_invtss :
  1469 00000C6C 56                  <1>     push esi
  1470 00000C6D BE[51060000]        <1>     mov  esi,int10msg
  1471 00000C72 E88D000000          <1>     call irq_print_msg
  1472 00000C77 5E                  <1>     pop  esi
  1473                              <1>     ; FIXME need to go back to previous tss to get ec via that stack
  1474 00000C78 83C302              <1>     add  ebx,2
  1475 00000C7B 58                  <1>     pop  eax                ; ec == invalid tss selector
  1476 00000C7C E827F8FFFF          <1>     call putx_vga
  1477 00000C81 E9D2000000          <1>     jmp  reboot_on_alt_key
  1478                              <1> 
  1479 00000C86 90<rept>            <1> align 4
  1480                              <1> int_handler_spurious :
  1481 00000C88 56                  <1>     push esi
  1482 00000C89 BE[A0070000]        <1>     mov  esi,spuriousmsg
  1483 00000C8E E871000000          <1>     call irq_print_msg
  1484 00000C93 5E                  <1>     pop  esi
  1485 00000C94 CF                  <1>     iret
  1486                              <1> 
  1487 00000C95 90<rept>            <1> align 4
  1488                              <1> int_handler_apicerr :
  1489 00000C98 56                  <1>     push esi
  1490 00000C99 BE[AE070000]        <1>     mov  esi,apicerrmsg
  1491 00000C9E E861000000          <1>     call irq_print_msg
  1492 00000CA3 5E                  <1>     pop  esi
  1493 00000CA4 CF                  <1>     iret
  1494                              <1> 
  1495                              <1> ; serves only to eoi the fixed ipi used for sleep wakeup
  1496 00000CA5 90<rept>            <1> align 4
  1497                              <1> wakeup :
  1498 00000CA8 50                  <1>     push eax
  1499 00000CA9 31C0                <1>     xor  eax,eax
  1500 00000CAB A3B000E0FE          <1>     mov  [0xfee000b0],eax    ; lapic eoi
  1501 00000CB0 58                  <1>     pop  eax
  1502 00000CB1 CF                  <1>     iret
  1503                              <1> 
  1504                              <1> 
  1505 00000CB2 90<rept>            <1> align 4
  1506                              <1> ; %if ($ >= 0x8000) bomb
  1507                              <1> sysent :
  1508 00000CB4 3D00020000          <1>     cmp  eax,0x0200
  1509 00000CB9 0F84D5020000        <1>     jz   syscall_klog
  1510 00000CBF 3D00100000          <1>     cmp  eax,0x1000
  1511 00000CC4 0F84DF020000        <1>     jz   syscall_ncpus
  1512 00000CCA 3D00200000          <1>     cmp  eax,0x2000
  1513 00000CCF 0F8439030000        <1>     jz   syscall_sleep
  1514 00000CD5 3D00210000          <1>     cmp  eax,0x2100
  1515 00000CDA 0F84CF020000        <1>     jz   syscall_new_thread
  1516 00000CE0 3D00270000          <1>     cmp  eax,0x2700
  1517 00000CE5 0F8458030000        <1>     jz   syscall_request_pmem_access
  1518 00000CEB 3D00FE0000          <1>     cmp  eax,0xfe00
  1519 00000CF0 0F84AD020000        <1>     jz   syscall_sipi_vector
  1520 00000CF6 BE[BF070000]        <1>     mov  esi,int255msg
  1521 00000CFB E804000000          <1>     call irq_print_msg
  1522 00000D00 31C0                <1>     xor  eax,eax
  1523 00000D02 48                  <1>     dec  eax
  1524 00000D03 CF                  <1>     iret
  1525                              <1> 
  1526                              <1> 
  1527                              <1> ; ---- IRQ support code ---- 
  1528                              <1> 
  1529                              <1> irq_print_msg :
  1530 00000D04 B801000000          <1>     mov  eax,1
  1531 00000D09 0FC105[E0070000]    <1>     xadd [irq_err_lno],eax
  1532 00000D10 50                  <1>     push eax                ; remember line number
  1533 00000D11 83E003              <1>     and  eax,0x3            ; only four lines
  1534 00000D14 40                  <1>     inc  eax                ; start with line 1
  1535 00000D15 BBA0000000          <1>     mov  ebx,160            ; vga line length
  1536 00000D1A 0FAFC3              <1>     imul eax,ebx
  1537 00000D1D 89C3                <1>     mov  ebx,eax
  1538                              <1> 
  1539 00000D1F A0[30030000]        <1>     mov  al,[enabled_lapic]
  1540 00000D24 08C0                <1>     or   al,al
  1541 00000D26 58                  <1>     pop  eax
  1542 00000D27 742A                <1>     jz   skip_cpumsg
  1543                              <1> 
  1544 00000D29 56                  <1>     push esi
  1545 00000D2A 50                  <1>     push eax
  1546 00000D2B BE[9E050000]        <1>     mov  esi,cpumsg
  1547 00000D30 E84CF7FFFF          <1>     call puts_vga
  1548 00000D35 A12000E0FE          <1>     mov  eax,[0xfee00020]   ; print our apic id
  1549 00000D3A C1E818              <1>     shr  eax,24
  1550 00000D3D 83C030              <1>     add  eax,'0'
  1551 00000D40 658803              <1>     mov  [gs:ebx],al
  1552 00000D43 58                  <1>     pop  eax                ; recover line number
  1553 00000D44 C0E802              <1>     shr  al,2               ; provide a rolling effect for
  1554 00000D47 240F                <1>     and  al,0xf             ;     unending irq messages
  1555 00000D49 0C08                <1>     or   al,0x8
  1556 00000D4B 65884301            <1>     mov  [gs:ebx+1],al
  1557 00000D4F 83C304              <1>     add  ebx,4
  1558 00000D52 5E                  <1>     pop  esi
  1559                              <1> 
  1560                              <1> skip_cpumsg :
  1561 00000D53 E929F7FFFF          <1>     jmp  puts_vga
  1562                              <1> 
  1563                              <1> 
  1564                              <1> reboot_on_alt_key :
  1565                              <1> reboot_on_alt_key_loop :
  1566 00000D58 E460                <1>     in   al,0x60
  1567 00000D5A 3C53                <1>     cmp  al,0x53            ; scan code for the DEL key
  1568 00000D5C 75FA                <1>     jnz  reboot_on_alt_key_loop
  1569                              <1> reboot :
  1570 00000D5E 0F011D[8A0D0000]    <1>     lidt [reboot_idt]       ; restore boot idt (helps qemu ...)
  1571 00000D65 EA[6C0D0000]2800    <1>     jmp  rmcssel:reboot_exit_pmode      ; thankyou hpa
  1572                              <1> reboot_exit_pmode :
  1573                              <1> bits 16
  1574 00000D6C B83000              <1>     mov  ax,rmdssel
  1575 00000D6F 8ED8                <1>     mov  ds,ax
  1576 00000D71 8EC0                <1>     mov  es,ax
  1577 00000D73 8ED0                <1>     mov  ss,ax
  1578 00000D75 8EE0                <1>     mov  fs,ax
  1579 00000D77 8EE8                <1>     mov  gs,ax
  1580                              <1> 
  1581 00000D79 0F20C0              <1>     mov  eax,cr0
  1582 00000D7C 6625FEFFFF7F        <1>     and  eax,0x7ffffffe
  1583 00000D82 0F22C0              <1>     mov  cr0,eax            ; disable pmode and paging
  1584 00000D85 EA0000FFFF          <1>     jmp  0xffff:0           ; jump to the warm start vector and
  1585                              <1>                             ; flush the I prefetch queue all at once
  1586                              <1> 
  1587                              <1> reboot_idt :
  1588 00000D8A FFFF                <1>     dw 0xffff
  1589 00000D8C 00000000            <1>     dd 0
  1590                              <1> 
  1591                              <1> 
  1592                              <1> ; ---- IDT initialization table ---- 
  1593                              <1> ;
  1594                              <1> ; One dw (2 bytes per vector) is used which means that all
  1595                              <1> ; int_handler entry points must reside below 0x10000!
  1596                              <1> ;
  1597                              <1> ; And since all int_handler routines are 4 byte aligned,
  1598                              <1> ; the bottom two bits are available to indicate type.
  1599                              <1> ; These bits index into the irq_types table below.
  1600                              <1> 
  1601                              <1> align 4
  1602                              <1> 
  1603                              <1> ; note: these are not gdt/ldt descriptors (see swdev3a 6.11 pg 228)
  1604                              <1> 
  1605 00000D90 8E                  <1> irq_types   db  0x8e            ; dpl=0 32bit interrupt gate (sets IF flag)
  1606 00000D91 EE                  <1>             db  0xee            ; dpl=3 32bit app (ring3) interrupt gate
  1607 00000D92 85                  <1>             db  0x85            ; dpl=0 32bit task gate
  1608 00000D93 8F                  <1>             db  0x8f            ; dpl=0 32bit trap gate (does not set IF flag)
  1609                              <1> 
  1610                              <1> ; all handlers/selectors are 4 byte aligned - this gives us
  1611                              <1> ; two bits to use to designate 1 of 4 types of idt descriptors ...
  1612                              <1> 
  1613                              <1> irqt_intr   equ 0
  1614                              <1> irqt_app    equ 1
  1615                              <1> irqt_task   equ 2
  1616                              <1> irqt_trap   equ 3
  1617                              <1> 
  1618                              <1> irq_setup_table:
  1619                              <1>     ; cpu defined
  1620 00000D94 [9B08]              <1>     dw  int_handler_div0      + irqt_trap ; 0
  1621 00000D96 [AF08]              <1>     dw  int_handler_debug     + irqt_trap ; 1
  1622 00000D98 [C008]              <1>     dw  int_handler_nmi       + irqt_intr ; 2
  1623 00000D9A [D108]              <1>     dw  int_handler_brkp      + irqt_app  ; 3
  1624 00000D9C [E508]              <1>     dw  int_handler_ovrflw    + irqt_app  ; 4
  1625 00000D9E [F908]              <1>     dw  int_handler_bound     + irqt_app  ; 5
  1626 00000DA0 [0F09]              <1>     dw  int_handler_invop     + irqt_trap ; 6
  1627 00000DA2 [1F09]              <1>     dw  int_handler_devna     + irqt_trap ; 7
  1628 00000DA4 4200                <1>     dw  tasksel_f08           + irqt_task ; 8   double fault
  1629 00000DA6 [2309]              <1>     dw  int_handler_cpsego    + irqt_trap ; 9
  1630 00000DA8 4A00                <1>     dw  tasksel_f10           + irqt_task ; 10  invalid tss
  1631 00000DAA [3309]              <1>     dw  int_handler_segnp     + irqt_trap ; 11
  1632 00000DAC [4309]              <1>     dw  int_handler_stkflt    + irqt_trap ; 12
  1633 00000DAE [6709]              <1>     dw  int_handler_gpf       + irqt_trap ; 13
  1634 00000DB0 [480A]              <1>     dw  int_handler_pgflt     + irqt_intr ; 14
  1635 00000DB2 0000                <1>     dw  0                                 ; 15  Intel reserved
  1636 00000DB4 [730A]              <1>     dw  int_handler_fpuerr    + irqt_trap ; 16
  1637 00000DB6 [830A]              <1>     dw  int_handler_algnchk   + irqt_trap ; 17
  1638 00000DB8 [970A]              <1>     dw  int_handler_machchk   + irqt_trap ; 18
  1639 00000DBA [AB0A]              <1>     dw  int_handler_simdfpe   + irqt_trap ; 19
  1640 00000DBC 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0
  1641 00000DC5 000000000000000000- <1>
  1642 00000DCE 000000000000        <1>
  1643                              <1>     ; hw defined
  1644                              <1> apic0_irqbase equ ($ - irq_setup_table)/2
  1645 00000DD4 [BC0A]              <1>     dw  int_handler_timer     + irqt_intr ; 32  0x20
  1646 00000DD6 [0C0B]              <1>     dw  int_handler_kbd       + irqt_intr ; 33
  1647 00000DD8 [400B]              <1>     dw  int_handler_hw02      + irqt_intr ; 34
  1648 00000DDA [540B]              <1>     dw  int_handler_hw03      + irqt_intr ; 35
  1649 00000DDC [680B]              <1>     dw  int_handler_hw04      + irqt_intr ; 36
  1650 00000DDE [7C0B]              <1>     dw  int_handler_hw05      + irqt_intr ; 37
  1651 00000DE0 [900B]              <1>     dw  int_handler_hw06      + irqt_intr ; 38
  1652 00000DE2 [A40B]              <1>     dw  int_handler_hw07      + irqt_intr ; 39
  1653                              <1> apic1_irqbase equ ($ - irq_setup_table)/2
  1654 00000DE4 [B80B]              <1>     dw  int_handler_hw08      + irqt_intr ; 40
  1655 00000DE6 [CC0B]              <1>     dw  int_handler_hw09      + irqt_intr ; 41
  1656 00000DE8 [E00B]              <1>     dw  int_handler_hw10      + irqt_intr ; 42
  1657 00000DEA [F40B]              <1>     dw  int_handler_hw11      + irqt_intr ; 43
  1658 00000DEC [080C]              <1>     dw  int_handler_hw12      + irqt_intr ; 44
  1659 00000DEE [1C0C]              <1>     dw  int_handler_hw13      + irqt_intr ; 45
  1660 00000DF0 [300C]              <1>     dw  int_handler_hw14      + irqt_intr ; 46
  1661 00000DF2 [440C]              <1>     dw  int_handler_hw15      + irqt_intr ; 47  0x2f
  1662                              <1>     ; undefined - hw can expand here
  1663 00000DF4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x30
  1664 00000DFD 000000000000000000- <1>
  1665 00000E06 000000000000000000- <1>
  1666 00000E0F 0000000000          <1>
  1667 00000E14 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x40
  1668 00000E1D 000000000000000000- <1>
  1669 00000E26 000000000000000000- <1>
  1670 00000E2F 0000000000          <1>
  1671 00000E34 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x50
  1672 00000E3D 000000000000000000- <1>
  1673 00000E46 000000000000000000- <1>
  1674 00000E4F 0000000000          <1>
  1675 00000E54 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x60
  1676 00000E5D 000000000000000000- <1>
  1677 00000E66 000000000000000000- <1>
  1678 00000E6F 0000000000          <1>
  1679 00000E74 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x70
  1680 00000E7D 000000000000000000- <1>
  1681 00000E86 000000000000000000- <1>
  1682 00000E8F 0000000000          <1>
  1683 00000E94 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x80
  1684 00000E9D 000000000000000000- <1>
  1685 00000EA6 000000000000000000- <1>
  1686 00000EAF 0000000000          <1>
  1687 00000EB4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x90
  1688 00000EBD 000000000000000000- <1>
  1689 00000EC6 000000000000000000- <1>
  1690 00000ECF 0000000000          <1>
  1691 00000ED4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xa0
  1692 00000EDD 000000000000000000- <1>
  1693 00000EE6 000000000000000000- <1>
  1694 00000EEF 0000000000          <1>
  1695                              <1>     ; set up cpu thread management tss gates
  1696                              <1>     ; these map 1-to-1 to cpus
  1697                              <1> first_thread_tss_gate equ ($ - irq_setup_table)/2
  1698 00000EF4 5A00                <1>     dw  tasksel_u00           + irqt_task
  1699 00000EF6 6A00                <1>     dw  tasksel_u01           + irqt_task
  1700 00000EF8 7A00                <1>     dw  tasksel_u02           + irqt_task
  1701 00000EFA 8A00                <1>     dw  tasksel_u03           + irqt_task
  1702 00000EFC 9A00                <1>     dw  tasksel_u04           + irqt_task
  1703 00000EFE AA00                <1>     dw  tasksel_u05           + irqt_task
  1704 00000F00 BA00                <1>     dw  tasksel_u06           + irqt_task
  1705 00000F02 CA00                <1>     dw  tasksel_u07           + irqt_task
  1706                              <1> %ifdef FOO
  1707                              <1>     dw  tasksel_u08           + irqt_task
  1708                              <1>     dw  tasksel_u09           + irqt_task
  1709                              <1>     dw  tasksel_u10           + irqt_task
  1710                              <1>     dw  tasksel_u11           + irqt_task
  1711                              <1>     dw  tasksel_u12           + irqt_task
  1712                              <1>     dw  tasksel_u13           + irqt_task
  1713                              <1>     dw  tasksel_u14           + irqt_task
  1714                              <1>     dw  tasksel_u15           + irqt_task
  1715                              <1> %endif
  1716 00000F04 000000000000000000- <1>     dw                  0,0,0,0,0,0,0,0   ; 0xb0
  1717 00000F0D 00000000000000      <1>
  1718 00000F14 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xc0
  1719 00000F1D 000000000000000000- <1>
  1720 00000F26 000000000000000000- <1>
  1721 00000F2F 0000000000          <1>
  1722 00000F34 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xd0
  1723 00000F3D 000000000000000000- <1>
  1724 00000F46 000000000000000000- <1>
  1725 00000F4F 0000000000          <1>
  1726 00000F54 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     ; 0xe0
  1727 00000F5D 000000000000000000- <1>
  1728 00000F66 000000000000000000- <1>
  1729 00000F6F 000000              <1>
  1730                              <1> spurious_int equ ($ - irq_setup_table)/2
  1731 00000F72 [880C]              <1>     dw  int_handler_spurious  + irqt_intr
  1732                              <1> apicerr_int equ ($ - irq_setup_table)/2
  1733 00000F74 [990C]              <1>     dw  int_handler_apicerr   + irqt_app
  1734 00000F76 000000000000000000- <1>     dw    0,0,0,0,0,0,0,0,0,0,0,0,0       ; 0xf0
  1735 00000F7F 000000000000000000- <1>
  1736 00000F88 0000000000000000    <1>
  1737                              <1>     ; sw defined - expand down if needed
  1738                              <1> wakeup_int equ ($ - irq_setup_table)/2
  1739 00000F90 [A90C]              <1>     dw  wakeup                + irqt_app
  1740 00000F92 [B50C]              <1>     dw  sysent                + irqt_app  ; 256  0xff
  1741                              <1> irq_setup_table_size equ ($ - irq_setup_table)/2
  1742                              <1> 
  1743                                  
  1744                                  ; -------- system calls --------
  1745                                  %include "ozsys.asm"
  1746                              <1> ; OZ - A more utopian OS    x86-32 system calls
  1747                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
  1748                              <1> ;
  1749                              <1> ; Copyright (C) 2015  Duane Voth
  1750                              <1> ;
  1751                              <1> ;   This program is free software: you can redistribute it and/or modify
  1752                              <1> ;   it under the terms of the GNU Affero General Public License as
  1753                              <1> ;   published by the Free Software Foundation, either version 3 of the
  1754                              <1> ;   License, or (at your option) any later version.
  1755                              <1> ;
  1756                              <1> ;   This program is distributed in the hope that it will be useful,
  1757                              <1> ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
  1758                              <1> ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1759                              <1> ;   GNU Affero General Public License for more details.
  1760                              <1> ;
  1761                              <1> ;   You should have received a copy of the GNU Affero General Public License
  1762                              <1> ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
  1763                              <1> ;
  1764                              <1> ;
  1765                              <1> ; OZ System Calls  (for ozapps)
  1766                              <1> 
  1767                              <1> bits 32
  1768                              <1> 
  1769                              <1> ;------------------------------------------------------------------
  1770                              <1> ;   syscall_klog : place a message on the vga line reserved for klog  :D
  1771                              <1> ;
  1772                              <1> ;   entry:
  1773                              <1> ;       esi = message address
  1774                              <1> ;   exit:
  1775                              <1> 
  1776                              <1> syscall_klog :
  1777 00000F94 53                  <1>     push ebx
  1778 00000F95 BB20030000          <1>     mov  ebx,5 * 160        ; line 6
  1779 00000F9A E8E2F4FFFF          <1>     call puts_vga
  1780 00000F9F 5B                  <1>     pop  ebx
  1781 00000FA0 31C0                <1>     xor  eax,eax
  1782 00000FA2 CF                  <1>     iret
  1783                              <1> 
  1784                              <1> ;------------------------------------------------------------------
  1785                              <1> ;   syscall_sipi_vector : get the entry vector for non-boot cpus
  1786                              <1> ;
  1787                              <1> ;   entry:
  1788                              <1> ;   exit:
  1789                              <1> ;       eax = N cpus
  1790                              <1> 
  1791                              <1> syscall_sipi_vector :
  1792 00000FA3 B800700000          <1>     mov  eax,sipi_vector
  1793 00000FA8 CF                  <1>     iret
  1794                              <1> 
  1795                              <1> ;------------------------------------------------------------------
  1796                              <1> ;   syscall_ncpus : get how many cpu threads are running
  1797                              <1> ;
  1798                              <1> ;   entry:
  1799                              <1> ;   exit:
  1800                              <1> ;       eax = N cpus
  1801                              <1> 
  1802                              <1> syscall_ncpus :
  1803 00000FA9 A1[14030000]        <1>     mov  eax,[ncpus]
  1804 00000FAE CF                  <1>     iret
  1805                              <1> 
  1806                              <1> ;------------------------------------------------------------------
  1807                              <1> ;   syscall_new_thread : ask for another cpu to execute code in
  1808                              <1> ;                        the current app
  1809                              <1> ;
  1810                              <1> ;   This implementation is quite a bit of a hack - apps can basically
  1811                              <1> ;   commendere any specific non-boot cpu they want ...
  1812                              <1> ;
  1813                              <1> ;   entry:
  1814                              <1> ;       edx = function start address in the app
  1815                              <1> ;       ecx = address of the top of the app's new thread stack
  1816                              <1> ;       ebx = app's new thread index
  1817                              <1> ;   exit:
  1818                              <1> ;       eax = 0 success, -1 failure
  1819                              <1> 
  1820                              <1> syscall_new_thread :
  1821 00000FAF 09DB                <1>     or   ebx,ebx
  1822 00000FB1 7459                <1>     jz   new_thread_fail        ; don't get to ask for cpu 0
  1823                              <1> 
  1824 00000FB3 31C0                <1>     xor  eax,eax
  1825 00000FB5 A0[30030000]        <1>     mov  al,[enabled_lapic]     ; if the lapics are not enabled,
  1826 00000FBA 08C0                <1>     or   al,al                  ; none of this is useful
  1827 00000FBC 744E                <1>     jz   new_thread_fail
  1828                              <1> 
  1829                              <1>     ; setup the tss
  1830                              <1>     ; slightly squirly - get the tss address from the task selector
  1831                              <1>     ; but there could be a race here: ncpus is updated before
  1832                              <1>     ; create_tss_pair is called, so the task selector could be zero!
  1833                              <1> 
  1834 00000FBE 89DF                <1>     mov  edi,ebx
  1835 00000FC0 C1E704              <1>     shl  edi,4                  ; 8 byte selectors in pairs
  1836 00000FC3 83C758              <1>     add  edi,tasksel_u00
  1837 00000FC6 8BB7[02000000]      <1>     mov  esi,[gdt+edi+2]
  1838 00000FCC 81E6FFFFFF00        <1>     and  esi,0xffffff
  1839 00000FD2 31C0                <1>     xor  eax,eax
  1840 00000FD4 8A87[07000000]      <1>     mov  al,[gdt+edi+7]
  1841 00000FDA C1E018              <1>     shl  eax,24
  1842 00000FDD 09C6                <1>     or   esi,eax
  1843 00000FDF 742B                <1>     jz   new_thread_fail        ; cpu isn't yet ready ...
  1844                              <1> 
  1845                              <1>     ; really should check the previous task link to see if this
  1846                              <1>     ; cpu is busy ...
  1847                              <1> 
  1848 00000FE1 894E38              <1>     mov  [esi+(tss0_esp-tss0)],ecx  ; set the app's stack
  1849 00000FE4 895620              <1>     mov  [esi+(tss0_eip-tss0)],edx  ; set the ip to the entry point
  1850                              <1> 
  1851                              <1>     ; lookup the requested cpu's int/taskgate gdt selector
  1852                              <1> 
  1853 00000FE7 89DF                <1>     mov  edi,ebx
  1854 00000FE9 81C7B0000000        <1>     add  edi,first_thread_tss_gate  ; convert ebx to int/taskgate number
  1855                              <1> 
  1856                              <1>     ; ipi a cpu.  no fancy affinity scheduling yet,
  1857                              <1>     ; just let the app ask for a specific cpu to do the work
  1858                              <1> 
  1859 00000FEF B800000001          <1>     mov  eax,0x01000000
  1860 00000FF4 89D9                <1>     mov  ecx,ebx                    ; recover requested cpu number
  1861 00000FF6 D3E0                <1>     shl  eax,cl                     ; form the icr destination field
  1862                              <1> 
  1863                              <1>     ; poke the cpu that matches our thread index - we only get 8 :/
  1864                              <1> 
  1865 00000FF8 A31003E0FE          <1>     mov  dword [0xfee00310],eax
  1866 00000FFD B800480000          <1>     mov  eax,0x4800                 ; no shorthand, fixed, logical, edge
  1867 00001002 09F8                <1>     or   eax,edi                    ; make int/taskgate number the vector
  1868 00001004 A30003E0FE          <1>     mov  dword [0xfee00300],eax
  1869                              <1> 
  1870 00001009 31C0                <1>     xor  eax,eax
  1871 0000100B CF                  <1>     iret
  1872                              <1> 
  1873                              <1> new_thread_fail :
  1874 0000100C 48                  <1>     dec  eax                    ; -1
  1875 0000100D C3                  <1>     ret
  1876                              <1> 
  1877                              <1> ;------------------------------------------------------------------
  1878                              <1> ;   syscall_sleep : wait for N timer interrupts
  1879                              <1> ;
  1880                              <1> ;   entry:
  1881                              <1> ;       edx = N ticks
  1882                              <1> ;   exit:
  1883                              <1> 
  1884                              <1> syscall_sleep :
  1885 0000100E A0[30030000]        <1>     mov  al,[enabled_lapic]
  1886 00001013 08C0                <1>     or   al,al
  1887 00001015 7415                <1>     jz   sleep_loop
  1888                              <1> 
  1889 00001017 A12000E0FE          <1>     mov  eax,[0xfee00020]
  1890 0000101C C1E818              <1>     shr  eax,24
  1891 0000101F 09C0                <1>     or   eax,eax
  1892 00001021 7409                <1>     jz   sleep_loop         ; the boot cpu services the timer int
  1893 00001023 88C1                <1>     mov  cl,al              ; so don't add it to the sleeper list
  1894 00001025 B801000000          <1>     mov  eax,1
  1895 0000102A D3E0                <1>     shl  eax,cl
  1896                              <1> 
  1897                              <1> sleep_loop :
  1898 0000102C F00905[1C030000]    <1>     lock or [sleepers],eax  ; announce we are sleeping
  1899 00001033 FB                  <1>     sti
  1900 00001034 F4                  <1>     hlt                     ; wait for an int to wake us up
  1901 00001035 4A                  <1>     dec  edx                ; decrement the tick count
  1902 00001036 75F4                <1>     jnz  sleep_loop
  1903                              <1> 
  1904 00001038 83F0FF              <1>     xor  eax,-1
  1905 0000103B F02105[1C030000]    <1>     lock and [sleepers],eax ; renounce sleepiness
  1906 00001042 CF                  <1>     iret
  1907                              <1> 
  1908                              <1> ;------------------------------------------------------------------
  1909                              <1> ;   syscall_request_pmem_access : ask for access to a physical
  1910                              <1> ;            memory address
  1911                              <1> ;
  1912                              <1> ;   entry:
  1913                              <1> ;       edx = phys memory address
  1914                              <1> ;
  1915                              <1> ;   exit:
  1916                              <1> ;       (need to return a logical address in eax)  For now just
  1917                              <1> ;       direct maps the physical address into logical addr space.
  1918                              <1> 
  1919                              <1> syscall_request_pmem_access :
  1920 00001043 E801000000          <1>     call map_pmem
  1921 00001048 CF                  <1>     iret
  1922                              <1> 
  1923                              <1> ;------------------------------------------------------------------
  1924                              <1> ;   map_pmem - add entries to the current page directory/table
  1925                              <1> ;              to direct map the requested physical memory address
  1926                              <1> ;              (logical identical to physical for now)
  1927                              <1> ;
  1928                              <1> ;   entry:
  1929                              <1> ;       edx = phys memory address
  1930                              <1> ;
  1931                              <1> ;   returns:
  1932                              <1> ;       (need to return a logical address in eax)  For now just
  1933                              <1> ;       direct maps the physical address into logical addr space.
  1934                              <1> ;       eax =  0 success
  1935                              <1> ;       eax = -1 fail
  1936                              <1> 
  1937                              <1> map_pmem :
  1938 00001049 53                  <1>     push ebx
  1939 0000104A 57                  <1>     push edi
  1940                              <1> 
  1941 0000104B 0F013A              <1>     invlpg [edx]
  1942 0000104E 52                  <1>     push edx
  1943 0000104F 0F20DB              <1>     mov  ebx,cr3
  1944 00001052 81E300F0FFFF        <1>     and  ebx,0xfffff000
  1945 00001058 89D7                <1>     mov  edi,edx
  1946 0000105A 81E70000C0FF        <1>     and  edi,0xffc00000
  1947 00001060 C1EF14              <1>     shr  edi,(22 - 2)           ; calc page directory index
  1948 00001063 81E200F03F00        <1>     and  edx,0x003ff000
  1949 00001069 C1EA0A              <1>     shr  edx,(12 - 2)           ; calc page table index
  1950                              <1> 
  1951 0000106C 8B043B              <1>     mov  eax,[ebx+edi]
  1952 0000106F 09C0                <1>     or   eax,eax                ; is there a page table here?
  1953 00001071 750F                <1>     jnz  map_pmem_have_pgtbl
  1954 00001073 E85BF4FFFF          <1>     call mem_alloc_kernel_page
  1955 00001078 09C0                <1>     or   eax,eax
  1956 0000107A 741F                <1>     jz   map_pmem_fail
  1957 0000107C C1E00C              <1>     shl  eax,12                 ; convert pgno to pgtbl entry
  1958 0000107F 89043B              <1>     mov  [ebx+edi],eax          ; update page table
  1959                              <1> 
  1960                              <1> map_pmem_have_pgtbl :
  1961                              <1>     ; for now, no security check, just direct map the address
  1962                              <1>     ; and mark the pages and the page table r/w by all
  1963 00001082 830C3B07            <1>     or   dword [ebx+edi],7      ; user, r/w, present
  1964                              <1> 
  1965 00001086 8B1C3B              <1>     mov  ebx,[ebx+edi]
  1966 00001089 81E300F0FFFF        <1>     and  ebx,0xfffff000
  1967 0000108F 58                  <1>     pop  eax                    ; recover requested phys mem addr
  1968                              <1>     ; FIXME yup, big security hole if called by ring 0! And it is ...
  1969 00001090 83C807              <1>     or   eax,7                  ; user, r/w, present
  1970 00001093 890413              <1>     mov  [ebx+edx],eax          ; update page directory
  1971 00001096 31C0                <1>     xor  eax,eax                ; 0
  1972                              <1> map_pmem_exit :
  1973 00001098 5F                  <1>     pop  edi
  1974 00001099 5B                  <1>     pop  ebx
  1975 0000109A C3                  <1>     ret
  1976                              <1> 
  1977                              <1> map_pmem_fail :
  1978 0000109B 48                  <1>     dec  eax                    ; -1
  1979 0000109C EBFA                <1>     jmp  map_pmem_exit
  1980                              <1> 
  1981                                  
  1982 0000109E 00<rept>                align 16, db 0
  1983                                  kernel_text_size equ ($-textstart)
  1984                                  
  1985                                  ; ---------------------------------------------------------------------------
  1986                                  section .data
  1987                                  datastart :
  1988                                  
  1989                                  ; -------- descriptors --------------
  1990                                  ; Intel SW dev manual 3a, 3.4.5, pg 103
  1991                                  ;
  1992                                  ; In my opinion, macros for descriptor entries
  1993                                  ; don't make the code that much more readable.
  1994                                  
  1995                                  descriptor_size equ 8
  1996                                  
  1997                                  gdt :
  1998                                  nullsel equ $-gdt           ; nullsel = 0h
  1999 00000000 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
  2000                                  
  2001                                  codesel equ $-gdt           ; codesel = 8h  4Gb flat over all logical mem
  2002 00000008 FFFF                        dw 0xffff               ; limit 0-15
  2003 0000000A 0000                        dw 0x0000               ; base  0-15
  2004 0000000C 00                          db 0x00                 ; base 16-23
  2005 0000000D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  2006 0000000E CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  2007 0000000F 00                          db 0x00                 ; base 24-31
  2008                                  
  2009                                  datasel equ $-gdt           ; datasel = 10h  4Gb flat over all logical mem
  2010 00000010 FFFF                        dw 0xffff               ; limit 0-15
  2011 00000012 0000                        dw 0x0000               ; base  0-15
  2012 00000014 00                          db 0x00                 ; base 16-23
  2013 00000015 92                          db 0x92                 ; present, dpl=0, data r/w
  2014 00000016 CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  2015 00000017 00                          db 0x00                 ; base 24-31
  2016                                  
  2017                                  stacksel equ $-gdt          ; stacksel = 18h  small limited stack
  2018 00000018 FF1F                        dw kstack_size-1        ; limit
  2019 0000001A 0010                        dw kstack_loc           ; base
  2020 0000001C 00                          db 0
  2021 0000001D 92                          db 0x92                 ; present, dpl=0, data, r/w
  2022 0000001E 40                          db 0x40                 ; byte granular, 32bit/8bit
  2023 0000001F 00                          db 0
  2024                                  
  2025                                  videosel equ $-gdt          ; videosel = 20h
  2026 00000020 9F0F                        dw 3999                 ; limit 80*25*2-1
  2027 00000022 0080                        dw 0x8000               ; base 0xb8000
  2028 00000024 0B                          db 0x0b
  2029 00000025 92                          db 0x92                 ; present, dpl=0, data, r/w
  2030 00000026 40                          db 0x40                 ; byte granular, 32bit/8bit
  2031 00000027 00                          db 0
  2032                                  
  2033                                  rmcssel equ $-gdt           ; real mode CS selector = 28h
  2034 00000028 FFFF                        dw 0xffff               ; limit 0-15
  2035 0000002A 0000                        dw 0x0000               ; base  0-15
  2036 0000002C 00                          db 0x00                 ; base 16-23
  2037 0000002D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  2038 0000002E 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  2039 0000002F 00                          db 0x00                 ; base 24-31
  2040                                  
  2041                                  rmdssel equ $-gdt           ; real mode DS selector = 30h
  2042 00000030 FFFF                        dw 0xffff               ; limit 0-15
  2043 00000032 0000                        dw 0x0000               ; base  0-15
  2044 00000034 00                          db 0x00                 ; base 16-23
  2045 00000035 92                          db 0x92                 ; present, dpl=0, data r/w
  2046 00000036 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  2047 00000037 00                          db 0x00                 ; base 24-31
  2048                                  
  2049                                  ldtsel1 equ $-gdt
  2050 00000038 1800                        dw ldt1_len             ; length of the ldt
  2051 0000003A [5001]                      dw ldt1                 ; address of the ldt
  2052 0000003C 00                          db 0
  2053 0000003D 82                          db 0x82                 ; present, dpl=0, ldt
  2054 0000003E 40                          db 0x40                 ; byte granular, 32bit/8bit
  2055 0000003F 00                          db 0
  2056                                  
  2057                                  tasksel_f08 equ $-gdt       ; the double fault task selector
  2058 00000040 6800                        dw tss_len              ; tss length
  2059 00000042 [6801]                      dw tss_f08              ; tss physical address
  2060 00000044 00                          db 0
  2061 00000045 89                          db 0x89                 ; present, dpl=0, tss32
  2062 00000046 40                          db 0x40                 ; byte granular, 32bit/8bit
  2063 00000047 00                          db 0
  2064                                  
  2065                                  tasksel_f10 equ $-gdt       ; the invalid tss task selector
  2066 00000048 6800                        dw tss_len              ; tss length
  2067 0000004A [D001]                      dw tss_f10              ; tss physical address
  2068 0000004C 00                          db 0
  2069 0000004D 89                          db 0x89                 ; present, dpl=0, tss32
  2070 0000004E 40                          db 0x40                 ; byte granular, 32bit/8bit
  2071 0000004F 00                          db 0
  2072                                  
  2073                                  ; there is one kernel thread tss (ring 0) and one user thread tss (ring 1)
  2074                                  ; per cpu.  memory for tss structs for the non-boot cpus are allocated as
  2075                                  ; each non-boot cpu comes online (see create_tss_pair).  tasksel_uXX tss
  2076                                  ; gates are installed in the idt (starting at first_thread_tss_gate),
  2077                                  ; they also map 1-to-1 with cpus.  (the thread is launched via an lapic
  2078                                  ; vectored interrupt that jumps immediately into user space - and to call a
  2079                                  ; task gate from an interrupt requires an existing ring 0 tss to be active)
  2080                                  ; tasksel_uXX tsses are initialized in new_thread.
  2081                                  
  2082                                  tasksel_k00 equ $-gdt
  2083 00000050 6800[3802]00894000                              dw tss_len, tss0, 0x8900, 0x40
  2084                                  tasksel_u00 equ $-gdt
  2085 00000058 6800[A002]00894000                              dw tss_len, tss1, 0x8900, 0x40
  2086                                  tasksel_k01 equ $-gdt
  2087 00000060 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2088                                  tasksel_u01 equ $-gdt
  2089 00000068 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2090                                  tasksel_k02 equ $-gdt
  2091 00000070 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2092                                  tasksel_u02 equ $-gdt
  2093 00000078 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2094                                  tasksel_k03 equ $-gdt
  2095 00000080 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2096                                  tasksel_u03 equ $-gdt
  2097 00000088 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2098                                  tasksel_k04 equ $-gdt
  2099 00000090 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2100                                  tasksel_u04 equ $-gdt
  2101 00000098 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2102                                  tasksel_k05 equ $-gdt
  2103 000000A0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2104                                  tasksel_u05 equ $-gdt
  2105 000000A8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2106                                  tasksel_k06 equ $-gdt
  2107 000000B0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2108                                  tasksel_u06 equ $-gdt
  2109 000000B8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2110                                  tasksel_k07 equ $-gdt
  2111 000000C0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2112                                  tasksel_u07 equ $-gdt
  2113 000000C8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2114                                  tasksel_k08 equ $-gdt
  2115 000000D0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2116                                  tasksel_u08 equ $-gdt
  2117 000000D8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2118                                  tasksel_k09 equ $-gdt
  2119 000000E0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2120                                  tasksel_u09 equ $-gdt
  2121 000000E8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2122                                  tasksel_k10 equ $-gdt
  2123 000000F0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2124                                  tasksel_u10 equ $-gdt
  2125 000000F8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2126                                  tasksel_k11 equ $-gdt
  2127 00000100 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2128                                  tasksel_u11 equ $-gdt
  2129 00000108 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2130                                  tasksel_k12 equ $-gdt
  2131 00000110 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2132                                  tasksel_u12 equ $-gdt
  2133 00000118 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2134                                  tasksel_k13 equ $-gdt
  2135 00000120 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2136                                  tasksel_u13 equ $-gdt
  2137 00000128 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2138                                  tasksel_k14 equ $-gdt
  2139 00000130 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2140                                  tasksel_u14 equ $-gdt
  2141 00000138 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2142                                  tasksel_k15 equ $-gdt
  2143 00000140 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2144                                  tasksel_u15 equ $-gdt
  2145 00000148 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2146                                  
  2147                                  max_threads equ ($-gdt-tasksel_k00)/descriptor_size/2
  2148                                  
  2149                                  gdt_end :
  2150                                  
  2151                                  ; ---------------------
  2152                                  
  2153                                  ldt1 :
  2154                                  nullsel1 equ $-ldt1         ; nullsel1 = 07h
  2155 00000150 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
  2156                                  
  2157                                  codesel1 equ $-ldt1         ; codesel1 = 0fh  4Gb flat over all logical mem
  2158 00000158 FFFF                        dw 0xffff               ; limit 0-15
  2159 0000015A 0000                        dw 0x0000               ; base  0-15
  2160 0000015C 00                          db 0x00                 ; base 16-23
  2161 0000015D FA                          db 0xfa                 ; present, dpl=3, code e/r
  2162 0000015E CF                          db 0xcf                 ; 4k granular, 32bit, limit 16-19
  2163 0000015F 00                          db 0x00                 ; base 24-31
  2164                                  
  2165                                  datasel1 equ $-ldt1         ; datasel1 = 17h  4Gb flat over all logical mem
  2166 00000160 FFFF                        dw 0xffff               ; limit 0-15
  2167 00000162 0000                        dw 0x0000               ; base  0-15
  2168 00000164 00                          db 0x00                 ; base 16-23
  2169 00000165 F2                          db 0xf2                 ; present, dpl=3, data r/w
  2170 00000166 CF                          db 0xcf                 ; 4k granular, 32bit, limit 16-19
  2171 00000167 00                          db 0x00                 ; base 24-31
  2172                                  
  2173                                  ; gcc wants the ds, es, and ss segment registers to match
  2174                                  ;stacksel1 equ $-ldt1        ; stacksel = 1ch  small limited stack
  2175                                  ;    dw 0xffff               ; limit
  2176                                  ;    dw 0x0000               ; base  0-15
  2177                                  ;    db 0x00
  2178                                  ;    db 0xf2                 ; present, dpl=3, data, r/w
  2179                                  ;    db 0                    ; byte granular, 16 bit
  2180                                  ;    db 0
  2181                                  
  2182                                  ldt1_end :
  2183                                  
  2184                                  ldt1_len equ ldt1_end-ldt1
  2185                                  
  2186                                  ; ---------------------
  2187                                  ; the tss that handles double fault exceptions
  2188                                  
  2189                                  tss_f08 :                   ; intel sw 3a 7.6  pg 287 of 756
  2190 00000168 00000000                    dw 0,0                  ; previous task link
  2191 0000016C 005F0000                    dd tss_f08_stk-0x100    ; esp0
  2192 00000170 10000000                    dw datasel,0            ; ss0
  2193 00000174 00000000                    dd 0                    ; esp1
  2194 00000178 00000000                    dw 0,0                  ; ss1
  2195 0000017C 00000000                    dd 0                    ; esp2
  2196 00000180 00000000                    dw 0,0                  ; ss2
  2197                                  tss_f08_cr3 :
  2198 00000184 00000000                    dd 0                    ; cr3
  2199 00000188 [580C0000]                  dd int_handler_tg_dblflt ; eip
  2200 0000018C 00000000                    dd 0                    ; eflags
  2201 00000190 00000000                    dd 0                    ; eax
  2202 00000194 00000000                    dd 0                    ; ecx
  2203 00000198 00000000                    dd 0                    ; edx
  2204 0000019C 00000000                    dd 0                    ; ebx
  2205 000001A0 00600000                    dd tss_f08_stk          ; esp
  2206 000001A4 00000000                    dd 0                    ; ebp
  2207 000001A8 00000000                    dd 0                    ; esi
  2208 000001AC 00000000                    dd 0                    ; edi
  2209 000001B0 10000000                    dw datasel,0            ; es
  2210 000001B4 08000000                    dw codesel,0            ; cs
  2211 000001B8 10000000                    dw datasel,0            ; ss
  2212 000001BC 10000000                    dw datasel,0            ; ds
  2213 000001C0 00000000                    dw 0,0                  ; fs
  2214 000001C4 20000000                    dw videosel,0           ; gs
  2215 000001C8 00000000                    dw 0,0                  ; ldt
  2216 000001CC 0000                        dw 0                    ; trap
  2217 000001CE 0000                        dw 0                    ; iomap
  2218                                  
  2219                                  ; ---------------------
  2220                                  ; the tss that handles invalid tss exceptions
  2221                                  
  2222                                  tss_f10 :                   ; intel sw 3a 7.6  pg 287 of 756
  2223 000001D0 00000000                    dw 0,0                  ; previous task link
  2224 000001D4 006F0000                    dd tss_f10_stk-0x100    ; esp0
  2225 000001D8 10000000                    dw datasel,0            ; ss0
  2226 000001DC 00000000                    dd 0                    ; esp1
  2227 000001E0 00000000                    dw 0,0                  ; ss1
  2228 000001E4 00000000                    dd 0                    ; esp2
  2229 000001E8 00000000                    dw 0,0                  ; ss2
  2230                                  tss_f10_cr3 :
  2231 000001EC 00000000                    dd 0                    ; cr3
  2232 000001F0 [6C0C0000]                  dd int_handler_tg_invtss ; eip
  2233 000001F4 00000000                    dd 0                    ; eflags
  2234 000001F8 00000000                    dd 0                    ; eax
  2235 000001FC 00000000                    dd 0                    ; ecx
  2236 00000200 00000000                    dd 0                    ; edx
  2237 00000204 00000000                    dd 0                    ; ebx
  2238 00000208 00700000                    dd tss_f10_stk          ; esp
  2239 0000020C 00000000                    dd 0                    ; ebp
  2240 00000210 00000000                    dd 0                    ; esi
  2241 00000214 00000000                    dd 0                    ; edi
  2242 00000218 10000000                    dw datasel,0            ; es
  2243 0000021C 08000000                    dw codesel,0            ; cs
  2244 00000220 10000000                    dw datasel,0            ; ss
  2245 00000224 10000000                    dw datasel,0            ; ds
  2246 00000228 00000000                    dw 0,0                  ; fs
  2247 0000022C 20000000                    dw videosel,0           ; gs
  2248 00000230 00000000                    dw 0,0                  ; ldt
  2249 00000234 0000                        dw 0                    ; trap
  2250 00000236 0000                        dw 0                    ; iomap
  2251                                  
  2252                                  ; ---------------------
  2253                                  ; tss0 and tss1 are cpu0's pair
  2254                                  
  2255                                  tss0 :                      ; intel swdev3a 7.6  pg 287 of 756
  2256 00000238 00000000                    dw 0,0                  ; previous task link
  2257                                  tss0_esp0 :
  2258 0000023C 00000000                    dd 0                    ; esp0
  2259                                  tss0_ss0 :
  2260 00000240 00000000                    dw 0,0                  ; ss0
  2261 00000244 00000000                    dd 0                    ; esp1
  2262 00000248 00000000                    dw 0,0                  ; ss1
  2263 0000024C 00000000                    dd 0                    ; esp2
  2264 00000250 00000000                    dw 0,0                  ; ss2
  2265                                  tss0_cr3 :
  2266 00000254 00000000                    dd 0                    ; cr3
  2267                                  tss0_eip :
  2268 00000258 00000000                    dd 0                    ; eip
  2269 0000025C 00000000                    dd 0                    ; eflags
  2270                                  tss0_eax :
  2271 00000260 00000000                    dd 0                    ; eax
  2272 00000264 00000000                    dd 0                    ; ecx
  2273 00000268 00000000                    dd 0                    ; edx
  2274 0000026C 00000000                    dd 0                    ; ebx
  2275                                  tss0_esp :
  2276 00000270 00000000                    dd 0                    ; esp
  2277 00000274 00000000                    dd 0                    ; ebp
  2278 00000278 00000000                    dd 0                    ; esi
  2279 0000027C 00000000                    dd 0                    ; edi
  2280                                  tss0_es :
  2281 00000280 00000000                    dw 0,0                  ; es
  2282                                  tss0_cs :
  2283 00000284 00000000                    dw 0,0                  ; cs
  2284                                  tss0_ss :
  2285 00000288 00000000                    dw 0,0                  ; ss
  2286                                  tss0_ds :
  2287 0000028C 00000000                    dw 0,0                  ; ds
  2288 00000290 00000000                    dw 0,0                  ; fs
  2289 00000294 20000000                    dw videosel,0           ; gs
  2290                                  tss0_ldt :
  2291 00000298 00000000                    dw 0,0                  ; ldt
  2292 0000029C 0000                        dw 0                    ; trap
  2293 0000029E 0000                        dw 0                    ; iomap
  2294                                  tss0_end :
  2295                                  
  2296                                  tss_len equ tss0_end-tss0
  2297                                  
  2298                                  ; user tss
  2299                                  
  2300                                  tss1 :                      ; intel sw 3a 7.6  pg 287 of 756
  2301 000002A0 00000000                    dw 0,0                  ; previous task link
  2302                                  tss1_esp0 :
  2303 000002A4 00000000                    dd 0                    ; esp0  (int and irq support)
  2304 000002A8 18000000                    dw stacksel,0           ; ss0   (filled in when running init apps)
  2305 000002AC 00000000                    dd 0                    ; esp1
  2306 000002B0 00000000                    dw 0,0                  ; ss1
  2307 000002B4 00000000                    dd 0                    ; esp2
  2308 000002B8 00000000                    dw 0,0                  ; ss2
  2309                                  tss1_cr3 :
  2310 000002BC 00000000                    dd 0                    ; cr3
  2311                                  tss1_eip :
  2312 000002C0 00000000                    dd 0                    ; eip
  2313 000002C4 00000000                    dd 0                    ; eflags
  2314 000002C8 00000000                    dd 0                    ; eax
  2315 000002CC 00000000                    dd 0                    ; ecx
  2316 000002D0 00000000                    dd 0                    ; edx
  2317 000002D4 00000000                    dd 0                    ; ebx
  2318 000002D8 00000000                    dd 0                    ; esp
  2319 000002DC 00000000                    dd 0                    ; ebp
  2320 000002E0 00000000                    dd 0                    ; esi
  2321 000002E4 00000000                    dd 0                    ; edi
  2322 000002E8 17000000                    dw datasel1+7,0         ; es
  2323 000002EC 0F000000                    dw codesel1+7,0         ; cs
  2324 000002F0 17000000                    dw datasel1+7,0         ; ss
  2325 000002F4 17000000                    dw datasel1+7,0         ; ds
  2326 000002F8 00000000                    dw 0,0                  ; fs
  2327 000002FC 00000000                    dw 0,0                  ; gs
  2328 00000300 3B000000                    dw ldtsel1+3,0          ; ldt
  2329 00000304 0000                        dw 0                    ; trap
  2330 00000306 0000                        dw 0                    ; iomap
  2331                                  
  2332                                  ; ---------------------
  2333                                  
  2334                                  gdtr :
  2335 00000308 4F01                        dw gdt_end - gdt - 1    ; gdt length
  2336 0000030A [00000000]                  dd gdt                  ; gdt physical address
  2337                                  
  2338                                  idtr :
  2339                                      ; irq_setup_table_size == the number of gates in the idt
  2340 0000030E FF07                        dw irq_setup_table_size * 8 - 1     ; idt limit (should be 2k)
  2341                                  idtr_addr :
  2342 00000310 00000000                    dd 0                                ; address of the idt
  2343                                  
  2344 00000314 00000000                ncpus           dd 0        ; number of running cpus
  2345                                  
  2346 00000318 00000000                next_free_page  dd 0        ; initialized after page tables are setup
  2347                                  
  2348 0000031C 0000000000000000        sleepers        dq 0        ; one bit per cpu
  2349                                  
  2350 00000324 00000000                pgdirp          dd 0
  2351 00000328 00000000                pgtb0p          dd 0
  2352 0000032C 00000000                pgtb1p          dd 0
  2353                                  
  2354 00000330 00                      enabled_lapic   db 0        ; set to 1 if an lapic is present and in use
  2355                                  
  2356 00000331 AA55                    dbgwall         db 0xaa,0x55
  2357                                  
  2358 00000333 00<rept>                align 16, db 0
  2359                                  kernel_data_size equ ($-datastart)
  2360                                  
  2361                                  
  2362                                  ; ---------------------
  2363                                  ; Need to align to a physical page boundary here so that appended init apps
  2364                                  ; are always page aligned.  The problem is our text section starts 1k below
  2365                                  ; a page boundary, and so an 'align 4096' doesn't match up with physical
  2366                                  ; memory.
  2367                                  
  2368                                  ; Add larger tests here if the times expression turns up negative, to make
  2369                                  ; the kernel image size right, but your next problem will be that the boot
  2370                                  ; loader will likely refuse to load all these sectors in one pass.
  2371                                  
  2372                                  section .fill
  2373                                  
  2374                                  fill :
  2375                                  
  2376                                  %if total_size > 4096+1024
  2377                                      times (4096+4096+1024-total_size) db 0
  2378                                  %elif total_size > 1024
  2379 00000000 00<rept>                    times (4096+1024-total_size) db 0
  2380                                  %endif
  2381                                  
  2382                                  kend :
  2383                                  
