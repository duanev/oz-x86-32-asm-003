     1                                  ; OZ - A more utopian OS   x86-32 startup 
     2                                  ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
     3                                  ;
     4                                  ; Copyright (C) 2015  Duane Voth
     5                                  ;
     6                                  ;   This program is free software: you can redistribute it and/or modify
     7                                  ;   it under the terms of the GNU Affero General Public License as
     8                                  ;   published by the Free Software Foundation, either version 3 of the
     9                                  ;   License, or (at your option) any later version.
    10                                  ;
    11                                  ;   This program is distributed in the hope that it will be useful,
    12                                  ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
    13                                  ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    14                                  ;   GNU Affero General Public License for more details.
    15                                  ;
    16                                  ;   You should have received a copy of the GNU Affero General Public License
    17                                  ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
    18                                  ;
    19                                  ;
    20                                  ;
    21                                  ; usage:
    22                                  ;	$ qemu-system-i386 -boot a -fda oz_fd -monitor stdio
    23                                  ;
    24                                  ; requires: nasm-2.07  or later from: http://www.nasm.us
    25                                  ;
    26                                  ; contributors:
    27                                  ;        djv - Duane Voth
    28                                  ;
    29                                  ; history:
    30                                  ; 2007/03/03 - 0.00.01 - djv - begin with various web examples
    31                                  ;                      http://linuxgazette.net/issue82/misc/raghu/code.asm.txt
    32                                  ;                      http://www.osdever.net/tutorials/brunmar/simple_asm.txt
    33                                  ; 2007/03/04 - 0.00.02 - djv - add timer interrupt support with stray int dbg
    34                                  ; 2007/03/05 - 0.00.03 - djv - remove stray int dbg, add mbr data struc back
    35                                  ; 2007/03/11 - 0.00.04 - djv - debug USB boot problem
    36                                  ; 2007/03/28 - 0.01.00 - djv - add a real-mode stage2 loader in the mbr to
    37                                  ;                              load the sectors past the mbr on the boot
    38                                  ;                              device into the memory behind the mbr.  so even
    39                                  ;                              tho the read from the device happens in two
    40                                  ;                              parts, memory contains a linear image of the
    41                                  ;                              first few sectors of the boot device.
    42                                  ; 2009/02/01 - 0.02.00 - djv - begin to define application and dynamic library
    43                                  ;                              binary formats with headers detailing size and
    44                                  ;                              entry points.
    45                                  ; 2009/08/01 - 0.03.00 - djv - create the OZ app execution container using
    46                                  ;                              TSSes, paging, and rings 0 and 3.  begin to
    47                                  ;                              play with system calls.
    48                                  ; 2015/10/12 - 0.03.01 - djv - cleanup, add smp usermode tss structs, sleep,
    49                                  ;                              wakeup, and ipi for user thread creation.
    50                                  
    51                                  %ifdef USB
    52                                  [map symbols oz_usb.map]
    53                                  %else
    54                                  [map symbols oz_fd.map]
    55                                  %endif
    56                                  
    57                                  ; -------- stage 1 ---------------------------------------------------------
    58                                  ; A classic x86 Master Boot Record
    59                                  
    60                                  section .text start=0x7c00  ; PC BIOS boot loader entry point
    61                                  textstart :
    62                                  
    63                                  bios_entry :
    64 00000000 FA                          cli
    65 00000001 EA[2400]0000                jmp 0:load_stage2       ; load cs, skip over mbr data struct
    66                                  
    67                                  times 6-($-$$)  db 0
    68 00000006 6F7A                    oemid db "oz"
    69                                  
    70 00000008 00<rept>                times 11-($-$$)  db 0
    71                                  
    72                                  ; compute the size of the kernel image in 512 byte sectors
    73                                  total_size equ (kernel_text_size + kernel_data_size)
    74                                  kisectors  equ (total_size)/512 + (APP_SIZE + 512)/512
    75                                  ; compute the end of the kernel image (with apps attached)
    76                                  kilast equ 0x7c00 + kisectors * 512
    77                                  
    78                                  ; MS MBR  (http://support.microsoft.com/kb/140418)
    79                                  %ifdef FLOPPY
    80                                      dw 512                  ; Bytes per sector
    81                                      db 1                    ; Sectors per cluster
    82                                      dw kisectors            ; Number of reserved sectors
    83                                      db 2                    ; Number of FATs
    84                                      dw 0x00e0               ; Number of dirs in root
    85                                      dw 0x0b40               ; Number of sectors in volume
    86                                      db 0xf0                 ; Media descriptor
    87                                      dw 9                    ; Number of sectors per FAT
    88                                      dw 18                   ; Number of sectors per track
    89                                      dw 2                    ; Number of heads
    90                                      dd 0                    ; Number of hidden sectors
    91                                      dd 0                    ; Large Sectors
    92                                  %endif
    93                                  
    94                                  %ifdef USB
    95 0000000B 0000                        dw 0                    ; Bytes per sector
    96 0000000D 00                          db 0                    ; Sectors per cluster
    97 0000000E 3A00                        dw kisectors            ; Number of reserved sectors
    98 00000010 00                          db 0                    ; Number of FATs
    99 00000011 0000                        dw 0                    ; Number of dirs in root
   100 00000013 0000                        dw 0                    ; Number of sectors in volume
   101 00000015 00                          db 0                    ; Media descriptor
   102 00000016 0000                        dw 0                    ; Number of sectors per FAT
   103 00000018 0000                        dw 0                    ; Number of sectors per track
   104 0000001A 0000                        dw 0                    ; Number of heads
   105 0000001C 00000000                    dd 0                    ; Number of hidden sectors
   106 00000020 00000000                    dd 0                    ; Large Sectors
   107                                  %endif
   108                                  
   109                                  ; -------- stage 2 loader ------------
   110                                  bits 16
   111                                  alignb 2
   112                                  
   113                                  load_stage2 :
   114 00000024 B80010                      mov  ax,kstack_loc
   115 00000027 89C4                        mov  sp,ax
   116 00000029 31C0                        xor  ax,ax
   117 0000002B 8ED0                        mov  ss,ax
   118 0000002D 8EC0                        mov  es,ax
   119 0000002F 8ED8                        mov  ds,ax
   120 00000031 8EE0                        mov  fs,ax
   121 00000033 8EE8                        mov  gs,ax
   122 00000035 FC                          cld
   123                                  
   124 00000036 52                          push dx                 ; save BIOS drive number
   125                                  
   126 00000037 B80006                      mov  ax,0x0600          ; ah=6 scroll window up, if al = 0 clrscr
   127 0000003A B90000                      mov  cx,0x0000          ; clear window from 0,0 
   128 0000003D BA4F17                      mov  dx,0x174f          ; to 23,79
   129 00000040 B70F                        mov  bh,0xf             ; fill with hi white
   130 00000042 CD10                        int  0x10               ; clear screen for direct writes to video memory
   131                                  
   132 00000044 BE[B700]                    mov  si,bootmsg
   133 00000047 31DB                        xor  bx,bx
   134 00000049 E85700                      call puts_vga_rm
   135                                                              ; puts_vga_rm leaves gs pointing at video mem
   136 0000004C 65C60601000E                mov  byte [gs:1],0xE    ; turn the first two chars yellow
   137 00000052 65C60603000E                mov  byte [gs:3],0xE
   138                                  
   139                                      ;F - white              
   140                                      ;E - yellow             
   141                                      ;D - magenta            
   142                                      ;C - red                
   143                                      ;B - cyan               
   144                                      ;A - green              
   145                                      ;9 - blue               
   146                                      ;8 - dark grey          
   147                                  
   148 00000058 A1[0002]                    mov  ax,[stage2]         ; check the signature byte
   149 0000005B 0306[0202]                  add  ax,[stage2+2]
   150 0000005F 3DA17A                      cmp  ax,0x7a6f+0x32
   151 00000062 741D                        jz   stage2_present
   152                                  
   153                                      ; -------- stage2 boot loader --------
   154                                  
   155                                      ; Assume that the kernel is smaller than whatever space
   156                                      ; is provided prior to file system data structures on the
   157                                      ; boot device, and that it can immediately follow the MBR.
   158                                  
   159 00000064 B402                        mov  ah,02h
   160 00000066 B039                        mov  al,kisectors-1     ; number of sectors to load
   161 00000068 BB[0002]                    mov  bx,stage2
   162 0000006B B90200                      mov  cx,2
   163 0000006E 5A                          pop  dx                 ; recover BIOS drive number
   164 0000006F 0E                          push cs
   165 00000070 07                          pop  es
   166 00000071 CD13                        int  13h
   167 00000073 7211                        jc   ioerr
   168                                  
   169                                      ; ---- make sure second stage actually got loaded
   170                                  
   171 00000075 A1[0002]                    mov  ax,[stage2]        ; check the signature byte
   172 00000078 0306[0202]                  add  ax,[stage2+2]
   173 0000007C 3DA17A                      cmp  ax,0x7a6f+0x32
   174 0000007F 750A                        jnz  s2err
   175                                  stage2_present :
   176 00000081 EA[0902]0000                jmp  0:start_stage2     ; use an absolute jump so stage 1
   177                                                              ; can be position independent
   178                                  
   179                                  ioerr :                     ; ah has status...
   180 00000086 BE[E700]                    mov  si,ioerrmsg
   181 00000089 EB03                        jmp  print_err
   182                                  
   183                                  s2err :
   184 0000008B BE[D100]                    mov  si,s2errmsg
   185                                  print_err :
   186 0000008E BBA000                      mov  bx,160
   187 00000091 E80F00                      call puts_vga_rm
   188 00000094 65C60601000C                mov  byte [gs:1],0xC    ; turn the first two vga chars red
   189 0000009A 65C60603000C                mov  byte [gs:3],0xC
   190                                  
   191                                  hang :
   192 000000A0 F4                          hlt
   193 000000A1 EBFD                        jmp  hang
   194                                  
   195                                  ; ----------------------------
   196                                  ;   puts_vga_rm - write a null delimited string to the VGA controller
   197                                  ;                 in real mode
   198                                  ;
   199                                  ;    enter:
   200                                  ;            esi - address of string
   201                                  ;            ebx - screen location (2 bytes per char, 160 bytes per line)
   202                                  ;    exit:
   203                                  ;            eax - destroyed
   204                                  ;             gs - set to video memory selector
   205                                  
   206                                  puts_vga_rm :
   207 000000A3 B800B8                      mov  ax,0xb800      ; point gs at video memory
   208 000000A6 8EE8                        mov  gs,ax          
   209                                  puts_vga_rm_loop :
   210 000000A8 AC                          lodsb
   211 000000A9 3C00                        cmp  al,0
   212 000000AB 7409                        jz   puts_vga_rm_done
   213 000000AD 658807                      mov  [gs:bx],al
   214 000000B0 6683C302                    add  ebx,2
   215 000000B4 EBF2                        jmp  puts_vga_rm_loop
   216                                  puts_vga_rm_done :
   217 000000B6 C3                          ret
   218                                  
   219 000000B7 4F5A2076302E30332E-     bootmsg     db      "OZ v0.03.01 - 2015/10/12 ",0
   220 000000C0 3031202D2032303135-
   221 000000C9 2F31302F31322000   
   222 000000D1 73746167652032206C-     s2errmsg    db      "stage 2 load failure ",0
   223 000000DA 6F6164206661696C75-
   224 000000E3 72652000           
   225 000000E7 692F6F206572726F72-     ioerrmsg    db      "i/o error loading stage 2 ",0
   226 000000F0 206C6F6164696E6720-
   227 000000F9 737461676520322000 
   228                                  
   229 00000102 00<rept>                times 446-($-$$) db 0       ; fill with zeros up to partition table
   230                                  
   231                                  tmpstk      equ     $
   232                                  
   233                                  ; If the kernel is loaded from a disk (including usb) the MBR
   234                                  ; must include a partition table based on the device geometry.
   235                                  ; This gets fed into oz.asm here via usbptbl.inc
   236                                  %ifdef USB
   237                                  %include "usbptbl.inc"
   238 000001BE 80000200060FFEFD    <1> db 0x80,0x00,0x02,0x00,0x06,0x0f,0xfe,0xfd
   239 000001C6 010000003F780F00    <1> db 0x01,0x00,0x00,0x00,0x3f,0x78,0x0f,0x00
   240 000001CE 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   241 000001D6 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   242 000001DE 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   243 000001E6 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   244 000001EE 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   245 000001F6 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   246                                  %else
   247                                      ; If the kernel is placed in memory by some other means
   248                                      ; (PXE, pxelinux, etc.) the partition table is irrelevant
   249                                      ; but the space is still required.  Make the default ptbl
   250                                      ; match a 1.44MB floppy.
   251                                      db 0x80,0x01,0x01,0x00,0x06,0x01,0x12,0x4f
   252                                      db 0x12,0x00,0x00,0x00,0x2e,0x0b,0x00,0x00
   253                                      db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   254                                      db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   255                                      db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   256                                  %endif
   257                                  
   258                                  %ifdef NEWUSB
   259                                  new usb?  gpt correct?
   260                                  0000 01B0: 00 00 00 00 00 2C 44 63  E0 36 03 00 00 00 80 20  .....,Dc .6.....
   261                                  0000 01C0: 21 00 83 9D 11 4C 00 08  00 00 00 C0 12 00 00 9D  !....L.. ........
   262                                  0000 01D0: 12 4C 83 57 25 F2 00 C8  12 00 00 A0 28 00 00 00  .L.W%... ....(...
   263                                  0000 01E0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ........ ........
   264                                  0000 01F0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 AA  ........ ......U.
   265                                  %endif
   266                                  
   267                                  
   268                                  times 510-($-$$) db 0       ; fill with zeros up to MBR signature
   269                                  
   270 000001FE 55AA                                dw 0x0aa55      ; write aa55 in bytes 511,512 to indicate
   271                                                              ; that it is a boot sector. 
   272                                  
   273                                  ; end of MBR
   274                                  ;
   275                                  ; -------- stage 2 ---------------------------------------------------------
   276                                  ;
   277                                  ; If a boot loader only loads 512 bytes in the first pass, the following
   278                                  ; code won't appear in memory until the code above has completed.  Other
   279                                  ; loaders however can load the entire OZ kernel image into memory in one
   280                                  ; shot.
   281                                  
   282                                  bits 16
   283                                  
   284                                  stage2 :
   285 00000200 6F7A3200                    db "oz2",0                      ; stage2 signature
   286                                  
   287                                  non_boot_cpu_ljmp_instruction :     ; place this in 16 bit code land
   288 00000204 EA00000000                  jmp word 0:0                    ; so we get the right opcode
   289                                  
   290                                  kstack_loc  equ 0x1000      ; must be on a 4k pysical page boundary
   291                                  kstack_size equ 4096*2
   292                                  
   293                                  pgdir equ 0x3000            ; use some of the free memory below us
   294                                  pgtb0 equ 0x4000            ; code below assumes this follows pgdir
   295                                  pgtb1 equ 0x5000            ; code below assumes this follows pgtb0
   296                                  
   297                                  idt   equ 0x7000            ; use some of the free memory below us
   298                                  
   299                                  ; ---------------------
   300                                  
   301                                  start_stage2 :
   302                                  
   303 00000209 B80030                      mov  ax,kstack_loc+kstack_size  ; setup the kernel stack
   304 0000020C 89C4                        mov  sp,ax
   305                                  
   306                                      ; ---- initialize the 8259's while in real mode
   307                                  
   308 0000020E E84305                      call irq_init_hardware
   309                                  
   310                                  ; ------------ main kernel entry point ------------
   311                                  ; all cpus enter here
   312                                  main :
   313                                  
   314                                      ; -------- enter protected mode --------
   315                                  
   316 00000211 0F0116[0803]                lgdt [gdtr]             ; initialize the gdt
   317 00000216 0F20C0                      mov  eax,cr0
   318 00000219 0C01                        or   al,0x01            ; set the protected mode bit (lsb of cr0)
   319 0000021B 0F22C0                      mov  cr0,eax
   320 0000021E EA[2302]0800                jmp  codesel:flush_ip1  ; flush the cpu instruction pipeline
   321                                  flush_ip1: 
   322                                  bits 32                     ; instructions after this point are 32bit
   323                                  
   324 00000223 B801000000                  mov  eax,1
   325 00000228 0FC105[14030000]            xadd [ncpus],eax        ; get our unique cpu number
   326                                                              ; could use the lapic id if available
   327 0000022F 89C6                        mov  esi,eax
   328 00000231 66B81000                    mov  ax,datasel   
   329 00000235 8ED8                        mov  ds,ax              ; initialize the data segments
   330 00000237 8EC0                        mov  es,ax
   331 00000239 66B81800                    mov  ax,stacksel        ; setup a restricted stack segment
   332 0000023D 8ED0                        mov  ss,ax
   333 0000023F BC00200000                  mov  esp,kstack_size
   334 00000244 89F0                        mov  eax,esi
   335 00000246 C1E008                      shl  eax,8              ; divvy up the stack, 256 bytes per cpu
   336 00000249 29C4                        sub  esp,eax
   337                                  
   338 0000024B 89F0                        mov  eax,esi
   339 0000024D 50                          push eax
   340 0000024E 89C3                        mov  ebx,eax
   341 00000250 80C330                      add  bl,'0'             ; boot cpu announces via ascii 0
   342 00000253 BF9E000000                  mov  edi,160-2          ; last chracter on first line of vga
   343 00000258 D1E0                        shl  eax,1
   344 0000025A 29C7                        sub  edi,eax
   345 0000025C 66B82000                    mov  ax,videosel        ; point gs at video memory
   346 00000260 8EE8                        mov  gs,ax
   347 00000262 65881F                      mov  [gs:edi],bl        ; announce cpu presence
   348 00000265 58                          pop  eax
   349                                  
   350 00000266 09C0                        or   eax,eax            ; are we the boot cpu?
   351 00000268 0F8F4E010000                jg   non_boot_init      ; if not, do non_boot_init
   352                                  
   353 0000026E E80A050000                  call irq_init_bsp_apic_hardware
   354                                  
   355                                      ; ---- debug marker
   356 00000273 65C605010000000A            mov  byte [gs:1],0xA    ; turn the first two chars green
   357 0000027B 65C605030000000A            mov  byte [gs:3],0xA
   358                                  
   359                                      ; ---- build the interrupt descriptor table
   360                                  
   361 00000283 BE[E40C0000]                mov  esi,irq_setup_table
   362 00000288 B900010000                  mov  ecx,irq_setup_table_size
   363 0000028D BA00700000                  mov  edx,idt
   364                                  irq_init :
   365 00000292 31C0                        xor  eax,eax
   366 00000294 8902                        mov  [edx],eax                  ; clear the idt entry
   367 00000296 894202                      mov  [edx+2],eax
   368 00000299 66AD                        lodsw
   369 0000029B 6689C3                      mov  bx,ax
   370 0000029E 6625FCFF                    and  ax,strict 0xfffc           ; separate config flags
   371 000002A2 6683E303                    and  bx,3                       ; from selector/offset value
   372 000002A6 6683FB02                    cmp  bx,irqt_task               ; task gates are different
   373 000002AA 7407                        jz   irq_init_task_gate
   374 000002AC 668902                      mov  [edx],ax                   ; store the handler offset
   375 000002AF 66B80800                    mov  ax,codesel
   376                                  irq_init_task_gate :
   377 000002B3 66894202                    mov  word [edx+2],ax
   378 000002B7 678AA7[E00C]                mov  ah,byte [bx+irq_types]
   379 000002BC 30C0                        xor  al,al
   380 000002BE 66894204                    mov  word [edx+4],ax
   381 000002C2 83C208                      add  edx,8
   382 000002C5 E2CB                        loop irq_init
   383                                  
   384 000002C7 0F011D[0E030000]            lidt [idtr]                     ; install the idt
   385                                  
   386                                      ; ---- setup entry point for non_boot_cpus
   387                                  
   388 000002CE A0[04020000]                mov  al,[non_boot_cpu_ljmp_instruction]     ; get the ljmp instruction
   389 000002D3 A200100000                  mov  [kstack_loc],al                        ; place it at a 4k phys mem boundary
   390 000002D8 C70501100000-               mov  dword [kstack_loc+1],main
   391 000002DE [11020000]         
   392                                  
   393                                      ; ---- setup the paging tables
   394                                  
   395 000002E2 BF00300000                  mov  edi,pgdir          ; first the page directory
   396 000002E7 0F22DF                      mov  cr3,edi            ; install the page directory
   397 000002EA B807400000                  mov  eax,pgtb0 + 7      ; page table 0: present, pl=3, r/w
   398 000002EF AB                          stosd                   ; ... pl=3 for now (simplify vga access)
   399 000002F0 B807500000                  mov  eax,pgtb1 + 7      ; page table 1: present, pl=3, r/w
   400 000002F5 AB                          stosd                   ; ... app memory
   401 000002F6 31C0                        xor  eax,eax            ; invalidate the rest of the app laddr space
   402 000002F8 B9FE030000                  mov  ecx,0x400-2        ; (yeah, only one pgdir for kernel+apps for now)
   403 000002FD F3AB                        rep stosd
   404                                  
   405                                              ; assume pgtb0 physically follows the pg dir
   406                                              ; pgtb0 is the page table for kernel memory
   407                                  
   408 000002FF AB                          stosd                   ; access to page 0 will always cause a fault
   409 00000300 B803100000                  mov  eax,0x1000 + 3     ; rest are direct map: present, pl=0, r/w
   410 00000305 B9FF030000                  mov  ecx,0x400-1
   411                                  pgtb0_fill :
   412 0000030A AB                          stosd
   413 0000030B 0500100000                  add  eax,0x1000
   414 00000310 E2F8                        loop pgtb0_fill
   415                                  
   416                                              ; assume pgtb1 physically follows pgtb0
   417                                              ; pgtb1 is the first page table for app code/data/stack
   418                                  
   419 00000312 31C0                        xor  eax,eax            ; invalidate the app logical address space
   420 00000314 B900040000                  mov  ecx,0x400          ; (we'll fill in what we need later)
   421 00000319 F3AB                        rep stosd
   422                                  
   423                                              ; enable paging
   424                                  
   425 0000031B 0F20C0                      mov  eax,cr0
   426 0000031E 0D00000080                  or   eax,0x80000000     ; msb of cr0
   427 00000323 0F22C0                      mov  cr0,eax
   428 00000326 EB00                        jmp  flush_ip2          ; flush the cpu instruction pipeline
   429                                  flush_ip2: 
   430                                  
   431                                              ; establish a "pool" of free pyhsical memory
   432                                  
   433 00000328 B810000000                  mov  eax,((kilast+0x1000) >> 12)    ; include a buffer zone
   434 0000032D A3[19030000]                mov  [next_free_page],eax
   435                                  
   436                                              ; if enabled, create page table entry for the lapic
   437                                  
   438 00000332 A0[18030000]                mov  al,[enabled_lapic]
   439 00000337 08C0                        or   al,al
   440 00000339 740F                        jz   no_lapic_init
   441                                  
   442 0000033B BA0000E0FE                  mov  edx,0xfee00000     ; phys address
   443 00000340 B900100000                  mov  ecx,0x1000         ; length
   444 00000345 E8490C0000                  call map_pmem
   445                                  
   446                                  no_lapic_init :
   447                                  
   448                                      ; ---- establish a current task
   449                                  
   450 0000034A 31C0                        xor  eax,eax
   451 0000034C B050                        mov  al,tasksel_k00
   452 0000034E 0F00D8                      ltr  ax
   453                                  
   454                                      ; ---- check for init apps
   455                                  
   456 00000351 BB[E0000000]                mov  ebx, kend
   457                                  app_loop :
   458 00000356 8B4318                      mov  eax, [ebx+0x18]    ; load the entry address
   459 00000359 813B6F7A6170                cmp  dword [ebx], 0x70617a6f  ; check for "ozap"
   460 0000035F 7402                        jz   have_an_app
   461 00000361 31C0                        xor  eax, eax           ; no app
   462                                  have_an_app :
   463                                  
   464 00000363 83F800                      cmp  eax, 0             ; is there an app to run?
   465 00000366 0F848E000000                jz   idle               ; if not, idle right away
   466                                  
   467                                      ; ---- setup the init task entry point
   468                                  
   469 0000036C BF[C0020000]                mov  edi,tss1_eip
   470 00000371 AB                          stosd
   471                                  
   472                                      ; cheat: reuse the same tss, ldt, and page tables for all
   473                                      ; the init apps - this means they run serialy - each has
   474                                      ; to exit for the next one to run
   475                                  
   476 00000372 31C0                        xor   eax,eax
   477 00000374 A3[A0020000]                mov   [tss1],eax        ; clear out previous task link
   478 00000379 AB                          stosd                   ; and some registers (flags)
   479 0000037A AB                          stosd                   ; (eax)
   480 0000037B AB                          stosd                   ; (ecx)
   481 0000037C AB                          stosd                   ; (edx)
   482 0000037D AB                          stosd                   ; (ebx)
   483 0000037E 8B4310                      mov   eax, [ebx+0x10]   ; get the end of the app
   484                                      ;add   eax,0x8001000     ; (this tests app stack page faults)
   485 00000381 AB                          stosd                   ; (esp)
   486 00000382 31C0                        xor   eax,eax
   487 00000384 AB                          stosd                   ; (ebp)
   488 00000385 AB                          stosd                   ; (esi)
   489 00000386 AB                          stosd                   ; (edi)
   490                                  
   491 00000387 BF00500000                  mov  edi,pgtb1          ; rewrite the app's page table
   492 0000038C 89D8                        mov  eax,ebx
   493 0000038E 83C805                      or   eax,5              ; init app code at 0x400000 (4Mb) present and r/o
   494 00000391 AB                          stosd                   ; assume all the init apps are < 4k
   495 00000392 0502100000                  add  eax,0x1000 + 2     ; add one page for data/bss/stack
   496 00000397 AB                          stosd
   497                                  
   498                                      ; ---- start the app
   499                                  
   500 00000398 53                          push ebx
   501 00000399 FB                          sti
   502 0000039A 9A000000005800              call tasksel_u00:0
   503 000003A1 5B                          pop  ebx
   504                                  
   505                                      ; ---- point to the end of this init app
   506                                  
   507 000003A2 0F013D00004000              invlpg [0x400000]       ; FIXME 80386 needs to reload cr3
   508 000003A9 0F013D00104000              invlpg [0x401000]
   509                                  
   510 000003B0 8B4310                      mov  eax, [ebx+0x10]    ; load the app end address
   511 000003B3 2D00004000                  sub  eax,0x400000
   512 000003B8 01C3                        add  ebx,eax            ; point ebx to the next app
   513 000003BA EB9A                        jmp  app_loop
   514                                  
   515                                  ; -------- non-boot cpu initialization --------
   516                                  
   517                                  non_boot_init :
   518                                  
   519 000003BC 0F011D[0E030000]            lidt [idtr]             ; install the global idt
   520                                  
   521                                      ; ---- enable paging
   522                                  
   523 000003C3 BF00300000                  mov  edi,pgdir          ; load this cpu's paging register
   524 000003C8 0F22DF                      mov  cr3,edi
   525                                  
   526 000003CB 50                          push eax
   527 000003CC 0F20C0                      mov  eax,cr0            ; enable paging
   528 000003CF 0D00000080                  or   eax,0x80000000
   529 000003D4 0F22C0                      mov  cr0,eax
   530 000003D7 EB00                        jmp  flush_ip3          ; flush the cpu instruction pipeline
   531                                  flush_ip3 : 
   532 000003D9 58                          pop  eax
   533                                  
   534                                      ; ---- limit the number of cpus we support here
   535                                  
   536 000003DA 83F810                      cmp  eax,16
   537 000003DD 7317                        jae  nb_idle
   538                                  
   539                                      ; ---- init the lapic
   540                                  
   541 000003DF E8F0030000                  call irq_init_ap_apic_hardware
   542                                  
   543                                      ; setup smbase?
   544                                  
   545                                      ; ---- establish a current task
   546                                  
   547 000003E4 89C3                        mov  ebx,eax            ; move cpu number to ebx
   548 000003E6 E885000000                  call create_tss_pair
   549 000003EB 53                          push ebx
   550 000003EC C1E304                      shl  ebx,4              ; 16x (selector size x2)
   551 000003EF 83C350                      add  ebx,tasksel_k00
   552 000003F2 0F00DB                      ltr  bx                 ; establish a current task
   553 000003F5 5B                          pop  ebx
   554                                  
   555                                      ; test kernel page fault handler
   556                                      ;mov  [321],eax
   557                                  
   558                                  nb_idle :
   559 000003F6 FB                          sti
   560 000003F7 F4                          hlt                     ; wait for something to do
   561 000003F8 EBFC                        jmp  nb_idle            ; (see new_thread)
   562                                  
   563                                      ; -------- boot cpu idle task --------
   564                                      ; could be combined with nb_idle but separating
   565                                      ; these can allow for easier debug
   566                                  
   567                                  idle :
   568 000003FA FB                          sti
   569 000003FB F4                          hlt                     ; wait for interrupts
   570 000003FC EBFC                        jmp  idle
   571                                  
   572                                  
   573                                  ; ----------------------------
   574                                  ;    puts_vga - write a null delimited string to the VGA controller
   575                                  ;               in protected mode
   576                                  ;    enter:
   577                                  ;         esi - address of string
   578                                  ;         ebx - screen location (2 bytes per char, 160 bytes per line)
   579                                  ;    exit:
   580                                  ;         eax - destroyed
   581                                  ;         ebx - next screen location
   582                                  ;          gs - set to video memory selector
   583                                  bits 32
   584                                  
   585                                  puts_vga :
   586 000003FE 66B82000                    mov  ax,videosel        ; point gs at video memory
   587 00000402 8EE8                        mov  gs,ax
   588                                  puts_vga_loop :
   589 00000404 2E8A06                      mov  al,[cs:esi]        ; use cs so irq handlers don't
   590 00000407 46                          inc  esi                ; have to load kernel ds
   591 00000408 3C00                        cmp  al,0
   592 0000040A 7408                        jz   puts_vga_done
   593 0000040C 658803                      mov  [gs:ebx],al
   594 0000040F 83C302                      add  ebx,2
   595 00000412 EBF0                        jmp  puts_vga_loop
   596                                  puts_vga_done :
   597 00000414 C3                          ret
   598                                  
   599                                  ; ----------------------------
   600                                  ;   putx_vga - write the contents of eax in hex to the VGA controller
   601                                  ;              (in protected mode)
   602                                  ;   putbx_vga - write the contents of al in hex to the VGA controller
   603                                  ;
   604                                  ;   enter:
   605                                  ;       eax - value to convert to hex
   606                                  ;       ebx - screen location (2 bytes per char, 160 bytes per line)
   607                                  ;   exit:
   608                                  ;       ebx - next screen location
   609                                  ;        gs - set to video memory selector
   610                                  bits 32
   611                                  
   612                                  putbx_vga :
   613 00000415 51                          push ecx
   614 00000416 B902000000                  mov  ecx,2
   615 0000041B 25FF000000                  and  eax,0xff
   616 00000420 C1C018                      rol  eax,24
   617 00000423 EB06                        jmp putx_vga_loop
   618                                  
   619                                  putx_vga :
   620 00000425 51                          push ecx
   621 00000426 B908000000                  mov  ecx,8
   622                                  putx_vga_loop :
   623 0000042B C1C004                      rol  eax,4
   624 0000042E 50                          push eax
   625 0000042F 240F                        and  al,0xf
   626 00000431 3C09                        cmp  al,9
   627 00000433 7704                        ja   putx_vga_hexdigit
   628 00000435 0430                        add  al,'0'
   629 00000437 EB02                        jmp short putx_vga_putc
   630                                  putx_vga_hexdigit :
   631 00000439 0457                        add  al,'a'-10
   632                                  putx_vga_putc :
   633 0000043B 658803                      mov  [gs:ebx],al
   634 0000043E 83C302                      add  ebx,2
   635 00000441 58                          pop  eax
   636 00000442 83E0F0                      and  eax,0xfffffff0
   637 00000445 E2E4                        loop putx_vga_loop
   638 00000447 65C60320                    mov  byte [gs:ebx],' '
   639 0000044B 83C302                      add  ebx,2
   640 0000044E 59                          pop  ecx
   641 0000044F C3                          ret
   642                                  
   643                                  ;------------------------------------------------------------------
   644                                  ;   mem_alloc_kernel_page - return the 4k page number of 1 page of memory
   645                                  ;                           from the kernel page pool
   646                                  ;
   647                                  ;   returns:    eax = page number, zero means no pages left
   648                                  
   649                                  mem_alloc_kernel_page :
   650 00000450 A1[19030000]                mov  eax,[next_free_page]
   651 00000455 FF05[19030000]              inc  dword [next_free_page]
   652                                      ; probably should check for the end of something ...
   653 0000045B 50                          push eax
   654 0000045C 51                          push ecx
   655 0000045D 57                          push edi
   656 0000045E C1E00C                      shl  eax,12
   657 00000461 B900040000                  mov  ecx,0x1000/4
   658 00000466 89C7                        mov  edi,eax
   659 00000468 31C0                        xor  eax,eax
   660 0000046A F3AB                        rep stosd                   ; zero the page
   661 0000046C 5F                          pop  edi
   662 0000046D 59                          pop  ecx
   663 0000046E 58                          pop  eax
   664 0000046F C3                          ret
   665                                  
   666                                  ;------------------------------------------------------------------
   667                                  ;   create a pair of tss structs for a new cpu
   668                                  ;
   669                                  ;   enter:
   670                                  ;       ebx - cpu number
   671                                  ;   exit:
   672                                  ;       ebx - cpu number
   673                                  
   674                                  create_tss_pair :
   675 00000470 E8DBFFFFFF                  call mem_alloc_kernel_page
   676 00000475 09C0                        or   eax,eax
   677 00000477 0F8495000000                jz   create_tss_pair_fail
   678 0000047D C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   679 00000480 89C7                        mov  edi,eax
   680                                  
   681 00000482 89FE                        mov  esi,edi
   682 00000484 83C668                      add  esi,(tss0_end-tss0)
   683                                  
   684 00000487 B800300000                  mov  eax,pgdir
   685 0000048C 89471C                      mov  [edi+(tss0_cr3-tss0)],eax
   686 0000048F 89461C                      mov  [esi+(tss0_cr3-tss0)],eax
   687                                  
   688 00000492 B817000000                  mov  eax,datasel1+7
   689 00000497 894648                      mov  [esi+(tss0_es-tss0)],eax
   690 0000049A 894650                      mov  [esi+(tss0_ss-tss0)],eax
   691 0000049D 894654                      mov  [esi+(tss0_ds-tss0)],eax
   692 000004A0 B80F000000                  mov  eax,codesel1+7
   693 000004A5 89464C                      mov  [esi+(tss0_cs-tss0)],eax
   694 000004A8 B83B000000                  mov  eax,ldtsel1+3
   695 000004AD 894660                      mov  [esi+(tss0_ldt-tss0)],eax
   696                                  
   697                                      ; setup the tss structs (edi = kernel, esi = user).
   698                                      ; there are three stacks total
   699                                      ;   (1) kernel tss esp0 - placed at the end of this page
   700                                      ;   (2) user tss esp0 (for interrupt handling) - end minus 1k
   701                                      ;   (3) user tss esp3 (esp) - will be set up by new_thread
   702                                  
   703 000004B0 89F8                        mov  eax,edi
   704 000004B2 0500100000                  add  eax,0x1000
   705 000004B7 894704                      mov  [edi+(tss0_esp0-tss0)],eax ; (1) kernel tss esp0
   706 000004BA 2D00040000                  sub  eax,0x400
   707 000004BF 894604                      mov  [esi+(tss0_esp0-tss0)],eax ; (2) user tss esp0
   708                                      ;mov  eax,stacksel
   709 000004C2 B810000000                  mov  eax,datasel
   710 000004C7 894708                      mov  [edi+(tss0_ss0-tss0)],eax
   711 000004CA 894608                      mov  [esi+(tss0_ss0-tss0)],eax
   712                                  
   713                                      ; patch the tss addresses into the reserved gdt selectors
   714                                  
   715 000004CD 89DA                        mov  edx,ebx
   716 000004CF C1E204                      shl  edx,4                      ; 16x because selectors are in pairs
   717 000004D2 83C250                      add  edx,tasksel_k00
   718                                  
   719 000004D5 89F8                        mov  eax,edi
   720 000004D7 C1E818                      shr  eax,24
   721 000004DA 8882[07000000]              mov  byte [gdt+edx+7],al        ; base 24-32
   722 000004E0 81E7FFFFFF00                and  edi,0xffffff
   723 000004E6 0BBA[02000000]              or   edi,[gdt+edx+2]            ; or in flags
   724 000004EC 89BA[02000000]              mov  [gdt+edx+2],edi            ; base 0-23 and flags
   725                                  
   726 000004F2 83C208                      add  edx,8                      ; move to tasksel_uxx
   727                                  
   728 000004F5 89F0                        mov  eax,esi
   729 000004F7 C1E818                      shr  eax,24
   730 000004FA 8882[07000000]              mov  byte [gdt+edx+7],al        ; base 24-32
   731 00000500 81E6FFFFFF00                and  esi,0xffffff
   732 00000506 0BB2[02000000]              or   esi,[gdt+edx+2]            ; or in flags
   733 0000050C 89B2[02000000]              mov  [gdt+edx+2],esi            ; base 0-23 and flags
   734                                  
   735                                  create_tss_pair_fail :
   736 00000512 C3                          ret
   737                                  
   738                                  ; -------- interrupt handlers --------
   739                                  %include "ozirq.asm"
   740                              <1> ; OZ - A more utopian OS    x86-32 interrupts
   741                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
   742                              <1> ;
   743                              <1> ; Copyright (C) 2015  Duane Voth
   744                              <1> ;
   745                              <1> ;   This program is free software: you can redistribute it and/or modify
   746                              <1> ;   it under the terms of the GNU Affero General Public License as
   747                              <1> ;   published by the Free Software Foundation, either version 3 of the
   748                              <1> ;   License, or (at your option) any later version.
   749                              <1> ;
   750                              <1> ;   This program is distributed in the hope that it will be useful,
   751                              <1> ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
   752                              <1> ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   753                              <1> ;   GNU Affero General Public License for more details.
   754                              <1> ;
   755                              <1> ;   You should have received a copy of the GNU Affero General Public License
   756                              <1> ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
   757                              <1> ;
   758                              <1> ;
   759                              <1> ; IRQ handling
   760                              <1> 
   761 00000513 63707500            <1> cpumsg      db      "cpu",0
   762                              <1> 
   763 00000517 646976696465206279- <1> int00msg    db      "divide by zero ",0
   764 00000520 207A65726F2000      <1>
   765 00000527 646562756720657863- <1> int01msg    db      "debug exception ",0
   766 00000530 657074696F6E2000    <1>
   767 00000538 6E6D692000          <1> int02msg    db      "nmi ",0
   768 0000053D 627265616B706F696E- <1> int03msg    db      "breakpoint exception ",0
   769 00000546 742065786365707469- <1>
   770 0000054F 6F6E2000            <1>
   771 00000553 6F766572666C6F7720- <1> int04msg    db      "overflow exception ",0
   772 0000055C 657863657074696F6E- <1>
   773 00000565 2000                <1>
   774 00000567 626F756E6420657863- <1> int05msg    db      "bound exceeded ",0
   775 00000570 65656465642000      <1>
   776 00000577 696E76616C6964206F- <1> int06msg    db      "invalid opcode ",0
   777 00000580 70636F64652000      <1>
   778 00000587 64657669636520756E- <1> int07msg    db      "device unavailable ",0
   779 00000590 617661696C61626C65- <1>
   780 00000599 2000                <1>
   781 0000059B 646F75626C65206661- <1> int08msg    db      "double fault ",0
   782 000005A4 756C742000          <1>
   783 000005A9 636F70726F63657373- <1> int09msg    db      "coprocessor segment overrun ",0
   784 000005B2 6F72207365676D656E- <1>
   785 000005BB 74206F76657272756E- <1>
   786 000005C4 2000                <1>
   787 000005C6 696E76616C69642074- <1> int10msg    db      "invalid tss ",0
   788 000005CF 73732000            <1>
   789 000005D3 7365676D656E74206E- <1> int11msg    db      "segment not present ",0
   790 000005DC 6F742070726573656E- <1>
   791 000005E5 742000              <1>
   792 000005E8 737461636B20666175- <1> int12msg    db      "stack fault ",0
   793 000005F1 6C742000            <1>
   794 000005F5 67656E6572616C2070- <1> int13msg    db      "general protection fault ",0
   795 000005FE 726F74656374696F6E- <1>
   796 00000607 206661756C742000    <1>
   797 0000060F 6B65726E656C207061- <1> int14kmsg   db      "kernel page fault addr=",0
   798 00000618 6765206661756C7420- <1>
   799 00000621 616464723D00        <1>
   800 00000627 617070207061676520- <1> int14umsg   db      "app page fault addr=",0
   801 00000630 6661756C7420616464- <1>
   802 00000639 723D00              <1>
   803 0000063C 666C6F6174696E6720- <1> int16msg    db      "floating point err ",0
   804 00000645 706F696E7420657272- <1>
   805 0000064E 2000                <1>
   806 00000650 616C69676E6D656E74- <1> int17msg    db      "alignment check ",0
   807 00000659 20636865636B2000    <1>
   808 00000661 6D616368696E652063- <1> int18msg    db      "machine check ",0
   809 0000066A 6865636B2000        <1>
   810 00000670 73696D6420666C6F61- <1> int19msg    db      "simd floating point err ",0
   811 00000679 74696E6720706F696E- <1>
   812 00000682 74206572722000      <1>
   813                              <1> 
   814 00000689 687720696E74303220- <1> int34msg    db      "hw int02 ",0
   815 00000692 00                  <1>
   816 00000693 687720696E74303320- <1> int35msg    db      "hw int03 ",0
   817 0000069C 00                  <1>
   818 0000069D 687720696E74303420- <1> int36msg    db      "hw int04 ",0
   819 000006A6 00                  <1>
   820 000006A7 687720696E74303520- <1> int37msg    db      "hw int05 ",0
   821 000006B0 00                  <1>
   822 000006B1 687720696E74303620- <1> int38msg    db      "hw int06 ",0
   823 000006BA 00                  <1>
   824 000006BB 687720696E74303720- <1> int39msg    db      "hw int07 ",0
   825 000006C4 00                  <1>
   826 000006C5 687720696E74303820- <1> int40msg    db      "hw int08 ",0
   827 000006CE 00                  <1>
   828 000006CF 687720696E74303920- <1> int41msg    db      "hw int09 ",0
   829 000006D8 00                  <1>
   830 000006D9 687720696E74313020- <1> int42msg    db      "hw int10 ",0
   831 000006E2 00                  <1>
   832 000006E3 687720696E74313120- <1> int43msg    db      "hw int11 ",0
   833 000006EC 00                  <1>
   834 000006ED 687720696E74313220- <1> int44msg    db      "hw int12 ",0
   835 000006F6 00                  <1>
   836 000006F7 687720696E74313320- <1> int45msg    db      "hw int13 ",0
   837 00000700 00                  <1>
   838 00000701 687720696E74313420- <1> int46msg    db      "hw int14 ",0
   839 0000070A 00                  <1>
   840 0000070B 687720696E74313520- <1> int47msg    db      "hw int15 ",0
   841 00000714 00                  <1>
   842                              <1> 
   843 00000715 73707572696F757320- <1> spuriousmsg db      "spurious int ",0
   844 0000071E 696E742000          <1>
   845 00000723 617069636572722069- <1> apicerrmsg  db      "apicerr int ",0
   846 0000072C 6E742000            <1>
   847 00000730 68692000            <1> himsg       db      "hi ",0
   848 00000734 756E6B6E6F776E2073- <1> int255msg           db  "unknown system call ",0
   849 0000073D 797374656D2063616C- <1>
   850 00000746 6C2000              <1>
   851                              <1> 
   852 00000749 766D206661756C743A- <1> intvmmsg            db  "vm fault: ",0
   853 00000752 2000                <1>
   854                              <1> 
   855                              <1> ; ---- IRQ hardware initialization ----
   856                              <1> 
   857                              <1> bits 16
   858                              <1> 
   859                              <1> irq_init_hardware :
   860                              <1> 
   861                              <1>     ; re-program the 8259's to move the hardware vectors out of the
   862                              <1>     ; soft int range ... C'mon, Intel was pretty clear about this!
   863                              <1> 
   864 00000754 B011                <1>     mov  al,0x11
   865 00000756 E620                <1>     out  0x20,al            ; init the 1st 8259
   866 00000758 B011                <1>     mov  al,0x11
   867 0000075A E6A0                <1>     out  0xA0,al            ; init the 2nd 8259
   868 0000075C B020                <1>     mov  al,apic0_irqbase
   869 0000075E E621                <1>     out  0x21,al            ; base for the 1st 8259
   870 00000760 B028                <1>     mov  al,apic1_irqbase
   871 00000762 E6A1                <1>     out  0xA1,al            ; base for the 2nd 8259
   872 00000764 B004                <1>     mov  al,0x04
   873 00000766 E621                <1>     out  0x21,al            ; set 1st 8259 as master
   874 00000768 B002                <1>     mov  al,0x02
   875 0000076A E6A1                <1>     out  0xA1,al            ; set 2nd 8259 as slave
   876 0000076C B001                <1>     mov  al,0x01
   877 0000076E E621                <1>     out  0x21,al
   878 00000770 B001                <1>     mov  al,0x01
   879 00000772 E6A1                <1>     out  0xA1,al
   880 00000774 B000                <1>     mov  al,0x00
   881 00000776 E621                <1>     out  0x21,al
   882 00000778 B000                <1>     mov  al,0x00
   883 0000077A E6A1                <1>     out  0xA1,al
   884 0000077C C3                  <1>     ret
   885                              <1> 
   886                              <1> bits 32
   887                              <1> 
   888                              <1> ; ----------
   889                              <1> 
   890                              <1> irq_init_bsp_apic_hardware :
   891                              <1>     ;jmp  no_apic
   892                              <1> 
   893                              <1>     ; ---- test for an apic
   894                              <1> 
   895 0000077D B801000000          <1>     mov  eax,1
   896 00000782 0FA2                <1>     cpuid
   897 00000784 83F801              <1>     cmp  eax,1
   898 00000787 724A                <1>     jb   no_apic
   899 00000789 81E200020000        <1>     and  edx,1 << 9         ; apic feature
   900 0000078F 7442                <1>     jz   no_apic
   901                              <1> 
   902                              <1> ;   mov  eax,[0xfee00370]
   903                              <1> ;   and  eax,0xffffff00
   904                              <1> ;   or   eax,apicerr_int
   905                              <1> ;   mov  [0xfee00370],eax   ; setup LVT3 error vector
   906                              <1> 
   907 00000791 A13000E0FE          <1>     mov  eax,[0xfee00030]
   908 00000796 25F0000000          <1>     and  eax,0xf0           ; see if it is a local apic
   909 0000079B 83F810              <1>     cmp  eax,0x10
   910 0000079E 7533                <1>     jnz  no_lapic
   911 000007A0 C605[18030000]01    <1>     mov  byte [enabled_lapic],0x1
   912                              <1> 
   913 000007A7 B8F0010000          <1>     mov  eax,0x000001f0     ; enable lapic, use spurious int 0xf0
   914 000007AC A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
   915 000007B1 B800000001          <1>     mov  eax,0x01000000
   916 000007B6 A3D000E0FE          <1>     mov  [0xfee000d0],eax   ; set our LDR
   917 000007BB B8FFFFFFFF          <1>     mov  eax,0xffffffff
   918 000007C0 A3E000E0FE          <1>     mov  [0xfee000e0],eax   ; set our DFR
   919                              <1> 
   920                              <1> ;    ; ---- enable the local apic via msr
   921                              <1> ; but apparently not needed ...
   922                              <1> ;    mov  ecx,0x1b
   923                              <1> ;    xor  edx,edx
   924                              <1> ; ;  mov  eax,0xfffff800
   925                              <1> ;    mov  eax,0x00000800
   926                              <1> ;    wrmsr
   927                              <1> ;    mov  eax,[0xfffff030]
   928                              <1> 
   929                              <1>     ; ---- visual indicator: lapic active
   930                              <1> 
   931 000007C5 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
   932 000007C9 8EE8                <1>     mov  gs,ax          
   933 000007CB 65C605320000002B    <1>     mov  byte [gs:25*2],'+'
   934                              <1> 
   935                              <1> no_apic :
   936                              <1> no_lapic :
   937 000007D3 C3                  <1>     ret
   938                              <1> 
   939                              <1> ; ----------
   940                              <1> 
   941                              <1> irq_init_ap_apic_hardware :
   942                              <1> 
   943                              <1>     ; ---- mtrr for 0xfee00000 -> strong uncachable (UC) ?
   944                              <1> 
   945 000007D4 50                  <1>     push eax                ; save cpu number
   946 000007D5 89C1                <1>     mov  ecx,eax
   947 000007D7 A0[18030000]        <1>     mov  al,[enabled_lapic]
   948 000007DC 08C0                <1>     or   al,al
   949 000007DE 7432                <1>     jz  no_lapic_init2
   950                              <1> 
   951 000007E0 BB00000001          <1>     mov  ebx,0x01000000
   952 000007E5 D3E3                <1>     shl  ebx,cl             ; bit mask based on cpu number
   953 000007E7 891DD000E0FE        <1>     mov  [0xfee000d0],ebx   ; set our LDR
   954                              <1> 
   955 000007ED A17003E0FE          <1>     mov  eax,[0xfee00370]
   956 000007F2 2500FFFFFF          <1>     and  eax,0xffffff00
   957 000007F7 0DF1000000          <1>     or   eax,apicerr_int
   958 000007FC A37003E0FE          <1>     mov  [0xfee00370],eax   ; setup LVT3 error vector
   959                              <1> 
   960 00000801 B8F0010000          <1>     mov  eax,0x00000100 + spurious_int  ; enable lapic
   961 00000806 A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
   962 0000080B 31C0                <1>     xor  eax,eax
   963 0000080D A3B000E0FE          <1>     mov  [0xfee000b0],eax   ; eoi anything outstanding
   964                              <1> no_lapic_init2 :
   965 00000812 58                  <1>     pop  eax
   966 00000813 C3                  <1>     ret
   967                              <1> 
   968                              <1> ; ---- IRQ handlers ----
   969                              <1> 
   970                              <1> align 4
   971                              <1> int_handler_div0 :
   972 00000814 56                  <1>     push esi
   973 00000815 BE[17050000]        <1>     mov  esi,int00msg
   974 0000081A E856040000          <1>     call irq_print_msg
   975 0000081F 5E                  <1>     pop  esi
   976 00000820 E9F0000000          <1>     jmp  int_handler_show_eip
   977                              <1> 
   978 00000825 90<rept>            <1> align 4
   979                              <1> int_handler_debug :
   980 00000828 56                  <1>     push esi
   981 00000829 BE[27050000]        <1>     mov  esi,int01msg
   982 0000082E E842040000          <1>     call irq_print_msg
   983 00000833 5E                  <1>     pop  esi
   984 00000834 E9DC000000          <1>     jmp  int_handler_show_eip
   985                              <1> 
   986 00000839 90<rept>            <1> align 4
   987                              <1> int_handler_nmi :
   988 0000083C 56                  <1>     push esi
   989 0000083D BE[38050000]        <1>     mov  esi,int02msg
   990 00000842 E82E040000          <1>     call irq_print_msg
   991 00000847 5E                  <1>     pop  esi
   992 00000848 E958040000          <1>     jmp  reboot_on_alt_key
   993                              <1> 
   994 0000084D 90<rept>            <1> align 4
   995                              <1> int_handler_brkp :
   996 00000850 56                  <1>     push esi
   997 00000851 BE[3D050000]        <1>     mov  esi,int03msg
   998 00000856 E81A040000          <1>     call irq_print_msg
   999 0000085B 5E                  <1>     pop  esi
  1000 0000085C E9B4000000          <1>     jmp  int_handler_show_eip
  1001                              <1> 
  1002 00000861 90<rept>            <1> align 4
  1003                              <1> int_handler_ovrflw :
  1004 00000864 56                  <1>     push esi
  1005 00000865 BE[53050000]        <1>     mov  esi,int04msg
  1006 0000086A E806040000          <1>     call irq_print_msg
  1007 0000086F 5E                  <1>     pop  esi
  1008 00000870 E9A0000000          <1>     jmp  int_handler_show_eip
  1009                              <1> 
  1010 00000875 90<rept>            <1> align 4
  1011                              <1> int_handler_bound :
  1012 00000878 56                  <1>     push esi
  1013 00000879 BE[67050000]        <1>     mov  esi,int05msg
  1014 0000087E E8F2030000          <1>     call irq_print_msg
  1015 00000883 5E                  <1>     pop  esi
  1016 00000884 E98C000000          <1>     jmp  int_handler_show_eip
  1017                              <1> 
  1018 00000889 90<rept>            <1> align 4
  1019                              <1> int_handler_invop :
  1020 0000088C 56                  <1>     push esi
  1021 0000088D BE[77050000]        <1>     mov  esi,int06msg
  1022 00000892 E8DE030000          <1>     call irq_print_msg
  1023 00000897 5E                  <1>     pop  esi
  1024 00000898 EB7B                <1>     jmp  int_handler_show_eip
  1025                              <1> 
  1026 0000089A 90<rept>            <1> align 4
  1027                              <1> int_handler_devna :
  1028                              <1>     ;push esi
  1029                              <1>     ;mov  esi,int07msg
  1030                              <1>     ;call irq_print_msg
  1031                              <1>     ;pop  esi
  1032                              <1>     ; FIXME fxsave/fxrestore the fpu/sse/mmx regs
  1033 0000089C 0F06                <1>     clts
  1034 0000089E CF                  <1>     iret
  1035                              <1> 
  1036 0000089F 90                  <1> align 4
  1037                              <1> int_handler_cpsego :
  1038 000008A0 56                  <1>     push esi
  1039 000008A1 BE[A9050000]        <1>     mov  esi,int09msg
  1040 000008A6 E8CA030000          <1>     call irq_print_msg
  1041 000008AB 5E                  <1>     pop  esi
  1042 000008AC EB67                <1>     jmp  int_handler_show_eip
  1043                              <1> 
  1044 000008AE 90<rept>            <1> align 4
  1045                              <1> int_handler_segnp :
  1046                              <1>     ; ec = seg selector
  1047 000008B0 56                  <1>     push esi
  1048 000008B1 BE[D3050000]        <1>     mov  esi,int11msg
  1049 000008B6 E8BA030000          <1>     call irq_print_msg
  1050 000008BB 5E                  <1>     pop  esi
  1051 000008BC EB32                <1>     jmp  int_handler_show_ec_eip
  1052                              <1> 
  1053 000008BE 90<rept>            <1> align 4
  1054                              <1> int_handler_stkflt :
  1055                              <1>     ; ec = seg selector
  1056 000008C0 56                  <1>     push esi
  1057 000008C1 BE[E8050000]        <1>     mov  esi,int12msg
  1058 000008C6 E8AA030000          <1>     call irq_print_msg
  1059 000008CB 5E                  <1>     pop  esi
  1060 000008CC B904000000          <1>     mov  ecx,4
  1061 000008D1 83C302              <1>     add  ebx,2
  1062                              <1> int_handler_show_stack_loop :
  1063 000008D4 58                  <1>     pop  eax
  1064 000008D5 E84BFBFFFF          <1>     call putx_vga
  1065 000008DA E2F8                <1>     loop int_handler_show_stack_loop
  1066 000008DC E9C4030000          <1>     jmp  reboot_on_alt_key
  1067                              <1> 
  1068 000008E1 90<rept>            <1> align 4
  1069                              <1> int_handler_gpf :
  1070                              <1>     ; ec = various ...
  1071                              <1>     ;test dword [esp+0xc],1 << 17    ; check the eflags vm bit
  1072                              <1>     ;jnz  int_handler_vm_gpf
  1073                              <1> 
  1074 000008E4 56                  <1>     push esi
  1075 000008E5 BE[F5050000]        <1>     mov  esi,int13msg
  1076 000008EA E886030000          <1>     call irq_print_msg
  1077 000008EF 5E                  <1>     pop  esi
  1078                              <1> int_handler_show_ec_eip :
  1079 000008F0 65C60365            <1>     mov  byte [gs:ebx],'e'
  1080 000008F4 83C302              <1>     add  ebx,2
  1081 000008F7 65C60363            <1>     mov  byte [gs:ebx],'c'
  1082 000008FB 83C302              <1>     add  ebx,2
  1083 000008FE 65C6033D            <1>     mov  byte [gs:ebx],'='
  1084 00000902 83C302              <1>     add  ebx,2
  1085 00000905 58                  <1>     pop  eax                ; ec
  1086 00000906 E80AFBFFFF          <1>     call putbx_vga
  1087 0000090B 83EB02              <1>     sub  ebx,2
  1088 0000090E 65C60320            <1>     mov  byte [gs:ebx],' '
  1089 00000912 83C302              <1>     add  ebx,2
  1090                              <1> int_handler_show_eip :
  1091 00000915 65C60363            <1>     mov  byte [gs:ebx],'c'
  1092 00000919 83C302              <1>     add  ebx,2
  1093 0000091C 65C60373            <1>     mov  byte [gs:ebx],'s'
  1094 00000920 83C302              <1>     add  ebx,2
  1095 00000923 65C6033A            <1>     mov  byte [gs:ebx],':'
  1096 00000927 83C302              <1>     add  ebx,2
  1097 0000092A 65C60365            <1>     mov  byte [gs:ebx],'e'
  1098 0000092E 83C302              <1>     add  ebx,2
  1099 00000931 65C60369            <1>     mov  byte [gs:ebx],'i'
  1100 00000935 83C302              <1>     add  ebx,2
  1101 00000938 65C60370            <1>     mov  byte [gs:ebx],'p'
  1102 0000093C 83C302              <1>     add  ebx,2
  1103 0000093F 65C6033D            <1>     mov  byte [gs:ebx],'='
  1104 00000943 83C302              <1>     add  ebx,2
  1105 00000946 5A                  <1>     pop  edx                ; eip
  1106 00000947 58                  <1>     pop  eax                ; cs
  1107 00000948 E8D8FAFFFF          <1>     call putx_vga
  1108 0000094D 83EB02              <1>     sub  ebx,2
  1109 00000950 65C6033A            <1>     mov  byte [gs:ebx],':'
  1110 00000954 83C302              <1>     add  ebx,2
  1111 00000957 89D0                <1>     mov  eax,edx
  1112 00000959 E8C7FAFFFF          <1>     call putx_vga
  1113 0000095E E942030000          <1>     jmp  reboot_on_alt_key
  1114                              <1> 
  1115                              <1> int_handler_vm_gpf :
  1116 00000963 53                  <1>     push ebx
  1117                              <1>     ;mov  ebx,[esp+8]        ; faulter's eip
  1118 00000964 2E8A1B              <1>     mov  bl,[cs:ebx]        ; get the opcode that caused the fault
  1119 00000967 80FBF4              <1>     cmp  bl,0xf4            ; 'hlt' is ok
  1120 0000096A 7452                <1>     jz   int_handler_vm_normal_return
  1121                              <1> 
  1122 0000096C 56                  <1>     push esi
  1123 0000096D 50                  <1>     push eax
  1124 0000096E 53                  <1>     push ebx
  1125 0000096F BE[49070000]        <1>     mov  esi,intvmmsg
  1126 00000974 E8FC020000          <1>     call irq_print_msg
  1127 00000979 65C6036F            <1>     mov  byte [gs:ebx],'o'
  1128 0000097D 83C302              <1>     add  ebx,2
  1129 00000980 65C60370            <1>     mov  byte [gs:ebx],'p'
  1130 00000984 83C302              <1>     add  ebx,2
  1131 00000987 65C60363            <1>     mov  byte [gs:ebx],'c'
  1132 0000098B 83C302              <1>     add  ebx,2
  1133 0000098E 65C6036F            <1>     mov  byte [gs:ebx],'o'
  1134 00000992 83C302              <1>     add  ebx,2
  1135 00000995 65C60364            <1>     mov  byte [gs:ebx],'d'
  1136 00000999 83C302              <1>     add  ebx,2
  1137 0000099C 65C60365            <1>     mov  byte [gs:ebx],'e'
  1138 000009A0 83C302              <1>     add  ebx,2
  1139 000009A3 65C60328            <1>     mov  byte [gs:ebx],'('
  1140 000009A7 83C302              <1>     add  ebx,2
  1141 000009AA 58                  <1>     pop  eax
  1142 000009AB 25FF000000          <1>     and  eax,0xff
  1143 000009B0 E860FAFFFF          <1>     call putbx_vga
  1144 000009B5 83C302              <1>     add  ebx,2
  1145 000009B8 65C60329            <1>     mov  byte [gs:ebx],')'
  1146 000009BC 58                  <1>     pop  eax
  1147 000009BD 5E                  <1>     pop  esi
  1148                              <1> int_handler_vm_normal_return :
  1149 000009BE 5B                  <1>     pop  ebx
  1150                              <1> 
  1151 000009BF FF74240C            <1>     push dword [esp+0xc]    ; eflags
  1152 000009C3 9D                  <1>     popf                    ; restore the VM and NT flags
  1153 000009C4 CF                  <1>     iret                    ; chain back via nested task
  1154                              <1>                             ; from v86 tss to original caller
  1155                              <1> 
  1156 000009C5 90<rept>            <1> align 4
  1157                              <1> int_handler_pgflt :
  1158 000009C8 58                  <1>     pop  eax
  1159 000009C9 50                  <1>     push eax
  1160 000009CA A904000000          <1>     test eax,0x4                        ; user mode or supervisor?
  1161 000009CF 7407                <1>     jz   int_handler_pgflt_bad_kaddr    ; if not, kernel failed
  1162                              <1> 
  1163                              <1> int_handler_pgflt_bad_uaddr :
  1164 000009D1 BE[27060000]        <1>     mov  esi,int14umsg
  1165 000009D6 EB05                <1>     jmp  int_handler_pgflt_msg
  1166                              <1> 
  1167                              <1> int_handler_pgflt_bad_kaddr :
  1168 000009D8 BE[0F060000]        <1>     mov  esi,int14kmsg
  1169                              <1> 
  1170                              <1> int_handler_pgflt_msg :
  1171 000009DD E893020000          <1>     call irq_print_msg
  1172 000009E2 0F20D0              <1>     mov  eax,cr2
  1173 000009E5 E83BFAFFFF          <1>     call putx_vga                       ; print the addres of the fault
  1174 000009EA E901FFFFFF          <1>     jmp  int_handler_show_ec_eip
  1175                              <1> 
  1176 000009EF 90                  <1> align 4
  1177                              <1> int_handler_fpuerr :
  1178 000009F0 56                  <1>     push esi
  1179 000009F1 BE[3C060000]        <1>     mov  esi,int16msg
  1180 000009F6 E87A020000          <1>     call irq_print_msg
  1181                              <1>     ; FIXME flags identify error
  1182                              <1>     ;   IS - FPU stack overflow
  1183                              <1>     ;   IA - Invalid arithmetic operation
  1184                              <1>     ;   Z  - Divide by zero
  1185                              <1>     ;   D  - Source operand is a denormal number
  1186                              <1>     ;   O  - Overflow in result
  1187                              <1>     ;   U  - Underflow in result
  1188                              <1>     ;   P  - Inexact result
  1189 000009FB E915FFFFFF          <1>     jmp  int_handler_show_eip
  1190                              <1> 
  1191                              <1> align 4
  1192                              <1> int_handler_algnchk :
  1193                              <1>     ; ec = zero
  1194 00000A00 56                  <1>     push esi
  1195 00000A01 BE[50060000]        <1>     mov  esi,int17msg
  1196 00000A06 E86A020000          <1>     call irq_print_msg
  1197 00000A0B 5E                  <1>     pop  esi
  1198 00000A0C 58                  <1>     pop  eax                    ; toss the ec
  1199 00000A0D E903FFFFFF          <1>     jmp  int_handler_show_eip
  1200                              <1> 
  1201 00000A12 90<rept>            <1> align 4
  1202                              <1> int_handler_machchk :
  1203 00000A14 56                  <1>     push esi
  1204 00000A15 BE[61060000]        <1>     mov  esi,int18msg
  1205 00000A1A E856020000          <1>     call irq_print_msg
  1206 00000A1F 5E                  <1>     pop  esi
  1207 00000A20 E9F0FEFFFF          <1>     jmp  int_handler_show_eip
  1208                              <1> 
  1209 00000A25 90<rept>            <1> align 4
  1210                              <1> int_handler_simdfpe :
  1211 00000A28 56                  <1>     push esi
  1212 00000A29 BE[70060000]        <1>     mov  esi,int19msg
  1213 00000A2E E842020000          <1>     call irq_print_msg
  1214 00000A33 5E                  <1>     pop  esi
  1215 00000A34 E9DCFEFFFF          <1>     jmp  int_handler_show_eip
  1216                              <1> 
  1217 00000A39 90<rept>            <1> align 4
  1218                              <1> int_handler_timer :     
  1219                              <1>     ;cli
  1220 00000A3C 60                  <1>     pusha
  1221 00000A3D 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
  1222 00000A41 8EE8                <1>     mov  gs,ax          
  1223 00000A43 658A1D01000000      <1>     mov  bl,byte [gs:1]     ; inc the color of the first two chars
  1224 00000A4A FEC3                <1>     inc  bl
  1225 00000A4C 80E30F              <1>     and  bl,0xf             ; just the foreground
  1226 00000A4F 65881D01000000      <1>     mov  byte [gs:1],bl
  1227 00000A56 65881D03000000      <1>     mov  byte [gs:3],bl
  1228                              <1> 
  1229                              <1>     ; ---- wakeup any sleeping cpus (see syscall_sleep)
  1230                              <1> 
  1231 00000A5D A0[18030000]        <1>     mov  al,[enabled_lapic]
  1232 00000A62 08C0                <1>     or   al,al
  1233 00000A64 741B                <1>     jz   no_sleepers
  1234                              <1> 
  1235                              <1>     ; the race here is not important, we'll catch them on the next tick
  1236                              <1> 
  1237 00000A66 A1[1D030000]        <1>     mov  eax,[sleepers]
  1238 00000A6B 09C0                <1>     or   eax,eax
  1239 00000A6D 7412                <1>     jz   no_sleepers
  1240 00000A6F C1E018              <1>     shl  eax,24                     ; FIXME can only handle 8 cpus
  1241 00000A72 A31003E0FE          <1>     mov  dword [0xfee00310],eax     ; via the destination register ...
  1242 00000A77 B8FE480000          <1>     mov  eax,0x04800 + wakeup_int   ; no shrthnd, fixed, logical, edge
  1243 00000A7C A30003E0FE          <1>     mov  dword [0xfee00300],eax
  1244                              <1> 
  1245                              <1> no_sleepers :
  1246 00000A81 B020                <1>     mov  al,0x20        
  1247 00000A83 E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1248 00000A85 61                  <1>     popa
  1249 00000A86 CF                  <1>     iret                
  1250                              <1> 
  1251 00000A87 90                  <1> align 4
  1252                              <1> int_handler_kbd :
  1253                              <1>     ;cli
  1254 00000A88 B020                <1>     mov  al,0x20
  1255 00000A8A E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1256                              <1> 
  1257 00000A8C 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
  1258 00000A90 8EE8                <1>     mov  gs,ax          
  1259                              <1> 
  1260 00000A92 53                  <1>     push ebx
  1261 00000A93 BB3C000000          <1>     mov  ebx,30*2
  1262 00000A98 E460                <1>     in   al,0x60
  1263 00000A9A 50                  <1>     push eax
  1264 00000A9B E875F9FFFF          <1>     call putbx_vga
  1265 00000AA0 58                  <1>     pop  eax
  1266                              <1> 
  1267 00000AA1 3C5B                <1>     cmp  al,0x5b            ; scan code for "the windows key"
  1268 00000AA3 0F8403020000        <1>     jz   reboot
  1269                              <1> 
  1270 00000AA9 65A044000000        <1>     mov  al,[gs:34*2]
  1271 00000AAF FEC0                <1>     inc  al
  1272 00000AB1 65A244000000        <1>     mov  [gs:34*2],al       ; change a character on screen
  1273                              <1> 
  1274 00000AB7 5B                  <1>     pop  ebx
  1275 00000AB8 CF                  <1>     iret
  1276                              <1> 
  1277 00000AB9 90<rept>            <1> align 4
  1278                              <1> int_handler_hw02 :
  1279 00000ABC 56                  <1>     push esi
  1280 00000ABD BE[89060000]        <1>     mov  esi,int34msg
  1281 00000AC2 E8AE010000          <1>     call irq_print_msg
  1282 00000AC7 5E                  <1>     pop  esi
  1283 00000AC8 E9D8010000          <1>     jmp  reboot_on_alt_key
  1284                              <1> 
  1285 00000ACD 90<rept>            <1> align 4
  1286                              <1> int_handler_hw03 :
  1287 00000AD0 56                  <1>     push esi
  1288 00000AD1 BE[93060000]        <1>     mov  esi,int35msg
  1289 00000AD6 E89A010000          <1>     call irq_print_msg
  1290 00000ADB 5E                  <1>     pop  esi
  1291 00000ADC E9C4010000          <1>     jmp  reboot_on_alt_key
  1292                              <1> 
  1293 00000AE1 90<rept>            <1> align 4
  1294                              <1> int_handler_hw04 :
  1295 00000AE4 56                  <1>     push esi
  1296 00000AE5 BE[9D060000]        <1>     mov  esi,int36msg
  1297 00000AEA E886010000          <1>     call irq_print_msg
  1298 00000AEF 5E                  <1>     pop  esi
  1299 00000AF0 E9B0010000          <1>     jmp  reboot_on_alt_key
  1300                              <1> 
  1301 00000AF5 90<rept>            <1> align 4
  1302                              <1> int_handler_hw05 :
  1303 00000AF8 56                  <1>     push esi
  1304 00000AF9 BE[A7060000]        <1>     mov  esi,int37msg
  1305 00000AFE E872010000          <1>     call irq_print_msg
  1306 00000B03 5E                  <1>     pop  esi
  1307 00000B04 E99C010000          <1>     jmp  reboot_on_alt_key
  1308                              <1> 
  1309 00000B09 90<rept>            <1> align 4
  1310                              <1> int_handler_hw06 :
  1311 00000B0C 56                  <1>     push esi
  1312 00000B0D BE[B1060000]        <1>     mov  esi,int38msg
  1313 00000B12 E85E010000          <1>     call irq_print_msg
  1314 00000B17 5E                  <1>     pop  esi
  1315 00000B18 E988010000          <1>     jmp  reboot_on_alt_key
  1316                              <1> 
  1317 00000B1D 90<rept>            <1> align 4
  1318                              <1> int_handler_hw07 :
  1319 00000B20 56                  <1>     push esi
  1320 00000B21 BE[BB060000]        <1>     mov  esi,int39msg
  1321 00000B26 E84A010000          <1>     call irq_print_msg
  1322 00000B2B 5E                  <1>     pop  esi
  1323 00000B2C E974010000          <1>     jmp  reboot_on_alt_key
  1324                              <1> 
  1325 00000B31 90<rept>            <1> align 4
  1326                              <1> int_handler_hw08 :
  1327 00000B34 56                  <1>     push esi
  1328 00000B35 BE[C5060000]        <1>     mov  esi,int40msg
  1329 00000B3A E836010000          <1>     call irq_print_msg
  1330 00000B3F 5E                  <1>     pop  esi
  1331 00000B40 E960010000          <1>     jmp  reboot_on_alt_key
  1332                              <1> 
  1333 00000B45 90<rept>            <1> align 4
  1334                              <1> int_handler_hw09 :
  1335 00000B48 56                  <1>     push esi
  1336 00000B49 BE[CF060000]        <1>     mov  esi,int41msg
  1337 00000B4E E822010000          <1>     call irq_print_msg
  1338 00000B53 5E                  <1>     pop  esi
  1339 00000B54 E94C010000          <1>     jmp  reboot_on_alt_key
  1340                              <1> 
  1341 00000B59 90<rept>            <1> align 4
  1342                              <1> int_handler_hw10 :
  1343 00000B5C 56                  <1>     push esi
  1344 00000B5D BE[D9060000]        <1>     mov  esi,int42msg
  1345 00000B62 E80E010000          <1>     call irq_print_msg
  1346 00000B67 5E                  <1>     pop  esi
  1347 00000B68 E938010000          <1>     jmp  reboot_on_alt_key
  1348                              <1> 
  1349 00000B6D 90<rept>            <1> align 4
  1350                              <1> int_handler_hw11 :
  1351 00000B70 56                  <1>     push esi
  1352 00000B71 BE[E3060000]        <1>     mov  esi,int43msg
  1353 00000B76 E8FA000000          <1>     call irq_print_msg
  1354 00000B7B 5E                  <1>     pop  esi
  1355 00000B7C E924010000          <1>     jmp  reboot_on_alt_key
  1356                              <1> 
  1357 00000B81 90<rept>            <1> align 4
  1358                              <1> int_handler_hw12 :
  1359 00000B84 56                  <1>     push esi
  1360 00000B85 BE[ED060000]        <1>     mov  esi,int44msg
  1361 00000B8A E8E6000000          <1>     call irq_print_msg
  1362 00000B8F 5E                  <1>     pop  esi
  1363 00000B90 E910010000          <1>     jmp  reboot_on_alt_key
  1364                              <1> 
  1365 00000B95 90<rept>            <1> align 4
  1366                              <1> int_handler_hw13 :
  1367 00000B98 56                  <1>     push esi
  1368 00000B99 BE[F7060000]        <1>     mov  esi,int45msg
  1369 00000B9E E8D2000000          <1>     call irq_print_msg
  1370 00000BA3 5E                  <1>     pop  esi
  1371 00000BA4 E9FC000000          <1>     jmp  reboot_on_alt_key
  1372                              <1> 
  1373 00000BA9 90<rept>            <1> align 4
  1374                              <1> int_handler_hw14 :
  1375 00000BAC 56                  <1>     push esi
  1376 00000BAD BE[01070000]        <1>     mov  esi,int46msg
  1377 00000BB2 E8BE000000          <1>     call irq_print_msg
  1378 00000BB7 5E                  <1>     pop  esi
  1379 00000BB8 E9E8000000          <1>     jmp  reboot_on_alt_key
  1380                              <1> 
  1381 00000BBD 90<rept>            <1> align 4
  1382                              <1> int_handler_hw15 :
  1383 00000BC0 56                  <1>     push esi
  1384 00000BC1 BE[0B070000]        <1>     mov  esi,int47msg
  1385 00000BC6 E8AA000000          <1>     call irq_print_msg
  1386 00000BCB 5E                  <1>     pop  esi
  1387 00000BCC E9D4000000          <1>     jmp  reboot_on_alt_key
  1388                              <1> 
  1389                              <1> ; called via the double fault task
  1390 00000BD1 90<rept>            <1> align 4
  1391                              <1> int_handler_tg_dblflt :
  1392 00000BD4 56                  <1>     push esi
  1393 00000BD5 BE[9B050000]        <1>     mov  esi,int08msg
  1394 00000BDA E896000000          <1>     call irq_print_msg
  1395 00000BDF 5E                  <1>     pop  esi
  1396 00000BE0 E9C0000000          <1>     jmp  reboot_on_alt_key
  1397                              <1> 
  1398                              <1> ; called via the invalid tss task
  1399 00000BE5 90<rept>            <1> align 4
  1400                              <1> int_handler_tg_invtss :
  1401 00000BE8 56                  <1>     push esi
  1402 00000BE9 BE[C6050000]        <1>     mov  esi,int10msg
  1403 00000BEE E882000000          <1>     call irq_print_msg
  1404 00000BF3 5E                  <1>     pop  esi
  1405                              <1>     ; FIXME need to go back to previous tss to get ec via that stack
  1406 00000BF4 83C302              <1>     add  ebx,2
  1407 00000BF7 58                  <1>     pop  eax                ; ec == invalid tss selector
  1408 00000BF8 E828F8FFFF          <1>     call putx_vga
  1409 00000BFD E9A3000000          <1>     jmp  reboot_on_alt_key
  1410                              <1> 
  1411 00000C02 90<rept>            <1> align 4
  1412                              <1> int_handler_spurious :
  1413 00000C04 56                  <1>     push esi
  1414 00000C05 BE[15070000]        <1>     mov  esi,spuriousmsg
  1415 00000C0A E866000000          <1>     call irq_print_msg
  1416 00000C0F 5E                  <1>     pop  esi
  1417 00000C10 CF                  <1>     iret
  1418                              <1> 
  1419 00000C11 90<rept>            <1> align 4
  1420                              <1> int_handler_apicerr :
  1421 00000C14 56                  <1>     push esi
  1422 00000C15 BE[23070000]        <1>     mov  esi,apicerrmsg
  1423 00000C1A E856000000          <1>     call irq_print_msg
  1424 00000C1F 5E                  <1>     pop  esi
  1425 00000C20 CF                  <1>     iret
  1426                              <1> 
  1427                              <1> ; serves only to eoi the fixed ipi used for sleep wakeup
  1428 00000C21 90<rept>            <1> align 4
  1429                              <1> wakeup :
  1430 00000C24 50                  <1>     push eax
  1431 00000C25 31C0                <1>     xor  eax,eax
  1432 00000C27 A3B000E0FE          <1>     mov  [0xfee000b0],eax    ; lapic eoi
  1433 00000C2C 58                  <1>     pop  eax
  1434 00000C2D CF                  <1>     iret
  1435                              <1> 
  1436                              <1> 
  1437 00000C2E 90<rept>            <1> align 4
  1438                              <1> ; %if ($ >= 0x8000) bomb
  1439                              <1> sysent :
  1440 00000C30 3D00020000          <1>     cmp  eax,0x0200
  1441 00000C35 0F84A9020000        <1>     jz   syscall_klog
  1442 00000C3B 3D00100000          <1>     cmp  eax,0x1000
  1443 00000C40 0F84AD020000        <1>     jz   syscall_ncpus
  1444 00000C46 3D00200000          <1>     cmp  eax,0x2000
  1445 00000C4B 0F8407030000        <1>     jz   syscall_sleep
  1446 00000C51 3D00210000          <1>     cmp  eax,0x2100
  1447 00000C56 0F849D020000        <1>     jz   syscall_new_thread
  1448 00000C5C 3D00270000          <1>     cmp  eax,0x2700
  1449 00000C61 0F8426030000        <1>     jz   syscall_request_pmem_access
  1450 00000C67 BE[34070000]        <1>     mov  esi,int255msg
  1451 00000C6C E804000000          <1>     call irq_print_msg
  1452 00000C71 31C0                <1>     xor  eax,eax
  1453 00000C73 48                  <1>     dec  eax
  1454 00000C74 CF                  <1>     iret
  1455                              <1> 
  1456                              <1> 
  1457                              <1> ; ---- IRQ support code ---- 
  1458                              <1> 
  1459                              <1> irq_print_msg :
  1460 00000C75 BBA0000000          <1>     mov  ebx,160            ; line 2
  1461 00000C7A A0[18030000]        <1>     mov  al,[enabled_lapic]
  1462 00000C7F 08C0                <1>     or   al,al
  1463 00000C81 741D                <1>     jz   skip_cpumsg
  1464                              <1> 
  1465 00000C83 56                  <1>     push esi
  1466 00000C84 BE[13050000]        <1>     mov  esi,cpumsg
  1467 00000C89 E870F7FFFF          <1>     call puts_vga
  1468 00000C8E A12000E0FE          <1>     mov  eax,[0xfee00020]   ; print our apic id
  1469 00000C93 C1E818              <1>     shr  eax,24
  1470 00000C96 83C030              <1>     add  eax,'0'
  1471 00000C99 658803              <1>     mov  [gs:ebx],al
  1472 00000C9C 83C304              <1>     add  ebx,4
  1473 00000C9F 5E                  <1>     pop  esi
  1474                              <1> 
  1475                              <1> skip_cpumsg :
  1476 00000CA0 E959F7FFFF          <1>     jmp  puts_vga
  1477                              <1> 
  1478                              <1> 
  1479                              <1> reboot_on_alt_key :
  1480 00000CA5 FA                  <1>     cli
  1481                              <1> reboot_on_alt_key_loop :
  1482 00000CA6 E460                <1>     in   al,0x60
  1483 00000CA8 3C38                <1>     cmp  al,'8'             ; part of the scan code for ALT
  1484 00000CAA 75FA                <1>     jnz  reboot_on_alt_key_loop
  1485                              <1> reboot :
  1486 00000CAC FA                  <1>     cli
  1487 00000CAD 0F011D[D90C0000]    <1>     lidt [reboot_idt]       ; restore boot idt (helps qemu ...)
  1488 00000CB4 EA[BB0C0000]2800    <1>     jmp  rmcssel:reboot_exit_pmode      ; thankyou hpa
  1489                              <1> reboot_exit_pmode :
  1490                              <1> bits 16
  1491 00000CBB B83000              <1>     mov  ax,rmdssel
  1492 00000CBE 8ED8                <1>     mov  ds,ax
  1493 00000CC0 8EC0                <1>     mov  es,ax
  1494 00000CC2 8ED0                <1>     mov  ss,ax
  1495 00000CC4 8EE0                <1>     mov  fs,ax
  1496 00000CC6 8EE8                <1>     mov  gs,ax
  1497                              <1> 
  1498 00000CC8 0F20C0              <1>     mov  eax,cr0
  1499 00000CCB 6625FEFFFF7F        <1>     and  eax,0x7ffffffe
  1500 00000CD1 0F22C0              <1>     mov  cr0,eax            ; disable pmode and paging
  1501 00000CD4 EA0000FFFF          <1>     jmp  0xffff:0           ; jump to the warm start vector and
  1502                              <1>                             ; flush the I prefetch queue all at once
  1503                              <1> 
  1504                              <1> reboot_idt :
  1505 00000CD9 FFFF                <1>     dw 0xffff
  1506 00000CDB 00000000            <1>     dd 0
  1507                              <1> 
  1508                              <1> 
  1509                              <1> ; ---- IDT initialization table ---- 
  1510                              <1> ;
  1511                              <1> ; One dw (2 bytes per vector) is used which means that all
  1512                              <1> ; int_handler entry points must reside below 0x10000!
  1513                              <1> ;
  1514                              <1> ; And since all int_handler routines are 4 byte aligned,
  1515                              <1> ; the bottom two bits are available to indicate type.
  1516                              <1> ; These bits index into the irq_types table below.
  1517                              <1> 
  1518 00000CDF 90                  <1> align 4
  1519                              <1> 
  1520                              <1> ; note: these are not gdt/ldt descriptors (see swdev3a 6.11 pg 228)
  1521                              <1> 
  1522 00000CE0 8E                  <1> irq_types   db  0x8e            ; dpl=0 32bit interrupt gate (sets IF flag)
  1523 00000CE1 EE                  <1>             db  0xee            ; dpl=3 32bit app (ring3) interrupt gate
  1524 00000CE2 85                  <1>             db  0x85            ; dpl=0 32bit task gate
  1525 00000CE3 8F                  <1>             db  0x8f            ; dpl=0 32bit trap gate (does not set IF flag)
  1526                              <1> 
  1527                              <1> ; all handlers/selectors are 4 byte aligned - this gives us
  1528                              <1> ; two bits to use to designate 1 of 4 types of idt descriptors ...
  1529                              <1> 
  1530                              <1> irqt_intr   equ 0
  1531                              <1> irqt_app    equ 1
  1532                              <1> irqt_task   equ 2
  1533                              <1> irqt_trap   equ 3
  1534                              <1> 
  1535                              <1> irq_setup_table:
  1536                              <1>     ; cpu defined
  1537 00000CE4 [1708]              <1>     dw  int_handler_div0      + irqt_trap ; 0
  1538 00000CE6 [2B08]              <1>     dw  int_handler_debug     + irqt_trap ; 1
  1539 00000CE8 [3C08]              <1>     dw  int_handler_nmi       + irqt_intr ; 2
  1540 00000CEA [5108]              <1>     dw  int_handler_brkp      + irqt_app  ; 3
  1541 00000CEC [6508]              <1>     dw  int_handler_ovrflw    + irqt_app  ; 4
  1542 00000CEE [7908]              <1>     dw  int_handler_bound     + irqt_app  ; 5
  1543 00000CF0 [8F08]              <1>     dw  int_handler_invop     + irqt_trap ; 6
  1544 00000CF2 [9F08]              <1>     dw  int_handler_devna     + irqt_trap ; 7
  1545 00000CF4 4200                <1>     dw  tasksel_f08           + irqt_task ; 8   double fault
  1546 00000CF6 [A308]              <1>     dw  int_handler_cpsego    + irqt_trap ; 9
  1547 00000CF8 4A00                <1>     dw  tasksel_f10           + irqt_task ; 10  invalid tss
  1548 00000CFA [B308]              <1>     dw  int_handler_segnp     + irqt_trap ; 11
  1549 00000CFC [C308]              <1>     dw  int_handler_stkflt    + irqt_trap ; 12
  1550 00000CFE [E708]              <1>     dw  int_handler_gpf       + irqt_trap ; 13
  1551 00000D00 [C809]              <1>     dw  int_handler_pgflt     + irqt_intr ; 14
  1552 00000D02 0000                <1>     dw  0                                 ; 15  Intel reserved
  1553 00000D04 [F309]              <1>     dw  int_handler_fpuerr    + irqt_trap ; 16
  1554 00000D06 [030A]              <1>     dw  int_handler_algnchk   + irqt_trap ; 17
  1555 00000D08 [170A]              <1>     dw  int_handler_machchk   + irqt_trap ; 18
  1556 00000D0A [2B0A]              <1>     dw  int_handler_simdfpe   + irqt_trap ; 19
  1557 00000D0C 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0
  1558 00000D15 000000000000000000- <1>
  1559 00000D1E 000000000000        <1>
  1560                              <1>     ; hw defined
  1561                              <1> apic0_irqbase equ ($ - irq_setup_table)/2
  1562 00000D24 [3C0A]              <1>     dw  int_handler_timer     + irqt_intr ; 32  0x20
  1563 00000D26 [880A]              <1>     dw  int_handler_kbd       + irqt_intr ; 33
  1564 00000D28 [BC0A]              <1>     dw  int_handler_hw02      + irqt_intr ; 34
  1565 00000D2A [D00A]              <1>     dw  int_handler_hw03      + irqt_intr ; 35
  1566 00000D2C [E40A]              <1>     dw  int_handler_hw04      + irqt_intr ; 36
  1567 00000D2E [F80A]              <1>     dw  int_handler_hw05      + irqt_intr ; 37
  1568 00000D30 [0C0B]              <1>     dw  int_handler_hw06      + irqt_intr ; 38
  1569 00000D32 [200B]              <1>     dw  int_handler_hw07      + irqt_intr ; 39
  1570                              <1> apic1_irqbase equ ($ - irq_setup_table)/2
  1571 00000D34 [340B]              <1>     dw  int_handler_hw08      + irqt_intr ; 40
  1572 00000D36 [480B]              <1>     dw  int_handler_hw09      + irqt_intr ; 41
  1573 00000D38 [5C0B]              <1>     dw  int_handler_hw10      + irqt_intr ; 42
  1574 00000D3A [700B]              <1>     dw  int_handler_hw11      + irqt_intr ; 43
  1575 00000D3C [840B]              <1>     dw  int_handler_hw12      + irqt_intr ; 44
  1576 00000D3E [980B]              <1>     dw  int_handler_hw13      + irqt_intr ; 45
  1577 00000D40 [AC0B]              <1>     dw  int_handler_hw14      + irqt_intr ; 46
  1578 00000D42 [C00B]              <1>     dw  int_handler_hw15      + irqt_intr ; 47  0x2f
  1579                              <1>     ; undefined - hw can expand here
  1580 00000D44 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x30
  1581 00000D4D 000000000000000000- <1>
  1582 00000D56 000000000000000000- <1>
  1583 00000D5F 0000000000          <1>
  1584 00000D64 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x40
  1585 00000D6D 000000000000000000- <1>
  1586 00000D76 000000000000000000- <1>
  1587 00000D7F 0000000000          <1>
  1588 00000D84 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x50
  1589 00000D8D 000000000000000000- <1>
  1590 00000D96 000000000000000000- <1>
  1591 00000D9F 0000000000          <1>
  1592 00000DA4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x60
  1593 00000DAD 000000000000000000- <1>
  1594 00000DB6 000000000000000000- <1>
  1595 00000DBF 0000000000          <1>
  1596 00000DC4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x70
  1597 00000DCD 000000000000000000- <1>
  1598 00000DD6 000000000000000000- <1>
  1599 00000DDF 0000000000          <1>
  1600 00000DE4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x80
  1601 00000DED 000000000000000000- <1>
  1602 00000DF6 000000000000000000- <1>
  1603 00000DFF 0000000000          <1>
  1604 00000E04 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x90
  1605 00000E0D 000000000000000000- <1>
  1606 00000E16 000000000000000000- <1>
  1607 00000E1F 0000000000          <1>
  1608 00000E24 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xa0
  1609 00000E2D 000000000000000000- <1>
  1610 00000E36 000000000000000000- <1>
  1611 00000E3F 0000000000          <1>
  1612                              <1>     ; set up cpu thread management tss gates
  1613                              <1>     ; these map 1-to-1 to cpus
  1614                              <1> first_thread_tss_gate equ ($ - irq_setup_table)/2
  1615 00000E44 5A00                <1>     dw  tasksel_u00           + irqt_task
  1616 00000E46 6A00                <1>     dw  tasksel_u01           + irqt_task
  1617 00000E48 7A00                <1>     dw  tasksel_u02           + irqt_task
  1618 00000E4A 8A00                <1>     dw  tasksel_u03           + irqt_task
  1619 00000E4C 9A00                <1>     dw  tasksel_u04           + irqt_task
  1620 00000E4E AA00                <1>     dw  tasksel_u05           + irqt_task
  1621 00000E50 BA00                <1>     dw  tasksel_u06           + irqt_task
  1622 00000E52 CA00                <1>     dw  tasksel_u07           + irqt_task
  1623                              <1> %ifdef FOO
  1624                              <1>     dw  tasksel_u08           + irqt_task
  1625                              <1>     dw  tasksel_u09           + irqt_task
  1626                              <1>     dw  tasksel_u10           + irqt_task
  1627                              <1>     dw  tasksel_u11           + irqt_task
  1628                              <1>     dw  tasksel_u12           + irqt_task
  1629                              <1>     dw  tasksel_u13           + irqt_task
  1630                              <1>     dw  tasksel_u14           + irqt_task
  1631                              <1>     dw  tasksel_u15           + irqt_task
  1632                              <1> %endif
  1633 00000E54 000000000000000000- <1>     dw                  0,0,0,0,0,0,0,0   ; 0xb0
  1634 00000E5D 00000000000000      <1>
  1635 00000E64 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xc0
  1636 00000E6D 000000000000000000- <1>
  1637 00000E76 000000000000000000- <1>
  1638 00000E7F 0000000000          <1>
  1639 00000E84 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xd0
  1640 00000E8D 000000000000000000- <1>
  1641 00000E96 000000000000000000- <1>
  1642 00000E9F 0000000000          <1>
  1643 00000EA4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xe0
  1644 00000EAD 000000000000000000- <1>
  1645 00000EB6 000000000000000000- <1>
  1646 00000EBF 0000000000          <1>
  1647                              <1> spurious_int equ ($ - irq_setup_table)/2
  1648 00000EC4 [040C]              <1>     dw  int_handler_spurious  + irqt_intr
  1649                              <1> apicerr_int equ ($ - irq_setup_table)/2
  1650 00000EC6 [150C]              <1>     dw  int_handler_apicerr   + irqt_app
  1651 00000EC8 000000000000000000- <1>     dw      0,0,0,0,0,0,0,0,0,0,0,0       ; 0xf0
  1652 00000ED1 000000000000000000- <1>
  1653 00000EDA 000000000000        <1>
  1654                              <1>     ; sw defined - expand down if needed
  1655                              <1> wakeup_int equ ($ - irq_setup_table)/2
  1656 00000EE0 [250C]              <1>     dw  wakeup                + irqt_app
  1657 00000EE2 [310C]              <1>     dw  sysent                + irqt_app  ; 256  0xff
  1658                              <1> irq_setup_table_size equ ($ - irq_setup_table)/2
  1659                              <1> 
  1660                                  
  1661                                  ; -------- system calls --------
  1662                                  %include "ozsys.asm"
  1663                              <1> ; OZ - A more utopian OS    x86-32 system calls
  1664                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
  1665                              <1> ;
  1666                              <1> ; Copyright (C) 2015  Duane Voth
  1667                              <1> ;
  1668                              <1> ;   This program is free software: you can redistribute it and/or modify
  1669                              <1> ;   it under the terms of the GNU Affero General Public License as
  1670                              <1> ;   published by the Free Software Foundation, either version 3 of the
  1671                              <1> ;   License, or (at your option) any later version.
  1672                              <1> ;
  1673                              <1> ;   This program is distributed in the hope that it will be useful,
  1674                              <1> ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
  1675                              <1> ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1676                              <1> ;   GNU Affero General Public License for more details.
  1677                              <1> ;
  1678                              <1> ;   You should have received a copy of the GNU Affero General Public License
  1679                              <1> ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
  1680                              <1> ;
  1681                              <1> ;
  1682                              <1> ; OZ System Calls  (for ozapps)
  1683                              <1> 
  1684                              <1> bits 32
  1685                              <1> 
  1686                              <1> ;------------------------------------------------------------------
  1687                              <1> ;   syscall_klog : place a message on the vga line reserved for klog  :D
  1688                              <1> ;
  1689                              <1> ;   entry:
  1690                              <1> ;       esi = message address
  1691                              <1> ;   exit:
  1692                              <1> 
  1693                              <1> syscall_klog :
  1694 00000EE4 60                  <1>     pusha
  1695 00000EE5 BB40010000          <1>     mov  ebx,2 * 160        ; line 3
  1696 00000EEA E80FF5FFFF          <1>     call puts_vga
  1697 00000EEF 61                  <1>     popa
  1698 00000EF0 31C0                <1>     xor  eax,eax
  1699 00000EF2 CF                  <1>     iret
  1700                              <1> 
  1701                              <1> ;------------------------------------------------------------------
  1702                              <1> ;   syscall_ncpus : get how many cpu threads are running
  1703                              <1> ;
  1704                              <1> ;   entry:
  1705                              <1> ;   exit:
  1706                              <1> ;       eax = N cpus
  1707                              <1> 
  1708                              <1> syscall_ncpus :
  1709 00000EF3 A1[14030000]        <1>     mov  eax,[ncpus]
  1710 00000EF8 CF                  <1>     iret
  1711                              <1> 
  1712                              <1> ;------------------------------------------------------------------
  1713                              <1> ;   syscall_new_thread : ask for another cpu to execute code in
  1714                              <1> ;                        the current app
  1715                              <1> ;
  1716                              <1> ;   This implementation is quite a bit of a hack - apps can basically
  1717                              <1> ;   commendere any specific non-boot cpu they want ...
  1718                              <1> ;
  1719                              <1> ;   entry:
  1720                              <1> ;       edx = function start address in the app
  1721                              <1> ;       ecx = address of the top of the app's new thread stack
  1722                              <1> ;       ebx = app's new thread index
  1723                              <1> ;   exit:
  1724                              <1> ;       eax = 0 success, -1 failure
  1725                              <1> 
  1726                              <1> syscall_new_thread :
  1727 00000EF9 09DB                <1>     or   ebx,ebx
  1728 00000EFB 7459                <1>     jz   new_thread_fail        ; don't get to ask for cpu 0
  1729                              <1> 
  1730 00000EFD 31C0                <1>     xor  eax,eax
  1731 00000EFF A0[18030000]        <1>     mov  al,[enabled_lapic]     ; if the lapics are not enabled,
  1732 00000F04 08C0                <1>     or   al,al                  ; none of this is useful
  1733 00000F06 744E                <1>     jz   new_thread_fail
  1734                              <1> 
  1735                              <1>     ; setup the tss
  1736                              <1>     ; slightly squirly - get the tss address from the task selector
  1737                              <1>     ; but there could be a race here: ncpus is updated before
  1738                              <1>     ; create_tss_pair is called, so the task selector could be zero!
  1739                              <1> 
  1740 00000F08 89DF                <1>     mov  edi,ebx
  1741 00000F0A C1E704              <1>     shl  edi,4                  ; 8 byte selectors in pairs
  1742 00000F0D 83C758              <1>     add  edi,tasksel_u00
  1743 00000F10 8BB7[02000000]      <1>     mov  esi,[gdt+edi+2]
  1744 00000F16 81E6FFFFFF00        <1>     and  esi,0xffffff
  1745 00000F1C 31C0                <1>     xor  eax,eax
  1746 00000F1E 8A87[07000000]      <1>     mov  al,[gdt+edi+7]
  1747 00000F24 C1E018              <1>     shl  eax,24
  1748 00000F27 09C6                <1>     or   esi,eax
  1749 00000F29 742B                <1>     jz   new_thread_fail        ; cpu isn't yet ready ...
  1750                              <1> 
  1751                              <1>     ; really should check the previous task link to see if this
  1752                              <1>     ; cpu is busy ...
  1753                              <1> 
  1754 00000F2B 894E38              <1>     mov  [esi+(tss0_esp-tss0)],ecx  ; set the app's stack
  1755 00000F2E 895620              <1>     mov  [esi+(tss0_eip-tss0)],edx  ; set the ip to the entry point
  1756                              <1> 
  1757                              <1>     ; lookup the requested cpu's int/taskgate gdt selector
  1758                              <1> 
  1759 00000F31 89DF                <1>     mov  edi,ebx
  1760 00000F33 81C7B0000000        <1>     add  edi,first_thread_tss_gate  ; convert ebx to int/taskgate number
  1761                              <1> 
  1762                              <1>     ; ipi a cpu.  no fancy affinity scheduling yet,
  1763                              <1>     ; just let the app ask for a specific cpu to do the work
  1764                              <1> 
  1765 00000F39 B800000001          <1>     mov  eax,0x01000000
  1766 00000F3E 89D9                <1>     mov  ecx,ebx                    ; recover requested cpu number
  1767 00000F40 D3E0                <1>     shl  eax,cl                     ; form the icr destination field
  1768                              <1> 
  1769                              <1>     ; poke the cpu that matches our thread index - we only get 8 :/
  1770                              <1> 
  1771 00000F42 A31003E0FE          <1>     mov  dword [0xfee00310],eax
  1772 00000F47 B800480000          <1>     mov  eax,0x4800                 ; no shorthand, fixed, logical, edge
  1773 00000F4C 09F8                <1>     or   eax,edi                    ; make int/taskgate number the vector
  1774 00000F4E A30003E0FE          <1>     mov  dword [0xfee00300],eax
  1775                              <1> 
  1776 00000F53 31C0                <1>     xor  eax,eax
  1777 00000F55 CF                  <1>     iret
  1778                              <1> 
  1779                              <1> new_thread_fail :
  1780 00000F56 48                  <1>     dec  eax                    ; -1
  1781 00000F57 C3                  <1>     ret
  1782                              <1> 
  1783                              <1> ;------------------------------------------------------------------
  1784                              <1> ;   syscall_sleep : wait for N timer interrupts
  1785                              <1> ;
  1786                              <1> ;   entry:
  1787                              <1> ;       edx = N ticks
  1788                              <1> ;   exit:
  1789                              <1> 
  1790                              <1> syscall_sleep :
  1791 00000F58 A0[18030000]        <1>     mov  al,[enabled_lapic]
  1792 00000F5D 08C0                <1>     or   al,al
  1793 00000F5F 7415                <1>     jz   sleep_loop
  1794                              <1> 
  1795 00000F61 A12000E0FE          <1>     mov  eax,[0xfee00020]
  1796 00000F66 C1E818              <1>     shr  eax,24
  1797 00000F69 09C0                <1>     or   eax,eax
  1798 00000F6B 7409                <1>     jz   sleep_loop         ; the boot cpu services the timer int
  1799 00000F6D 88C1                <1>     mov  cl,al              ; so don't add it to the sleeper list
  1800 00000F6F B801000000          <1>     mov  eax,1
  1801 00000F74 D3E0                <1>     shl  eax,cl
  1802                              <1> 
  1803                              <1> sleep_loop :
  1804 00000F76 F00905[1D030000]    <1>     lock or [sleepers],eax  ; announce we are sleeping
  1805 00000F7D FB                  <1>     sti
  1806 00000F7E F4                  <1>     hlt                     ; wait for an int to wake us up
  1807 00000F7F 4A                  <1>     dec  edx                ; decrement the tick count
  1808 00000F80 75F4                <1>     jnz  sleep_loop
  1809                              <1> 
  1810 00000F82 83F0FF              <1>     xor  eax,-1
  1811 00000F85 F02105[1D030000]    <1>     lock and [sleepers],eax ; renounce sleepiness
  1812 00000F8C CF                  <1>     iret
  1813                              <1> 
  1814                              <1> ;------------------------------------------------------------------
  1815                              <1> ;   syscall_request_pmem_access : ask for access to a physical
  1816                              <1> ;            memory address
  1817                              <1> ;
  1818                              <1> ;   entry:
  1819                              <1> ;       edx = phys memory address
  1820                              <1> ;
  1821                              <1> ;   exit:
  1822                              <1> ;       (need to return a logical address in eax)  For now just
  1823                              <1> ;       direct maps the physical address into logical addr space.
  1824                              <1> 
  1825                              <1> syscall_request_pmem_access :
  1826 00000F8D E801000000          <1>     call map_pmem
  1827 00000F92 CF                  <1>     iret
  1828                              <1> 
  1829                              <1> ;------------------------------------------------------------------
  1830                              <1> ;   map_pmem - add entries to the current page directory/table
  1831                              <1> ;              to direct map the requested physical memory address
  1832                              <1> ;
  1833                              <1> ;   entry:
  1834                              <1> ;       edx = phys memory address
  1835                              <1> ;
  1836                              <1> ;   returns:
  1837                              <1> ;       (need to return a logical address in eax)  For now just
  1838                              <1> ;       direct maps the physical address into logical addr space.
  1839                              <1> ;       eax =  0 success
  1840                              <1> ;       eax = -1 fail
  1841                              <1> 
  1842                              <1> map_pmem :
  1843 00000F93 60                  <1>     pusha
  1844 00000F94 52                  <1>     push edx
  1845 00000F95 0F20DB              <1>     mov  ebx,cr3
  1846 00000F98 81E300F0FFFF        <1>     and  ebx,0xfffff000
  1847 00000F9E 89D7                <1>     mov  edi,edx
  1848 00000FA0 81E70000C0FF        <1>     and  edi,0xffc00000
  1849 00000FA6 C1EF14              <1>     shr  edi,(22 - 2)           ; calc page directory index
  1850 00000FA9 81E200F03F00        <1>     and  edx,0x003ff000
  1851 00000FAF C1EA0A              <1>     shr  edx,(12 - 2)           ; calc page table index
  1852                              <1> 
  1853 00000FB2 8B043B              <1>     mov  eax,[ebx+edi]
  1854 00000FB5 09C0                <1>     or   eax,eax                ; is there a page table here?
  1855 00000FB7 750F                <1>     jnz  map_pmem_have_pgtbl
  1856 00000FB9 E892F4FFFF          <1>     call mem_alloc_kernel_page
  1857 00000FBE 09C0                <1>     or   eax,eax
  1858 00000FC0 741E                <1>     jz   map_pmem_fail
  1859 00000FC2 C1E00C              <1>     shl  eax,12                 ; convert pgno to pgtbl entry
  1860 00000FC5 89043B              <1>     mov  [ebx+edi],eax          ; update page table
  1861                              <1> 
  1862                              <1> map_pmem_have_pgtbl :
  1863                              <1>     ; for now, no security check, just direct map the address
  1864                              <1>     ; and mark the pages and the page table r/w by all
  1865 00000FC8 830C3B07            <1>     or   dword [ebx+edi],7      ; user, r/w, present
  1866                              <1> 
  1867 00000FCC 8B1C3B              <1>     mov  ebx,[ebx+edi]
  1868 00000FCF 81E300F0FFFF        <1>     and  ebx,0xfffff000
  1869 00000FD5 58                  <1>     pop  eax                    ; recover requested phys mem addr
  1870                              <1>     ; FIXME yup, big security hole if called by ring 0! And it is ...
  1871 00000FD6 83C807              <1>     or   eax,7                  ; user, r/w, present
  1872 00000FD9 890413              <1>     mov  [ebx+edx],eax          ; update page directory
  1873 00000FDC 61                  <1>     popa
  1874 00000FDD 31C0                <1>     xor  eax,eax                ; 0
  1875 00000FDF C3                  <1>     ret
  1876                              <1> 
  1877                              <1> map_pmem_fail :
  1878 00000FE0 48                  <1>     dec  eax                    ; -1
  1879 00000FE1 C3                  <1>     ret
  1880                              <1> 
  1881                                  
  1882 00000FE2 00<rept>                align 16, db 0
  1883                                  kernel_text_size equ ($-textstart)
  1884                                  
  1885                                  ; ---------------------------------------------------------------------------
  1886                                  section .data
  1887                                  datastart :
  1888                                  
  1889                                  ; -------- descriptors --------------
  1890                                  ; Intel SW dev manual 3a, 3.4.5, pg 103
  1891                                  ;
  1892                                  ; In my opinion, macros for descriptor entries
  1893                                  ; don't make the code that much more readable.
  1894                                  
  1895                                  gdt :
  1896                                  nullsel equ $-gdt           ; nullsel = 0h
  1897 00000000 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
  1898                                  
  1899                                  codesel equ $-gdt           ; codesel = 8h  4Gb flat over all logical mem
  1900 00000008 FFFF                        dw 0xffff               ; limit 0-15
  1901 0000000A 0000                        dw 0x0000               ; base  0-15
  1902 0000000C 00                          db 0x00                 ; base 16-23
  1903 0000000D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  1904 0000000E CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  1905 0000000F 00                          db 0x00                 ; base 24-31
  1906                                  
  1907                                  datasel equ $-gdt           ; datasel = 10h  4Gb flat over all logical mem
  1908 00000010 FFFF                        dw 0xffff               ; limit 0-15
  1909 00000012 0000                        dw 0x0000               ; base  0-15
  1910 00000014 00                          db 0x00                 ; base 16-23
  1911 00000015 92                          db 0x92                 ; present, dpl=0, data r/w
  1912 00000016 CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  1913 00000017 00                          db 0x00                 ; base 24-31
  1914                                  
  1915                                  stacksel equ $-gdt          ; stacksel = 18h  small limited stack
  1916 00000018 FF1F                        dw kstack_size-1        ; limit
  1917 0000001A 0010                        dw kstack_loc           ; base
  1918 0000001C 00                          db 0
  1919 0000001D 92                          db 0x92                 ; present, dpl=0, data, r/w
  1920 0000001E 40                          db 0x40                 ; byte granular, 32bit/8bit
  1921 0000001F 00                          db 0
  1922                                  
  1923                                  videosel equ $-gdt          ; videosel = 20h
  1924 00000020 9F0F                        dw 3999                 ; limit 80*25*2-1
  1925 00000022 0080                        dw 0x8000               ; base 0xb8000
  1926 00000024 0B                          db 0x0b
  1927 00000025 92                          db 0x92                 ; present, dpl=0, data, r/w
  1928 00000026 40                          db 0x40                 ; byte granular, 32bit/8bit
  1929 00000027 00                          db 0
  1930                                  
  1931                                  rmcssel equ $-gdt           ; real mode CS selector = 28h
  1932 00000028 FFFF                        dw 0x0ffff              ; limit 0-15
  1933 0000002A 0000                        dw 0x0000               ; base  0-15
  1934 0000002C 00                          db 0x00                 ; base 16-23
  1935 0000002D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  1936 0000002E 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  1937 0000002F 00                          db 0x00                 ; base 24-31
  1938                                  
  1939                                  rmdssel equ $-gdt           ; real mode DS selector = 30h
  1940 00000030 FFFF                        dw 0x0ffff              ; limit 0-15
  1941 00000032 0000                        dw 0x0000               ; base  0-15
  1942 00000034 00                          db 0x00                 ; base 16-23
  1943 00000035 92                          db 0x92                 ; present, dpl=0, data r/w
  1944 00000036 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  1945 00000037 00                          db 0x00                 ; base 24-31
  1946                                  
  1947                                  ldtsel1 equ $-gdt
  1948 00000038 1800                        dw ldt1_len             ; length of the ldt
  1949 0000003A [5001]                      dw ldt1                 ; address of the ldt
  1950 0000003C 00                          db 0
  1951 0000003D 82                          db 0x82                 ; present, dpl=0, ldt
  1952 0000003E 40                          db 0x40                 ; byte granular, 32bit/8bit
  1953 0000003F 00                          db 0
  1954                                  
  1955                                  tasksel_f08 equ $-gdt       ; the double fault task selector
  1956 00000040 6800                        dw tss_len              ; tss length
  1957 00000042 [6801]                      dw tss_f08              ; tss physical address
  1958 00000044 00                          db 0
  1959 00000045 89                          db 0x89                 ; present, dpl=0, tss32
  1960 00000046 40                          db 0x40                 ; byte granular, 32bit/8bit
  1961 00000047 00                          db 0
  1962                                  
  1963                                  tasksel_f10 equ $-gdt       ; the invalid tss task selector
  1964 00000048 6800                        dw tss_len              ; tss length
  1965 0000004A [D001]                      dw tss_f10              ; tss physical address
  1966 0000004C 00                          db 0
  1967 0000004D 89                          db 0x89                 ; present, dpl=0, tss32
  1968 0000004E 40                          db 0x40                 ; byte granular, 32bit/8bit
  1969 0000004F 00                          db 0
  1970                                  
  1971                                  ; there is one kernel thread tss (ring 0) and one user thread tss (ring 1)
  1972                                  ; per cpu.  memory for tss structs for the non-boot cpus are allocated as
  1973                                  ; each non-boot cpu comes online (see create_tss_pair).  tasksel_uXX tss
  1974                                  ; gates are installed in the idt (starting at first_thread_tss_gate),
  1975                                  ; they also map 1-to-1 with cpus.  (the thread is launched via an lapic
  1976                                  ; vectored interrupt that jumps immediately into user space - and to call a
  1977                                  ; task gate from an interrupt requires an existing ring 0 tss to be active)
  1978                                  ; tasksel_uXX tsses are initialized in new_thread.
  1979                                  
  1980                                  tasksel_k00 equ $-gdt
  1981 00000050 6800[3802]00894000                              dw tss_len, tss0, 0x8900, 0x40
  1982                                  tasksel_u00 equ $-gdt
  1983 00000058 6800[A002]00894000                              dw tss_len, tss1, 0x8900, 0x40
  1984                                  tasksel_k01 equ $-gdt
  1985 00000060 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1986                                  tasksel_u01 equ $-gdt
  1987 00000068 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1988                                  tasksel_k02 equ $-gdt
  1989 00000070 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1990                                  tasksel_u02 equ $-gdt
  1991 00000078 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1992                                  tasksel_k03 equ $-gdt
  1993 00000080 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1994                                  tasksel_u03 equ $-gdt
  1995 00000088 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1996                                  tasksel_k04 equ $-gdt
  1997 00000090 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1998                                  tasksel_u04 equ $-gdt
  1999 00000098 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2000                                  tasksel_k05 equ $-gdt
  2001 000000A0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2002                                  tasksel_u05 equ $-gdt
  2003 000000A8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2004                                  tasksel_k06 equ $-gdt
  2005 000000B0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2006                                  tasksel_u06 equ $-gdt
  2007 000000B8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2008                                  tasksel_k07 equ $-gdt
  2009 000000C0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2010                                  tasksel_u07 equ $-gdt
  2011 000000C8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2012                                  tasksel_k08 equ $-gdt
  2013 000000D0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2014                                  tasksel_u08 equ $-gdt
  2015 000000D8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2016                                  tasksel_k09 equ $-gdt
  2017 000000E0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2018                                  tasksel_u09 equ $-gdt
  2019 000000E8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2020                                  tasksel_k10 equ $-gdt
  2021 000000F0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2022                                  tasksel_u10 equ $-gdt
  2023 000000F8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2024                                  tasksel_k11 equ $-gdt
  2025 00000100 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2026                                  tasksel_u11 equ $-gdt
  2027 00000108 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2028                                  tasksel_k12 equ $-gdt
  2029 00000110 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2030                                  tasksel_u12 equ $-gdt
  2031 00000118 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2032                                  tasksel_k13 equ $-gdt
  2033 00000120 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2034                                  tasksel_u13 equ $-gdt
  2035 00000128 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2036                                  tasksel_k14 equ $-gdt
  2037 00000130 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2038                                  tasksel_u14 equ $-gdt
  2039 00000138 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2040                                  tasksel_k15 equ $-gdt
  2041 00000140 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2042                                  tasksel_u15 equ $-gdt
  2043 00000148 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2044                                  gdt_end :
  2045                                  
  2046                                  ; ---------------------
  2047                                  
  2048                                  ldt1 :
  2049                                  nullsel1 equ $-ldt1         ; nullsel1 = 07h
  2050 00000150 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
  2051                                  
  2052                                  codesel1 equ $-ldt1         ; codesel1 = 0fh  4Gb flat over all logical mem
  2053 00000158 FFFF                        dw 0xffff               ; limit 0-15
  2054 0000015A 0000                        dw 0x0000               ; base  0-15
  2055 0000015C 00                          db 0x00                 ; base 16-23
  2056 0000015D FA                          db 0xfa                 ; present, dpl=3, code e/r
  2057 0000015E CF                          db 0xcf                 ; 4k granular, 32bit, limit 16-19
  2058 0000015F 00                          db 0x00                 ; base 24-31
  2059                                  
  2060                                  datasel1 equ $-ldt1         ; datasel1 = 17h  4Gb flat over all logical mem
  2061 00000160 FFFF                        dw 0xffff               ; limit 0-15
  2062 00000162 0000                        dw 0x0000               ; base  0-15
  2063 00000164 00                          db 0x00                 ; base 16-23
  2064 00000165 F2                          db 0xf2                 ; present, dpl=3, data r/w
  2065 00000166 CF                          db 0xcf                 ; 4k granular, 32bit, limit 16-19
  2066 00000167 00                          db 0x00                 ; base 24-31
  2067                                  
  2068                                  ; gcc wants the ds, es, and ss segment registers to match
  2069                                  ;stacksel1 equ $-ldt1        ; stacksel = 1ch  small limited stack
  2070                                  ;    dw 0xffff               ; limit
  2071                                  ;    dw 0x0000               ; base  0-15
  2072                                  ;    db 0x00
  2073                                  ;    db 0xf2                 ; present, dpl=3, data, r/w
  2074                                  ;    db 0                    ; byte granular, 16 bit
  2075                                  ;    db 0
  2076                                  
  2077                                  ldt1_end :
  2078                                  
  2079                                  ldt1_len equ ldt1_end-ldt1
  2080                                  
  2081                                  ; ---------------------
  2082                                  ; the tss that handles double fault exceptions
  2083                                  
  2084                                  tss_f08 :                   ; intel sw 3a 7.6  pg 287 of 756
  2085 00000168 00000000                    dw 0,0                  ; previous task link
  2086 0000016C 00000000                    dd 0                    ; esp0
  2087 00000170 00000000                    dw 0,0                  ; ss0
  2088 00000174 00000000                    dd 0                    ; esp1
  2089 00000178 00000000                    dw 0,0                  ; ss1
  2090 0000017C 00000000                    dd 0                    ; esp2
  2091 00000180 00000000                    dw 0,0                  ; ss2
  2092 00000184 00300000                    dd pgdir                ; cr3
  2093 00000188 [D40B0000]                  dd int_handler_tg_dblflt ; eip
  2094 0000018C 00000000                    dd 0                    ; eflags
  2095 00000190 00000000                    dd 0                    ; eax
  2096 00000194 00000000                    dd 0                    ; ecx
  2097 00000198 00000000                    dd 0                    ; edx
  2098 0000019C 00000000                    dd 0                    ; ebx
  2099 000001A0 00080000                    dd kstack_size/4        ; esp
  2100 000001A4 00000000                    dd 0                    ; ebp
  2101 000001A8 00000000                    dd 0                    ; esi
  2102 000001AC 00000000                    dd 0                    ; edi
  2103 000001B0 10000000                    dw datasel,0            ; es
  2104 000001B4 08000000                    dw codesel,0            ; cs
  2105 000001B8 10000000                    dw datasel,0            ; ss
  2106 000001BC 10000000                    dw datasel,0            ; ds
  2107 000001C0 00000000                    dw 0,0                  ; fs
  2108 000001C4 20000000                    dw videosel,0           ; gs
  2109 000001C8 00000000                    dw 0,0                  ; ldt
  2110 000001CC 0000                        dw 0                    ; trap
  2111 000001CE 0000                        dw 0                    ; iomap
  2112                                  
  2113                                  ; ---------------------
  2114                                  ; the tss that handles invalid tss exceptions
  2115                                  
  2116                                  tss_f10 :                   ; intel sw 3a 7.6  pg 287 of 756
  2117 000001D0 00000000                    dw 0,0                  ; previous task link
  2118 000001D4 00000000                    dd 0                    ; esp0
  2119 000001D8 00000000                    dw 0,0                  ; ss0
  2120 000001DC 00000000                    dd 0                    ; esp1
  2121 000001E0 00000000                    dw 0,0                  ; ss1
  2122 000001E4 00000000                    dd 0                    ; esp2
  2123 000001E8 00000000                    dw 0,0                  ; ss2
  2124 000001EC 00300000                    dd pgdir                ; cr3
  2125 000001F0 [E80B0000]                  dd int_handler_tg_invtss ; eip
  2126 000001F4 00000000                    dd 0                    ; eflags
  2127 000001F8 00000000                    dd 0                    ; eax
  2128 000001FC 00000000                    dd 0                    ; ecx
  2129 00000200 00000000                    dd 0                    ; edx
  2130 00000204 00000000                    dd 0                    ; ebx
  2131 00000208 00100000                    dd kstack_size/2        ; esp
  2132 0000020C 00000000                    dd 0                    ; ebp
  2133 00000210 00000000                    dd 0                    ; esi
  2134 00000214 00000000                    dd 0                    ; edi
  2135 00000218 10000000                    dw datasel,0            ; es
  2136 0000021C 08000000                    dw codesel,0            ; cs
  2137 00000220 10000000                    dw datasel,0            ; ss
  2138 00000224 10000000                    dw datasel,0            ; ds
  2139 00000228 00000000                    dw 0,0                  ; fs
  2140 0000022C 20000000                    dw videosel,0           ; gs
  2141 00000230 00000000                    dw 0,0                  ; ldt
  2142 00000234 0000                        dw 0                    ; trap
  2143 00000236 0000                        dw 0                    ; iomap
  2144                                  
  2145                                  ; ---------------------
  2146                                  ; tss0 and tss1 are cpu0's pair, these are also templates for other
  2147                                  ; cpus that come online.
  2148                                  
  2149                                  tss0 :                      ; intel swdev3a 7.6  pg 287 of 756
  2150 00000238 00000000                    dw 0,0                  ; previous task link
  2151                                  tss0_esp0 :
  2152 0000023C 00000000                    dd 0                    ; esp0
  2153                                  tss0_ss0 :
  2154 00000240 00000000                    dw 0,0                  ; ss0
  2155 00000244 00000000                    dd 0                    ; esp1
  2156 00000248 00000000                    dw 0,0                  ; ss1
  2157 0000024C 00000000                    dd 0                    ; esp2
  2158 00000250 00000000                    dw 0,0                  ; ss2
  2159                                  tss0_cr3 :
  2160 00000254 00300000                    dd pgdir                ; cr3
  2161                                  tss0_eip :
  2162 00000258 00000000                    dd 0                    ; eip
  2163 0000025C 00000000                    dd 0                    ; eflags
  2164                                  tss0_eax :
  2165 00000260 00000000                    dd 0                    ; eax
  2166 00000264 00000000                    dd 0                    ; ecx
  2167 00000268 00000000                    dd 0                    ; edx
  2168 0000026C 00000000                    dd 0                    ; ebx
  2169                                  tss0_esp :
  2170 00000270 00000000                    dd 0                    ; esp
  2171 00000274 00000000                    dd 0                    ; ebp
  2172 00000278 00000000                    dd 0                    ; esi
  2173 0000027C 00000000                    dd 0                    ; edi
  2174                                  tss0_es :
  2175 00000280 00000000                    dw 0,0                  ; es
  2176                                  tss0_cs :
  2177 00000284 00000000                    dw 0,0                  ; cs
  2178                                  tss0_ss :
  2179 00000288 00000000                    dw 0,0                  ; ss
  2180                                  tss0_ds :
  2181 0000028C 00000000                    dw 0,0                  ; ds
  2182 00000290 00000000                    dw 0,0                  ; fs
  2183 00000294 20000000                    dw videosel,0           ; gs
  2184                                  tss0_ldt :
  2185 00000298 00000000                    dw 0,0                  ; ldt
  2186 0000029C 0000                        dw 0                    ; trap
  2187 0000029E 0000                        dw 0                    ; iomap
  2188                                  tss0_end :
  2189                                  
  2190                                  tss_len equ tss0_end-tss0
  2191                                  
  2192                                  ; user tss
  2193                                  
  2194                                  tss1 :                      ; intel sw 3a 7.6  pg 287 of 756
  2195 000002A0 00000000                    dw 0,0                  ; previous task link
  2196 000002A4 E01F0000                    dd kstack_size-32       ; esp0  (int and irq support)
  2197 000002A8 10000000                    dw datasel,0            ; ss0   (-32 leaves some stack space for main)
  2198 000002AC 00000000                    dd 0                    ; esp1
  2199 000002B0 00000000                    dw 0,0                  ; ss1
  2200 000002B4 00000000                    dd 0                    ; esp2
  2201 000002B8 00000000                    dw 0,0                  ; ss2
  2202 000002BC 00300000                    dd pgdir                ; cr3
  2203                                  tss1_eip :
  2204 000002C0 00000000                    dd 0                    ; eip
  2205 000002C4 00000000                    dd 0                    ; eflags
  2206 000002C8 00000000                    dd 0                    ; eax
  2207 000002CC 00000000                    dd 0                    ; ecx
  2208 000002D0 00000000                    dd 0                    ; edx
  2209 000002D4 00000000                    dd 0                    ; ebx
  2210 000002D8 00000000                    dd 0                    ; esp
  2211 000002DC 00000000                    dd 0                    ; ebp
  2212 000002E0 00000000                    dd 0                    ; esi
  2213 000002E4 00000000                    dd 0                    ; edi
  2214 000002E8 17000000                    dw datasel1+7,0         ; es
  2215 000002EC 0F000000                    dw codesel1+7,0         ; cs
  2216 000002F0 17000000                    dw datasel1+7,0         ; ss
  2217 000002F4 17000000                    dw datasel1+7,0         ; ds
  2218 000002F8 00000000                    dw 0,0                  ; fs
  2219 000002FC 00000000                    dw 0,0                  ; gs
  2220 00000300 3B000000                    dw ldtsel1+3,0          ; ldt
  2221 00000304 0000                        dw 0                    ; trap
  2222 00000306 0000                        dw 0                    ; iomap
  2223                                  
  2224                                  ; ---------------------
  2225                                  
  2226                                  gdtr :
  2227 00000308 4F01                        dw gdt_end - gdt - 1    ; gdt length
  2228 0000030A [00000000]                  dd gdt                  ; gdt physical address
  2229                                  
  2230                                  idtr :
  2231                                      ; irq_setup_table_size == the number of gates in the idt
  2232 0000030E FF07                        dw irq_setup_table_size * 8 - 1     ; idt limit (should be 2k)
  2233 00000310 00700000                    dd idt                              ; address of the idt
  2234                                  
  2235 00000314 00000000                ncpus           dd 0        ; number of running cpus
  2236                                  
  2237 00000318 00                      enabled_lapic   db 0        ; set to 1 if an lapic is present and in use
  2238                                  
  2239 00000319 00000000                next_free_page  dd 0        ; initialized after page tables are setup
  2240                                  
  2241 0000031D 0000000000000000        sleepers        dq 0        ; one bit per cpu
  2242                                  
  2243 00000325 00<rept>                align 16, db 0
  2244                                  kernel_data_size equ ($-datastart)
  2245                                  
  2246                                  
  2247                                  ; ---------------------
  2248                                  ; Need to align to a physical page boundary here so that appended init apps
  2249                                  ; are always page aligned.  The problem is our text section starts 1k below
  2250                                  ; a page boundary, and so an 'align 4096' doesn't match up with physical
  2251                                  ; memory.
  2252                                  
  2253                                  ; Add larger tests here if the times expression turns up negative, to make
  2254                                  ; the kernel image size right, but your next problem will be that the boot
  2255                                  ; loader will likely refuse to load all these sectors in one pass.
  2256                                  
  2257                                  section .fill
  2258                                  
  2259                                  fill :
  2260                                  
  2261                                  %if total_size > 4096+1024
  2262                                      times (4096+4096+1024-total_size) db 0
  2263                                  %elif total_size > 1024
  2264 00000000 00<rept>                    times (4096+1024-total_size) db 0
  2265                                  %endif
  2266                                  
  2267                                  kend :
  2268                                  
