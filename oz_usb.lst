     1                                  ; OZ - A more utopian OS   x86-32 startup
     2                                  ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
     3                                  ;
     4                                  ; Copyright (C) 2015  Duane Voth
     5                                  ;
     6                                  ;   This program is free software: you can redistribute it and/or modify
     7                                  ;   it under the terms of the GNU Affero General Public License as
     8                                  ;   published by the Free Software Foundation, either version 3 of the
     9                                  ;   License, or (at your option) any later version.
    10                                  ;
    11                                  ;   This program is distributed in the hope that it will be useful,
    12                                  ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
    13                                  ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    14                                  ;   GNU Affero General Public License for more details.
    15                                  ;
    16                                  ;   You should have received a copy of the GNU Affero General Public License
    17                                  ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
    18                                  ;
    19                                  ;
    20                                  ;
    21                                  ; usage:
    22                                  ;	$ qemu-system-i386 -boot a -fda oz_fd -monitor stdio
    23                                  ;
    24                                  ; requires: nasm-2.07  or later from: http://www.nasm.us
    25                                  ;
    26                                  ; credits:
    27                                  ;       many thanks to the folks at wiki.osdev.org who archive great info.
    28                                  ;
    29                                  ; contributors:
    30                                  ;        djv - Duane Voth
    31                                  ;
    32                                  ; history:
    33                                  ; 2007/03/03 - 0.00.01 - djv - begin with various web examples
    34                                  ;                      http://linuxgazette.net/issue82/misc/raghu/code.asm.txt
    35                                  ;                      http://www.osdever.net/tutorials/brunmar/simple_asm.txt
    36                                  ; 2007/03/04 - 0.00.02 - djv - add timer interrupt support with stray int dbg
    37                                  ; 2007/03/05 - 0.00.03 - djv - remove stray int dbg, add mbr data struc back
    38                                  ; 2007/03/11 - 0.00.04 - djv - debug USB boot problem
    39                                  ; 2007/03/28 - 0.01.00 - djv - add a real-mode stage2 loader in the mbr to
    40                                  ;                              load the sectors past the mbr on the boot
    41                                  ;                              device into the memory behind the mbr.  so even
    42                                  ;                              tho the read from the device happens in two
    43                                  ;                              parts, memory contains a linear image of the
    44                                  ;                              first few sectors of the boot device.
    45                                  ; 2009/02/01 - 0.02.00 - djv - begin to define application and dynamic library
    46                                  ;                              binary formats with headers detailing size and
    47                                  ;                              entry points.
    48                                  ; 2009/08/01 - 0.03.00 - djv - create the OZ app execution container using
    49                                  ;                              TSSes, paging, and rings 0 and 3.  begin to
    50                                  ;                              play with system calls.
    51                                  ; 2015/10/26 - 0.03.01 - djv - cleanup, add smp usermode tss structs, sleep,
    52                                  ;                              wakeup, and ipi for user thread creation.
    53                                  
    54                                  %ifdef USB
    55                                  [map symbols oz_usb.map]
    56                                  %else
    57                                  [map symbols oz_fd.map]
    58                                  %endif
    59                                  
    60                                  ; -------- stage 1 ---------------------------------------------------------
    61                                  ; A classic x86 Master Boot Record
    62                                  
    63                                  section .text start=0x7c00  ; PC BIOS boot loader entry point
    64                                  textstart :
    65                                  
    66                                  bios_entry :
    67 00000000 FA                          cli
    68 00000001 EA[2400]0000                jmp 0:load_stage2       ; load cs, skip over mbr data struct
    69                                  
    70                                  times 6-($-$$)  db 0
    71 00000006 6F7A                    oemid db "oz"
    72                                  
    73 00000008 00<rept>                times 11-($-$$)  db 0
    74                                  
    75                                  ; compute the size of the kernel image in 512 byte sectors
    76                                  total_size equ (kernel_text_size + kernel_data_size)
    77                                  kisectors  equ (total_size)/512 + (APP_SIZE + 512)/512
    78                                  ; compute the end of the kernel image (with apps attached)
    79                                  kilast equ 0x7c00 + kisectors * 512
    80                                  
    81                                  ; MS MBR  (http://support.microsoft.com/kb/140418)
    82                                  %ifdef FLOPPY
    83                                      dw 512                  ; Bytes per sector
    84                                      db 1                    ; Sectors per cluster
    85                                      dw kisectors            ; Number of reserved sectors
    86                                      db 2                    ; Number of FATs
    87                                      dw 0x00e0               ; Number of dirs in root
    88                                      dw 0x0b40               ; Number of sectors in volume
    89                                      db 0xf0                 ; Media descriptor
    90                                      dw 9                    ; Number of sectors per FAT
    91                                      dw 18                   ; Number of sectors per track
    92                                      dw 2                    ; Number of heads
    93                                      dd 0                    ; Number of hidden sectors
    94                                      dd 0                    ; Large Sectors
    95                                  %endif
    96                                  
    97                                  %ifdef USB
    98 0000000B 0000                        dw 0                    ; Bytes per sector
    99 0000000D 00                          db 0                    ; Sectors per cluster
   100 0000000E 3B00                        dw kisectors            ; Number of reserved sectors
   101 00000010 00                          db 0                    ; Number of FATs
   102 00000011 0000                        dw 0                    ; Number of dirs in root
   103 00000013 0000                        dw 0                    ; Number of sectors in volume
   104 00000015 00                          db 0                    ; Media descriptor
   105 00000016 0000                        dw 0                    ; Number of sectors per FAT
   106 00000018 0000                        dw 0                    ; Number of sectors per track
   107 0000001A 0000                        dw 0                    ; Number of heads
   108 0000001C 00000000                    dd 0                    ; Number of hidden sectors
   109 00000020 00000000                    dd 0                    ; Large Sectors
   110                                  %endif
   111                                  
   112                                  ; -------- stage 2 loader ------------
   113                                  bits 16
   114                                  alignb 2
   115                                  
   116                                  load_stage2 :
   117 00000024 B80030                      mov  ax,kstack_loc+kstack_size
   118 00000027 89C4                        mov  sp,ax
   119 00000029 31C0                        xor  ax,ax
   120 0000002B 8ED0                        mov  ss,ax
   121 0000002D 8EC0                        mov  es,ax
   122 0000002F 8ED8                        mov  ds,ax
   123 00000031 8EE0                        mov  fs,ax
   124 00000033 8EE8                        mov  gs,ax
   125 00000035 FC                          cld
   126                                  
   127                                      ; debug - pattern the stack so we can see what gets used
   128 00000036 66B811111111                mov  eax,0x11111111
   129 0000003C BF0010                      mov  di,kstack_loc
   130 0000003F B90008                      mov  cx,kstack_size/4
   131 00000042 F366AB                      rep stosd
   132                                  
   133 00000045 52                          push dx                 ; save BIOS drive number
   134                                  
   135 00000046 B80006                      mov  ax,0x0600          ; ah=06h : scroll window up, if al = 0 clrscr
   136 00000049 B90000                      mov  cx,0x0000          ; clear window from 0,0 
   137 0000004C BA4F17                      mov  dx,0x174f          ; to 23,79
   138 0000004F B70F                        mov  bh,0xf             ; fill with hi white
   139 00000051 CD10                        int  0x10               ; clear screen for direct writes to video memory
   140                                  
   141 00000053 BE[C600]                    mov  si,bootmsg
   142 00000056 31DB                        xor  bx,bx
   143 00000058 E85700                      call puts_vga_rm
   144                                                              ; puts_vga_rm leaves gs pointing at video mem
   145 0000005B 65C60601000E                mov  byte [gs:1],0xE    ; turn the first two chars yellow
   146 00000061 65C60603000E                mov  byte [gs:3],0xE
   147                                  
   148                                      ;F - white              
   149                                      ;E - yellow             
   150                                      ;D - magenta            
   151                                      ;C - red                
   152                                      ;B - cyan               
   153                                      ;A - green              
   154                                      ;9 - blue               
   155                                      ;8 - dark grey          
   156                                  
   157 00000067 A1[0002]                    mov  ax,[stage2]        ; check the signature byte
   158 0000006A 0306[0202]                  add  ax,[stage2+2]      ; stage2 might already have been loaded
   159 0000006E 3DA17A                      cmp  ax,0x7a6f+0x32
   160 00000071 741D                        jz   stage2_present
   161                                  
   162                                      ; -------- stage2 boot loader --------
   163                                  
   164                                      ; Assume that the kernel is smaller than whatever space
   165                                      ; is provided prior to file system data structures on the
   166                                      ; boot device, and that it can immediately follow the MBR.
   167                                  
   168 00000073 B402                        mov  ah,02h
   169 00000075 B03B                        mov  al,kisectors       ; number of sectors to load
   170 00000077 BB[0002]                    mov  bx,stage2
   171 0000007A B90200                      mov  cx,2
   172 0000007D 5A                          pop  dx                 ; recover BIOS drive number
   173 0000007E 0E                          push cs
   174 0000007F 07                          pop  es
   175 00000080 CD13                        int  13h
   176 00000082 7211                        jc   ioerr
   177                                  
   178                                      ; ---- make sure second stage actually got loaded
   179                                  
   180 00000084 A1[0002]                    mov  ax,[stage2]        ; check the signature byte
   181 00000087 0306[0202]                  add  ax,[stage2+2]
   182 0000008B 3DA17A                      cmp  ax,0x7a6f+0x32
   183 0000008E 750A                        jnz  s2err
   184                                  stage2_present :
   185 00000090 EA[0902]0000                jmp  0:start_stage2     ; use an absolute jump so stage 1
   186                                                              ; can be position independent
   187                                  
   188                                  ioerr :                     ; ah has status...
   189 00000095 BE[F600]                    mov  si,ioerrmsg
   190 00000098 EB03                        jmp  print_err
   191                                  
   192                                  s2err :
   193 0000009A BE[E000]                    mov  si,s2errmsg
   194                                  print_err :
   195 0000009D BBA000                      mov  bx,160
   196 000000A0 E80F00                      call puts_vga_rm
   197 000000A3 65C60601000C                mov  byte [gs:1],0xC    ; turn the first two vga chars red
   198 000000A9 65C60603000C                mov  byte [gs:3],0xC
   199                                  
   200                                  hang :
   201 000000AF F4                          hlt
   202 000000B0 EBFD                        jmp  hang
   203                                  
   204                                  ; ----------------------------
   205                                  ;   puts_vga_rm - write a null delimited string to the VGA controller
   206                                  ;                 in real mode
   207                                  ;
   208                                  ;    enter:
   209                                  ;            esi - address of string
   210                                  ;            ebx - screen location (2 bytes per char, 160 bytes per line)
   211                                  ;    exit:
   212                                  ;            eax - destroyed
   213                                  ;             gs - set to video memory selector
   214                                  
   215                                  puts_vga_rm :
   216 000000B2 B800B8                      mov  ax,0xb800      ; point gs at video memory
   217 000000B5 8EE8                        mov  gs,ax          
   218                                  puts_vga_rm_loop :
   219 000000B7 AC                          lodsb
   220 000000B8 3C00                        cmp  al,0
   221 000000BA 7409                        jz   puts_vga_rm_done
   222 000000BC 658807                      mov  [gs:bx],al
   223 000000BF 6683C302                    add  ebx,2
   224 000000C3 EBF2                        jmp  puts_vga_rm_loop
   225                                  puts_vga_rm_done :
   226 000000C5 C3                          ret
   227                                  
   228 000000C6 4F5A2076302E30332E-     bootmsg     db      "OZ v0.03.01 - 2015/10/26 ",0
   229 000000CF 3031202D2032303135-
   230 000000D8 2F31302F32362000   
   231 000000E0 73746167652032206C-     s2errmsg    db      "stage 2 load failure ",0
   232 000000E9 6F6164206661696C75-
   233 000000F2 72652000           
   234 000000F6 692F6F206572726F72-     ioerrmsg    db      "i/o error loading stage 2 ",0
   235 000000FF 206C6F6164696E6720-
   236 00000108 737461676520322000 
   237                                  
   238 00000111 00<rept>                times 446-($-$$) db 0       ; fill with zeros up to partition table
   239                                  
   240                                  ; If the kernel is loaded from a disk (including usb) the MBR
   241                                  ; must include a partition table based on the device geometry.
   242                                  ; This gets fed into oz.asm here via usbptbl.inc
   243                                  %ifdef USB
   244                                  %include "usbptbl.inc"
   245 000001BE 80000200060FFEFD    <1> db 0x80,0x00,0x02,0x00,0x06,0x0f,0xfe,0xfd
   246 000001C6 010000003F780F00    <1> db 0x01,0x00,0x00,0x00,0x3f,0x78,0x0f,0x00
   247 000001CE 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   248 000001D6 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   249 000001DE 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   250 000001E6 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   251 000001EE 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   252 000001F6 0000000000000000    <1> db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   253                                  %else
   254                                      ; If the kernel is placed in memory by some other means
   255                                      ; (PXE, pxelinux, etc.) the partition table is irrelevant
   256                                      ; but the space is still required.  Make the default ptbl
   257                                      ; match a 1.44MB floppy.
   258                                      db 0x80,0x01,0x01,0x00,0x06,0x01,0x12,0x4f
   259                                      db 0x12,0x00,0x00,0x00,0x2e,0x0b,0x00,0x00
   260                                      db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   261                                      db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   262                                      db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   263                                  %endif
   264                                  
   265                                  %ifdef NEWUSB
   266                                  new usb?  gpt correct?
   267                                  0000 01B0: 00 00 00 00 00 2C 44 63  E0 36 03 00 00 00 80 20  .....,Dc .6.....
   268                                  0000 01C0: 21 00 83 9D 11 4C 00 08  00 00 00 C0 12 00 00 9D  !....L.. ........
   269                                  0000 01D0: 12 4C 83 57 25 F2 00 C8  12 00 00 A0 28 00 00 00  .L.W%... ....(...
   270                                  0000 01E0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ........ ........
   271                                  0000 01F0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 AA  ........ ......U.
   272                                  %endif
   273                                  
   274                                  
   275                                  times 510-($-$$) db 0       ; fill with zeros up to MBR signature
   276                                  
   277 000001FE 55AA                                dw 0x0aa55      ; write aa55 in bytes 511,512 to indicate
   278                                                              ; that it is a boot sector. 
   279                                  
   280                                  ; end of MBR
   281                                  ;
   282                                  ; -------- stage 2 ---------------------------------------------------------
   283                                  ;
   284                                  ; If a boot loader only loads 512 bytes in the first pass, the following
   285                                  ; code won't appear in memory until the code above has completed.  Other
   286                                  ; loaders however can load the entire OZ kernel image into memory in one
   287                                  ; shot. (pxe)
   288                                  
   289                                  bits 16
   290                                  
   291                                  stage2 :
   292 00000200 6F7A3200                    db "oz2",0                      ; stage2 signature
   293                                  
   294                                  non_boot_cpu_ljmp_instruction :     ; place this in 16 bit code land
   295 00000204 EA00000000                  jmp word 0:0                    ; so we get the right opcode
   296                                  
   297                                  ; adjust this if you want to change the supported number of cpus
   298                                  max_ncpus_l2   equ 7        ; log2(max_ncpus) (128 => 7)
   299                                  
   300                                  ; adjust this to change the total stack size for all cpus
   301                                  kstack_size_l2 equ 13       ; log2 stack space for all cpus (13 => 8k)
   302                                  
   303                                  kstack_size    equ (1 << kstack_size_l2)
   304                                  
   305                                  ; adjust these if you want to move things around
   306                                  kstack_loc  equ 0x1000      ; base for cpu stacks
   307                                  tss_f08_stk equ 0x6000      ; stack for double fault (grows down from ...)
   308                                  tss_f10_stk equ 0x7000      ; stack for tss fault (grows down from ...)
   309                                  sipi_vector equ 0x7000      ; where the non-boot cpus will start
   310                                  
   311                                  ; ---------------------
   312                                  
   313                                  start_stage2 :
   314                                  
   315                                      ; ---- initialize the 8259's while in real mode
   316                                  
   317 00000209 E8D805                      call irq_init_hardware
   318                                  
   319                                  ; ------------ main kernel entry point ------------
   320                                  ; all cpus enter here
   321                                  main :
   322 0000020C FA                          cli                     ; appears to stabilize recent machines a bit
   323                                  
   324                                      ; -------- enter protected mode --------
   325                                  
   326 0000020D 0F0116[0803]                lgdt [gdtr]             ; initialize the gdt
   327 00000212 0F20C0                      mov  eax,cr0
   328 00000215 0C21                        or   al,0x21            ; set the protected mode bit (lsb of cr0)
   329 00000217 0F22C0                      mov  cr0,eax            ;   and enable the native FPU exceptions ...
   330 0000021A EA[1F02]0800                jmp  codesel:flush_ip1  ; flush the cpu instruction pipeline
   331                                  flush_ip1: 
   332                                  bits 32                     ; instructions after this point are 32bit
   333                                  
   334 0000021F 66B81000                    mov  ax,datasel
   335 00000223 8ED8                        mov  ds,ax              ; initialize the data segments
   336 00000225 8EC0                        mov  es,ax
   337                                  
   338 00000227 B801000000                  mov  eax,1
   339 0000022C 0FC105[14030000]            xadd [ncpus],eax        ; get our unique cpu number
   340                                                              ; could use the lapic id if available
   341 00000233 89C6                        mov  esi,eax
   342 00000235 66B81800                    mov  ax,stacksel        ; setup a restricted stack segment
   343 00000239 8ED0                        mov  ss,ax
   344 0000023B BC00200000                  mov  esp,kstack_size    ; start at the top of the reserved stack space
   345 00000240 89F0                        mov  eax,esi
   346 00000242 C1E006                      shl  eax,(kstack_size_l2 - max_ncpus_l2)    ; kstack_size/max_ncpus * cpu#
   347 00000245 29C4                        sub  esp,eax            ; divvy up the stack
   348                                  
   349 00000247 89F0                        mov  eax,esi
   350 00000249 50                          push eax                ; save cpu index
   351 0000024A 89C3                        mov  ebx,eax
   352 0000024C 80C330                      add  bl,'0'             ; boot cpu announces via ascii 0
   353 0000024F BF9E000000                  mov  edi,160-2          ; last chracter on first line of vga
   354 00000254 D1E0                        shl  eax,1
   355 00000256 29C7                        sub  edi,eax
   356 00000258 66B82000                    mov  ax,videosel        ; point gs at video memory
   357 0000025C 8EE8                        mov  gs,ax
   358 0000025E 65881F                      mov  [gs:edi],bl        ; announce cpu presence
   359 00000261 58                          pop  eax
   360                                  
   361 00000262 09C0                        or   eax,eax            ; are we the boot cpu?
   362 00000264 0F8FD4010000                jg   non_boot_init      ; if not, do non_boot_init
   363                                  
   364                                      ; ---- establish a "pool" of free pyhsical memory
   365                                  
   366 0000026A B810000000                  mov  eax,((kilast+0x1000) >> 12)    ; include a buffer zone
   367 0000026F A3[18030000]                mov  [next_free_page],eax
   368                                  
   369                                      ; ---- setup the paging tables
   370                                  
   371 00000274 E85A020000                  call mem_alloc_kernel_page  ; get a page for pgdir
   372 00000279 C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   373 0000027C 89C7                        mov  edi,eax
   374 0000027E A3[24030000]                mov  [pgdirp],eax
   375 00000283 A3[84010000]                mov  [tss_f08_cr3],eax
   376 00000288 A3[EC010000]                mov  [tss_f10_cr3],eax
   377 0000028D A3[54020000]                mov  [tss0_cr3],eax
   378 00000292 A3[BC020000]                mov  [tss1_cr3],eax
   379 00000297 E837020000                  call mem_alloc_kernel_page  ; get a page for pgtb0
   380 0000029C C1E00C                      shl  eax,12
   381 0000029F 89C2                        mov  edx,eax
   382 000002A1 A3[28030000]                mov  [pgtb0p],eax
   383 000002A6 E828020000                  call mem_alloc_kernel_page  ; get a page for pgtb1
   384 000002AB C1E00C                      shl  eax,12
   385 000002AE 89C1                        mov  ecx,eax
   386 000002B0 A3[2C030000]                mov  [pgtb1p],eax
   387                                  
   388                                              ; first the page directory
   389                                  
   390 000002B5 0F22DF                      mov  cr3,edi            ; install the page directory
   391 000002B8 89D0                        mov  eax,edx
   392 000002BA 83C007                      add  eax,7              ; page table 0: present, pl=3, r/w
   393 000002BD AB                          stosd                   ; ... pl=3 for now (simplify vga access)
   394 000002BE 89C8                        mov  eax,ecx
   395 000002C0 83C007                      add  eax,7              ; page table 1: present, pl=3, r/w
   396 000002C3 AB                          stosd                   ; ... app memory
   397 000002C4 31C0                        xor  eax,eax            ; invalidate the rest of the app laddr space
   398 000002C6 B9FE030000                  mov  ecx,0x400-2        ; (yeah, only one pgdir for kernel+apps for now)
   399 000002CB F3AB                        rep stosd
   400                                  
   401                                              ; pgtb0 is the page table for kernel memory
   402                                  
   403 000002CD 89D7                        mov  edi,edx
   404 000002CF AB                          stosd                   ; access to page 0 will always cause a fault
   405 000002D0 B803100000                  mov  eax,0x1000 + 3     ; rest are direct map: present, pl=0, r/w
   406 000002D5 B9FF030000                  mov  ecx,0x400-1
   407                                  pgtb0_fill :
   408 000002DA AB                          stosd                   ; kernel gets to touch anything it wants < 4MB
   409 000002DB 0500100000                  add  eax,0x1000
   410 000002E0 E2F8                        loop pgtb0_fill
   411                                  
   412                                              ; pgtb1 is the first page table for app code/data/stack it is
   413                                              ; already all zeros (invalid - we'll fill in what we need later)
   414                                  
   415                                              ; enable paging - if we've done it all right, we won't crash
   416                                  
   417 000002E2 0F20C0                      mov  eax,cr0
   418 000002E5 0D00000080                  or   eax,0x80000000     ; msb of cr0
   419 000002EA 0F22C0                      mov  cr0,eax
   420 000002ED EB00                        jmp  flush_ip2          ; flush the cpu instruction pipeline
   421                                  flush_ip2: 
   422                                  
   423                                      ; ---- build the interrupt descriptor table
   424                                  
   425 000002EF E8DF010000                  call mem_alloc_kernel_page  ; get a page for the idt
   426 000002F4 C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   427 000002F7 89C2                        mov  edx,eax
   428 000002F9 A3[10030000]                mov  [idtr_addr],eax
   429                                  
   430 000002FE BE[F80D0000]                mov  esi,irq_setup_table
   431 00000303 B900010000                  mov  ecx,irq_setup_table_size
   432                                  irq_init :
   433 00000308 31C0                        xor  eax,eax
   434 0000030A 8902                        mov  [edx],eax                  ; clear the idt entry
   435 0000030C 894202                      mov  [edx+2],eax
   436 0000030F 66AD                        lodsw
   437 00000311 6689C3                      mov  bx,ax
   438 00000314 6625FCFF                    and  ax,strict 0xfffc           ; separate config flags
   439 00000318 6683E303                    and  bx,3                       ; from selector/offset value
   440 0000031C 6683FB02                    cmp  bx,irqt_task               ; task gates are different
   441 00000320 7407                        jz   irq_init_task_gate
   442 00000322 668902                      mov  [edx],ax                   ; store the handler offset
   443 00000325 66B80800                    mov  ax,codesel
   444                                  irq_init_task_gate :
   445 00000329 66894202                    mov  word [edx+2],ax
   446 0000032D 678AA7[F40D]                mov  ah,byte [bx+irq_types]
   447 00000332 30C0                        xor  al,al
   448 00000334 66894204                    mov  word [edx+4],ax
   449 00000338 83C208                      add  edx,8
   450 0000033B E2CB                        loop irq_init
   451                                  
   452 0000033D 0F011D[0E030000]            lidt [idtr]                     ; install the idt
   453                                  
   454                                      ; ---- let's see what kind of interrupt hardware we've got
   455                                  
   456 00000344 C605[30030000]00            mov  byte [enabled_lapic],0x0
   457 0000034B B801000000                  mov  eax,1
   458 00000350 0FA2                        cpuid
   459 00000352 83F801                      cmp  eax,1
   460 00000355 720F                        jb   no_lapic
   461 00000357 81E200020000                and  edx,1 << 9         ; lapic feature
   462 0000035D 7407                        jz   no_lapic
   463 0000035F C605[30030000]01            mov  byte [enabled_lapic],0x1
   464                                  no_lapic :
   465                                  
   466                                              ; if enabled, create page table entry for the lapic
   467                                  
   468 00000366 A0[30030000]                mov  al,[enabled_lapic]
   469 0000036B 08C0                        or   al,al
   470 0000036D 7430                        jz   no_lapic_init
   471                                  
   472 0000036F BA0000E0FE                  mov  edx,0xfee00000     ; phys address
   473 00000374 B900100000                  mov  ecx,0x1000         ; length
   474 00000379 E82F0D0000                  call map_pmem
   475                                  
   476                                      ; do the ioapic while we're at it
   477 0000037E BA0000C0FE                  mov  edx,0xfec00000     ; phys address
   478 00000383 52                          push edx
   479 00000384 B900100000                  mov  ecx,0x1000         ; length
   480 00000389 E81F0D0000                  call map_pmem
   481 0000038E 5A                          pop  edx
   482 0000038F C70201000000                mov  dword [edx],1
   483 00000395 A11000C0FE                  mov  eax,[0xfec00010]
   484                                  
   485 0000039A E86E040000                  call irq_init_bsp_apic_hardware
   486                                  
   487                                  no_lapic_init :
   488                                  
   489                                      ; ---- setup entry point for non_boot_cpus
   490                                  
   491 0000039F A0[04020000]                mov  al,[non_boot_cpu_ljmp_instruction]     ; get the ljmp instruction
   492 000003A4 A200700000                  mov  [sipi_vector],al                       ; place it at a 4k phys mem boundary
   493 000003A9 C70501700000-               mov  dword [sipi_vector+1],main
   494 000003AF [0C020000]         
   495                                  
   496                                      ; ---- establish a current task
   497                                  
   498 000003B3 31C0                        xor  eax,eax
   499 000003B5 B050                        mov  al,tasksel_k00
   500 000003B7 0F00D8                      ltr  ax
   501                                  
   502                                      ; ---- check for init apps
   503                                  
   504 000003BA BB[B00F0000]                mov  ebx, kend
   505                                  app_loop :
   506 000003BF 8B4318                      mov  eax, [ebx+0x18]    ; load the entry address
   507 000003C2 813B6F7A6170                cmp  dword [ebx], 0x70617a6f  ; check for "ozap"
   508 000003C8 7402                        jz   have_an_app
   509 000003CA 31C0                        xor  eax, eax           ; no app
   510                                  have_an_app :
   511                                  
   512 000003CC 83F800                      cmp  eax, 0             ; is there an app to run?
   513 000003CF 0F84A8000000                jz   idle               ; if not, idle right away
   514                                  
   515                                      ; ---- setup the init task entry point
   516                                  
   517 000003D5 BF[C0020000]                mov  edi,tss1_eip
   518 000003DA AB                          stosd
   519                                  
   520                                      ; cheat: reuse the same tss, ldt, and page tables for all
   521                                      ; the init apps - this means they run serialy - each has
   522                                      ; to exit for the next one to run
   523                                  
   524 000003DB 31C0                        xor   eax,eax
   525 000003DD A3[A0020000]                mov   [tss1],eax        ; clear out previous task link
   526 000003E2 AB                          stosd                   ; and some registers (flags)
   527 000003E3 AB                          stosd                   ; (eax)
   528 000003E4 AB                          stosd                   ; (ecx)
   529 000003E5 AB                          stosd                   ; (edx)
   530 000003E6 AB                          stosd                   ; (ebx)
   531 000003E7 8B4310                      mov   eax, [ebx+0x10]   ; get the end of the app
   532                                      ;add   eax,0x8001000     ; (this tests app stack page faults)
   533 000003EA AB                          stosd                   ; (esp)
   534 000003EB 31C0                        xor   eax,eax
   535 000003ED AB                          stosd                   ; (ebp)
   536 000003EE AB                          stosd                   ; (esi)
   537 000003EF AB                          stosd                   ; (edi)
   538                                  
   539 000003F0 8B3D[2C030000]              mov  edi,[pgtb1p]       ; rewrite the app's page table
   540 000003F6 89D8                        mov  eax,ebx
   541 000003F8 83C805                      or   eax,5              ; init app code at 0x400000 (4Mb) present and r/o
   542 000003FB AB                          stosd                   ; assume all the init apps are < 4k
   543 000003FC 0502100000                  add  eax,0x1000 + 2     ; add one page for data/bss/stack
   544 00000401 AB                          stosd
   545                                  
   546                                      ; ---- debug marker
   547 00000402 65C605010000000A            mov  byte [gs:1],0xA    ; turn the first two chars green
   548 0000040A 65C605030000000A            mov  byte [gs:3],0xA
   549                                  
   550                                      ; ---- use our current stack for system interrupts during the app
   551                                  
   552 00000412 53                          push ebx
   553 00000413 BF[A4020000]                mov  edi,tss1_esp0
   554 00000418 89E0                        mov  eax,esp
   555 0000041A AB                          stosd
   556                                  
   557                                      ; ---- start the app
   558                                  
   559 0000041B FB                          sti
   560 0000041C 9A000000005800              call tasksel_u00:0
   561 00000423 5B                          pop  ebx
   562                                  
   563                                      ; ---- point to the end of this init app
   564                                  
   565 00000424 0F013D00004000              invlpg [0x400000]       ; FIXME 80386 needs to reload cr3
   566 0000042B 0F013D00104000              invlpg [0x401000]
   567                                  
   568 00000432 8B4310                      mov  eax, [ebx+0x10]    ; load the app end address
   569 00000435 2D00004000                  sub  eax,0x400000
   570 0000043A 01C3                        add  ebx,eax            ; point ebx to the next app
   571 0000043C EB81                        jmp  app_loop
   572                                  
   573                                  ; -------- non-boot cpu initialization --------
   574                                  
   575                                  non_boot_init :
   576                                  
   577 0000043E 0F011D[0E030000]            lidt [idtr]             ; install the global idt
   578                                  
   579                                      ; ---- enable paging
   580                                  
   581 00000445 8B3D[24030000]              mov  edi,[pgdirp]       ; load this cpu's paging register
   582 0000044B 0F22DF                      mov  cr3,edi
   583                                  
   584 0000044E 50                          push eax
   585 0000044F 0F20C0                      mov  eax,cr0            ; enable paging
   586 00000452 0D00000080                  or   eax,0x80000000
   587 00000457 0F22C0                      mov  cr0,eax
   588 0000045A EB00                        jmp  flush_ip3          ; flush the cpu instruction pipeline
   589                                  flush_ip3 : 
   590 0000045C 58                          pop  eax
   591                                  
   592                                      ; ---- limit the number of threads we support here
   593                                  
   594 0000045D 83F810                      cmp  eax,max_threads
   595 00000460 7317                        jae  nb_idle
   596                                  
   597                                      ; ---- init the lapic
   598                                  
   599 00000462 E8EE030000                  call irq_init_ap_apic_hardware
   600                                  
   601                                      ; setup smbase?
   602                                  
   603                                      ; ---- establish a current task
   604                                  
   605 00000467 89C3                        mov  ebx,eax            ; move cpu number to ebx
   606 00000469 E886000000                  call create_tss_pair
   607 0000046E 53                          push ebx
   608 0000046F C1E304                      shl  ebx,4              ; 16x (descriptor_size x2)
   609 00000472 83C350                      add  ebx,tasksel_k00
   610 00000475 0F00DB                      ltr  bx                 ; establish a current task
   611 00000478 5B                          pop  ebx
   612                                  
   613                                      ; test kernel page fault handler
   614                                      ;mov  [321],eax
   615                                  
   616                                  nb_idle :
   617 00000479 FB                          sti
   618 0000047A F4                          hlt                     ; wait for something to do
   619 0000047B EBFC                        jmp  nb_idle            ; (see new_thread)
   620                                  
   621                                      ; -------- boot cpu idle task --------
   622                                      ; could be combined with nb_idle but separating
   623                                      ; these can allow for easier debug
   624                                  
   625                                  idle :
   626 0000047D FB                          sti
   627 0000047E F4                          hlt                     ; wait for interrupts
   628 0000047F EBFC                        jmp  idle
   629                                  
   630                                  
   631                                  ; ----------------------------
   632                                  ;    puts_vga - write a null delimited string to the VGA controller
   633                                  ;               in protected mode
   634                                  ;    enter:
   635                                  ;         esi - address of string
   636                                  ;         ebx - screen location (2 bytes per char, 160 bytes per line)
   637                                  ;    exit:
   638                                  ;         eax - destroyed
   639                                  ;         ebx - next screen location
   640                                  ;          gs - set to video memory selector
   641                                  bits 32
   642                                  
   643                                  puts_vga :
   644 00000481 66B82000                    mov  ax,videosel        ; point gs at video memory
   645 00000485 8EE8                        mov  gs,ax
   646                                  puts_vga_loop :
   647 00000487 2E8A06                      mov  al,[cs:esi]        ; use cs so irq handlers don't
   648 0000048A 46                          inc  esi                ; have to load kernel ds
   649 0000048B 3C00                        cmp  al,0
   650 0000048D 7408                        jz   puts_vga_done
   651 0000048F 658803                      mov  [gs:ebx],al
   652 00000492 83C302                      add  ebx,2
   653 00000495 EBF0                        jmp  puts_vga_loop
   654                                  puts_vga_done :
   655 00000497 C3                          ret
   656                                  
   657                                  ; ----------------------------
   658                                  ;   putx_vga - write the contents of eax in hex to the VGA controller
   659                                  ;              (in protected mode)
   660                                  ;   putbx_vga - write the contents of al in hex to the VGA controller
   661                                  ;
   662                                  ;   enter:
   663                                  ;       eax - value to convert to hex
   664                                  ;       ebx - screen location (2 bytes per char, 160 bytes per line)
   665                                  ;   exit:
   666                                  ;       ebx - next screen location
   667                                  ;        gs - set to video memory selector
   668                                  bits 32
   669                                  
   670                                  putbx_vga :
   671 00000498 51                          push ecx
   672 00000499 B902000000                  mov  ecx,2
   673 0000049E 25FF000000                  and  eax,0xff
   674 000004A3 C1C018                      rol  eax,24
   675 000004A6 EB06                        jmp putx_vga_loop
   676                                  
   677                                  putx_vga :
   678 000004A8 51                          push ecx
   679 000004A9 B908000000                  mov  ecx,8
   680                                  putx_vga_loop :
   681 000004AE C1C004                      rol  eax,4
   682 000004B1 50                          push eax
   683 000004B2 240F                        and  al,0xf
   684 000004B4 3C09                        cmp  al,9
   685 000004B6 7704                        ja   putx_vga_hexdigit
   686 000004B8 0430                        add  al,'0'
   687 000004BA EB02                        jmp short putx_vga_putc
   688                                  putx_vga_hexdigit :
   689 000004BC 0457                        add  al,'a'-10
   690                                  putx_vga_putc :
   691 000004BE 658803                      mov  [gs:ebx],al
   692 000004C1 83C302                      add  ebx,2
   693 000004C4 58                          pop  eax
   694 000004C5 83E0F0                      and  eax,0xfffffff0
   695 000004C8 E2E4                        loop putx_vga_loop
   696 000004CA 65C60320                    mov  byte [gs:ebx],' '
   697 000004CE 83C302                      add  ebx,2
   698 000004D1 59                          pop  ecx
   699 000004D2 C3                          ret
   700                                  
   701                                  ;------------------------------------------------------------------
   702                                  ;   mem_alloc_kernel_page - return the 4k page number of 1 page of memory
   703                                  ;                           from the kernel page pool
   704                                  ;
   705                                  ;   smp safe
   706                                  ;
   707                                  ;   returns:    eax = page number, zero means no pages left
   708                                  
   709                                  mem_alloc_kernel_page :
   710 000004D3 B801000000                  mov  eax,1
   711 000004D8 0FC105[18030000]            xadd [next_free_page],eax   ; atomic, making this re-entrant
   712                                      ; FIXME probably should check for the end of something and return 0
   713 000004DF 50                          push eax
   714 000004E0 51                          push ecx
   715 000004E1 57                          push edi
   716 000004E2 C1E00C                      shl  eax,12
   717 000004E5 B900040000                  mov  ecx,0x1000/4
   718 000004EA 89C7                        mov  edi,eax
   719 000004EC 31C0                        xor  eax,eax
   720 000004EE F3AB                        rep stosd                   ; zero the page
   721 000004F0 5F                          pop  edi
   722 000004F1 59                          pop  ecx
   723 000004F2 58                          pop  eax
   724 000004F3 C3                          ret
   725                                  
   726                                  ;------------------------------------------------------------------
   727                                  ;   create a pair of tss structs for a new cpu
   728                                  ;
   729                                  ;   enter:
   730                                  ;       ebx - cpu number
   731                                  ;   exit:
   732                                  ;       ebx - cpu number
   733                                  
   734                                  create_tss_pair :
   735 000004F4 E8DAFFFFFF                  call mem_alloc_kernel_page
   736 000004F9 09C0                        or   eax,eax
   737 000004FB 0F849C000000                jz   create_tss_pair_fail
   738 00000501 C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   739 00000504 89C7                        mov  edi,eax                ; first tss is the kernel ring 0 thread
   740                                  
   741 00000506 89FE                        mov  esi,edi
   742 00000508 83C668                      add  esi,(tss0_end-tss0)    ; second tss is the user ring 3 thread
   743                                  
   744 0000050B A1[24030000]                mov  eax,[pgdirp]
   745 00000510 89471C                      mov  [edi+(tss0_cr3-tss0)],eax
   746 00000513 89461C                      mov  [esi+(tss0_cr3-tss0)],eax
   747                                  
   748                                      ; user tss gets ldt selectors
   749 00000516 B817000000                  mov  eax,datasel1+7
   750 0000051B 894648                      mov  [esi+(tss0_es-tss0)],eax
   751 0000051E 894650                      mov  [esi+(tss0_ss-tss0)],eax
   752 00000521 894654                      mov  [esi+(tss0_ds-tss0)],eax
   753 00000524 B80F000000                  mov  eax,codesel1+7
   754 00000529 89464C                      mov  [esi+(tss0_cs-tss0)],eax
   755 0000052C B83B000000                  mov  eax,ldtsel1+3
   756 00000531 894660                      mov  [esi+(tss0_ldt-tss0)],eax
   757                                  
   758                                      ; there are three stacks total
   759                                      ;   (1) kernel tss esp0 - placed at the end of this page
   760                                      ;   (2) user tss esp0 (for interrupt handling) - end minus 1k
   761                                      ;   (3) user tss esp - will be set up by new_thread
   762                                  
   763                                      ;mov  eax,stacksel
   764                                      ;mov  [edi+(tss0_ss0-tss0)],eax
   765                                      ;mov  [edi+(tss0_esp0-tss0)],esp ; (1) kernel tss esp0
   766                                  
   767 00000534 B810000000                  mov  eax,datasel
   768 00000539 894708                      mov  [edi+(tss0_ss0-tss0)],eax
   769 0000053C 89F8                        mov  eax,edi
   770 0000053E 0500080000                  add  eax,0x0800                 ; end of the tss page
   771 00000543 894704                      mov  [edi+(tss0_esp0-tss0)],eax ; (1) kernel tss esp0
   772                                  
   773                                      ; sloppy (datasel maps all of physical ram), but better than
   774                                      ; having to set up a separate gdt stacksel for each cpu
   775 00000546 B810000000                  mov  eax,datasel
   776 0000054B 894608                      mov  [esi+(tss0_ss0-tss0)],eax
   777 0000054E 89F8                        mov  eax,edi
   778 00000550 0500100000                  add  eax,0x1000                 ; end of the tss page
   779 00000555 894604                      mov  [esi+(tss0_esp0-tss0)],eax ; (2) user tss esp0
   780                                  
   781                                      ; patch the tss addresses into the reserved gdt selectors
   782                                  
   783 00000558 89DA                        mov  edx,ebx
   784 0000055A C1E204                      shl  edx,4                      ; 16x because selectors are in pairs
   785 0000055D 83C250                      add  edx,tasksel_k00
   786                                  
   787 00000560 89F8                        mov  eax,edi
   788 00000562 C1E818                      shr  eax,24
   789 00000565 8882[07000000]              mov  byte [gdt+edx+7],al        ; base 24-32
   790 0000056B 81E7FFFFFF00                and  edi,0xffffff
   791 00000571 0BBA[02000000]              or   edi,[gdt+edx+2]            ; or in flags
   792 00000577 89BA[02000000]              mov  [gdt+edx+2],edi            ; base 0-23 and flags
   793                                  
   794 0000057D 83C208                      add  edx,8                      ; move to tasksel_uxx
   795                                  
   796 00000580 89F0                        mov  eax,esi
   797 00000582 C1E818                      shr  eax,24
   798 00000585 8882[07000000]              mov  byte [gdt+edx+7],al        ; base 24-32
   799 0000058B 81E6FFFFFF00                and  esi,0xffffff
   800 00000591 0BB2[02000000]              or   esi,[gdt+edx+2]            ; or in flags
   801 00000597 89B2[02000000]              mov  [gdt+edx+2],esi            ; base 0-23 and flags
   802                                  
   803                                  create_tss_pair_fail :
   804 0000059D C3                          ret
   805                                  
   806                                  ; -------- interrupt handlers --------
   807                                  %include "ozirq.asm"
   808                              <1> ; OZ - A more utopian OS    x86-32 interrupts
   809                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
   810                              <1> ;
   811                              <1> ; Copyright (C) 2015  Duane Voth
   812                              <1> ;
   813                              <1> ;   This program is free software: you can redistribute it and/or modify
   814                              <1> ;   it under the terms of the GNU Affero General Public License as
   815                              <1> ;   published by the Free Software Foundation, either version 3 of the
   816                              <1> ;   License, or (at your option) any later version.
   817                              <1> ;
   818                              <1> ;   This program is distributed in the hope that it will be useful,
   819                              <1> ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
   820                              <1> ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   821                              <1> ;   GNU Affero General Public License for more details.
   822                              <1> ;
   823                              <1> ;   You should have received a copy of the GNU Affero General Public License
   824                              <1> ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
   825                              <1> ;
   826                              <1> ;
   827                              <1> ; IRQ handling
   828                              <1> ;
   829                              <1> ; resources:
   830                              <1> ;       http://forum.osdev.org/viewtopic.php?p=107868#107868
   831                              <1> 
   832 0000059E 63707500            <1> cpumsg      db      "cpu",0
   833                              <1> 
   834 000005A2 646976696465206279- <1> int00msg    db      "divide by zero ",0
   835 000005AB 207A65726F2000      <1>
   836 000005B2 646562756720657863- <1> int01msg    db      "debug exception ",0
   837 000005BB 657074696F6E2000    <1>
   838 000005C3 6E6D692000          <1> int02msg    db      "nmi ",0
   839 000005C8 627265616B706F696E- <1> int03msg    db      "breakpoint exception ",0
   840 000005D1 742065786365707469- <1>
   841 000005DA 6F6E2000            <1>
   842 000005DE 6F766572666C6F7720- <1> int04msg    db      "overflow exception ",0
   843 000005E7 657863657074696F6E- <1>
   844 000005F0 2000                <1>
   845 000005F2 626F756E6420657863- <1> int05msg    db      "bound exceeded ",0
   846 000005FB 65656465642000      <1>
   847 00000602 696E76616C6964206F- <1> int06msg    db      "invalid opcode ",0
   848 0000060B 70636F64652000      <1>
   849 00000612 64657669636520756E- <1> int07msg    db      "device unavailable ",0
   850 0000061B 617661696C61626C65- <1>
   851 00000624 2000                <1>
   852 00000626 646F75626C65206661- <1> int08msg    db      "double fault ",0
   853 0000062F 756C742000          <1>
   854 00000634 636F70726F63657373- <1> int09msg    db      "coprocessor segment overrun ",0
   855 0000063D 6F72207365676D656E- <1>
   856 00000646 74206F76657272756E- <1>
   857 0000064F 2000                <1>
   858 00000651 696E76616C69642074- <1> int10msg    db      "invalid tss ",0
   859 0000065A 73732000            <1>
   860 0000065E 7365676D656E74206E- <1> int11msg    db      "segment not present ",0
   861 00000667 6F742070726573656E- <1>
   862 00000670 742000              <1>
   863 00000673 737461636B20666175- <1> int12msg    db      "stack fault ",0
   864 0000067C 6C742000            <1>
   865 00000680 67656E6572616C2070- <1> int13msg    db      "general protection fault ",0
   866 00000689 726F74656374696F6E- <1>
   867 00000692 206661756C742000    <1>
   868 0000069A 6B65726E656C207061- <1> int14kmsg   db      "kernel page fault addr=",0
   869 000006A3 6765206661756C7420- <1>
   870 000006AC 616464723D00        <1>
   871 000006B2 617070207061676520- <1> int14umsg   db      "app page fault addr=",0
   872 000006BB 6661756C7420616464- <1>
   873 000006C4 723D00              <1>
   874 000006C7 666C6F6174696E6720- <1> int16msg    db      "floating point err ",0
   875 000006D0 706F696E7420657272- <1>
   876 000006D9 2000                <1>
   877 000006DB 616C69676E6D656E74- <1> int17msg    db      "alignment check ",0
   878 000006E4 20636865636B2000    <1>
   879 000006EC 6D616368696E652063- <1> int18msg    db      "machine check ",0
   880 000006F5 6865636B2000        <1>
   881 000006FB 73696D6420666C6F61- <1> int19msg    db      "simd floating point err ",0
   882 00000704 74696E6720706F696E- <1>
   883 0000070D 74206572722000      <1>
   884                              <1> 
   885 00000714 687720696E74303220- <1> int34msg    db      "hw int02 ",0
   886 0000071D 00                  <1>
   887 0000071E 687720696E74303320- <1> int35msg    db      "hw int03 ",0
   888 00000727 00                  <1>
   889 00000728 687720696E74303420- <1> int36msg    db      "hw int04 ",0
   890 00000731 00                  <1>
   891 00000732 687720696E74303520- <1> int37msg    db      "hw int05 ",0
   892 0000073B 00                  <1>
   893 0000073C 687720696E74303620- <1> int38msg    db      "hw int06 ",0
   894 00000745 00                  <1>
   895 00000746 687720696E74303720- <1> int39msg    db      "hw int07 ",0
   896 0000074F 00                  <1>
   897 00000750 687720696E74303820- <1> int40msg    db      "hw int08 ",0
   898 00000759 00                  <1>
   899 0000075A 687720696E74303920- <1> int41msg    db      "hw int09 ",0
   900 00000763 00                  <1>
   901 00000764 687720696E74313020- <1> int42msg    db      "hw int10 ",0
   902 0000076D 00                  <1>
   903 0000076E 687720696E74313120- <1> int43msg    db      "hw int11 ",0
   904 00000777 00                  <1>
   905 00000778 687720696E74313220- <1> int44msg    db      "hw int12 ",0
   906 00000781 00                  <1>
   907 00000782 687720696E74313320- <1> int45msg    db      "hw int13 ",0
   908 0000078B 00                  <1>
   909 0000078C 687720696E74313420- <1> int46msg    db      "hw int14 ",0
   910 00000795 00                  <1>
   911 00000796 687720696E74313520- <1> int47msg    db      "hw int15 ",0
   912 0000079F 00                  <1>
   913                              <1> 
   914 000007A0 73707572696F757320- <1> spuriousmsg db      "spurious int ",0
   915 000007A9 696E742000          <1>
   916 000007AE 617069636572722069- <1> apicerrmsg  db      "apicerr int ",0
   917 000007B7 6E742000            <1>
   918 000007BB 68692000            <1> himsg       db      "hi ",0
   919 000007BF 756E6B6E6F776E2073- <1> int255msg           db  "unknown system call ",0
   920 000007C8 797374656D2063616C- <1>
   921 000007D1 6C2000              <1>
   922                              <1> 
   923 000007D4 766D206661756C743A- <1> intvmmsg            db  "vm fault: ",0
   924 000007DD 2000                <1>
   925                              <1> 
   926 000007DF 90                  <1>   align 4
   927 000007E0 00000000            <1> irq_err_lno dd 0
   928                              <1> 
   929                              <1> ; ---- IRQ hardware initialization ----
   930                              <1> 
   931                              <1> bits 16
   932                              <1> 
   933                              <1> irq_init_hardware :
   934                              <1> 
   935                              <1>     ; re-program the 8259's to move the hardware vectors out of the
   936                              <1>     ; soft int range ... C'mon, Intel was pretty clear about this!
   937                              <1> 
   938 000007E4 B011                <1>     mov  al,0x11
   939 000007E6 E620                <1>     out  0x20,al            ; init the 1st 8259
   940 000007E8 B011                <1>     mov  al,0x11
   941 000007EA E6A0                <1>     out  0xA0,al            ; init the 2nd 8259
   942 000007EC B020                <1>     mov  al,apic0_irqbase
   943 000007EE E621                <1>     out  0x21,al            ; base for the 1st 8259
   944 000007F0 B028                <1>     mov  al,apic1_irqbase
   945 000007F2 E6A1                <1>     out  0xA1,al            ; base for the 2nd 8259
   946 000007F4 B004                <1>     mov  al,0x04
   947 000007F6 E621                <1>     out  0x21,al            ; set 1st 8259 as master
   948 000007F8 B002                <1>     mov  al,0x02
   949 000007FA E6A1                <1>     out  0xA1,al            ; set 2nd 8259 as slave
   950 000007FC B001                <1>     mov  al,0x01
   951 000007FE E621                <1>     out  0x21,al
   952 00000800 B001                <1>     mov  al,0x01
   953 00000802 E6A1                <1>     out  0xA1,al
   954 00000804 B0FC                <1>     mov  al,0xfc            ; PIC1 disable all but the timer and kbd
   955 00000806 E621                <1>     out  0x21,al
   956 00000808 B0FF                <1>     mov  al,0xff            ; PIC2 disable everything
   957 0000080A E6A1                <1>     out  0xA1,al
   958 0000080C C3                  <1>     ret
   959                              <1> 
   960                              <1> bits 32
   961                              <1> 
   962                              <1> ; ----------
   963                              <1> 
   964                              <1> irq_init_bsp_apic_hardware :
   965                              <1>     ;jmp  no_apic
   966                              <1> 
   967                              <1>     ; ---- test for an apic
   968                              <1> 
   969 0000080D A17003E0FE          <1>     mov  eax,[0xfee00370]
   970 00000812 2500FFFFFF          <1>     and  eax,0xffffff00
   971 00000817 0DF0000000          <1>     or   eax,apicerr_int
   972 0000081C A37003E0FE          <1>     mov  [0xfee00370],eax   ; setup LVT3 error vector
   973                              <1> 
   974 00000821 B8EF010000          <1>     mov  eax,0x00000100 + spurious_int    ; enable + spurious int
   975 00000826 A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
   976 0000082B B800000001          <1>     mov  eax,0x01000000
   977 00000830 A3D000E0FE          <1>     mov  [0xfee000d0],eax   ; set our LDR
   978 00000835 B8FFFFFFFF          <1>     mov  eax,0xffffffff
   979 0000083A A3E000E0FE          <1>     mov  [0xfee000e0],eax   ; set our DFR
   980 0000083F 31C0                <1>     xor  eax,eax
   981 00000841 A3B000E0FE          <1>     mov  [0xfee000b0],eax   ; eoi anything outstanding
   982                              <1> 
   983                              <1> ;    ; ---- enable the local apic via msr
   984                              <1> ; but apparently not needed ...
   985                              <1> ;    mov  ecx,0x1b
   986                              <1> ;    xor  edx,edx
   987                              <1> ; ;  mov  eax,0xfffff800
   988                              <1> ;    mov  eax,0x00000800
   989                              <1> ;    wrmsr
   990                              <1> ;    mov  eax,[0xfffff030]
   991                              <1> 
   992                              <1>     ; ---- visual indicator: lapic active
   993                              <1> 
   994 00000846 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
   995 0000084A 8EE8                <1>     mov  gs,ax          
   996 0000084C 65C605320000002B    <1>     mov  byte [gs:25*2],'+'
   997                              <1> 
   998 00000854 C3                  <1>     ret
   999                              <1> 
  1000                              <1> ; ----------
  1001                              <1> 
  1002                              <1> irq_init_ap_apic_hardware :
  1003                              <1>     ; eax = cpu number
  1004                              <1> 
  1005                              <1>     ; ---- mtrr for 0xfee00000 -> strong uncachable (UC) ?
  1006                              <1> 
  1007 00000855 50                  <1>     push eax                ; save cpu number
  1008 00000856 89C1                <1>     mov  ecx,eax
  1009 00000858 A0[30030000]        <1>     mov  al,[enabled_lapic]
  1010 0000085D 08C0                <1>     or   al,al
  1011 0000085F 7432                <1>     jz  no_lapic_init2
  1012                              <1> 
  1013 00000861 BB00000001          <1>     mov  ebx,0x01000000
  1014 00000866 D3E3                <1>     shl  ebx,cl             ; bit mask based on cpu number
  1015 00000868 891DD000E0FE        <1>     mov  [0xfee000d0],ebx   ; set our LDR
  1016                              <1> 
  1017 0000086E A17003E0FE          <1>     mov  eax,[0xfee00370]
  1018 00000873 2500FFFFFF          <1>     and  eax,0xffffff00
  1019 00000878 0DF0000000          <1>     or   eax,apicerr_int
  1020 0000087D A37003E0FE          <1>     mov  [0xfee00370],eax   ; setup LVT3 error vector
  1021                              <1> 
  1022 00000882 B8EF010000          <1>     mov  eax,0x00000100 + spurious_int  ; enable + spurious int
  1023 00000887 A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
  1024 0000088C 31C0                <1>     xor  eax,eax
  1025 0000088E A3B000E0FE          <1>     mov  [0xfee000b0],eax   ; eoi anything outstanding
  1026                              <1> no_lapic_init2 :
  1027 00000893 58                  <1>     pop  eax
  1028 00000894 C3                  <1>     ret
  1029                              <1> 
  1030                              <1> ; ---- IRQ handlers ----
  1031                              <1> 
  1032 00000895 90<rept>            <1> align 4
  1033                              <1> int_handler_div0 :
  1034 00000898 56                  <1>     push esi
  1035 00000899 BE[A2050000]        <1>     mov  esi,int00msg
  1036 0000089E E8C5040000          <1>     call irq_print_msg
  1037 000008A3 5E                  <1>     pop  esi
  1038 000008A4 E9EC000000          <1>     jmp  int_handler_show_eip
  1039                              <1> 
  1040 000008A9 90<rept>            <1> align 4
  1041                              <1> int_handler_debug :
  1042 000008AC 56                  <1>     push esi
  1043 000008AD BE[B2050000]        <1>     mov  esi,int01msg
  1044 000008B2 E8B1040000          <1>     call irq_print_msg
  1045 000008B7 5E                  <1>     pop  esi
  1046 000008B8 E9D8000000          <1>     jmp  int_handler_show_eip
  1047                              <1> 
  1048 000008BD 90<rept>            <1> align 4
  1049                              <1> int_handler_nmi :
  1050 000008C0 56                  <1>     push esi
  1051 000008C1 BE[C3050000]        <1>     mov  esi,int02msg
  1052 000008C6 E89D040000          <1>     call irq_print_msg
  1053 000008CB 5E                  <1>     pop  esi
  1054 000008CC CF                  <1>     iret
  1055                              <1>     ;jmp  reboot_on_alt_key
  1056                              <1> 
  1057 000008CD 90<rept>            <1> align 4
  1058                              <1> int_handler_brkp :
  1059 000008D0 56                  <1>     push esi
  1060 000008D1 BE[C8050000]        <1>     mov  esi,int03msg
  1061 000008D6 E88D040000          <1>     call irq_print_msg
  1062 000008DB 5E                  <1>     pop  esi
  1063 000008DC E9B4000000          <1>     jmp  int_handler_show_eip
  1064                              <1> 
  1065 000008E1 90<rept>            <1> align 4
  1066                              <1> int_handler_ovrflw :
  1067 000008E4 56                  <1>     push esi
  1068 000008E5 BE[DE050000]        <1>     mov  esi,int04msg
  1069 000008EA E879040000          <1>     call irq_print_msg
  1070 000008EF 5E                  <1>     pop  esi
  1071 000008F0 E9A0000000          <1>     jmp  int_handler_show_eip
  1072                              <1> 
  1073 000008F5 90<rept>            <1> align 4
  1074                              <1> int_handler_bound :
  1075 000008F8 56                  <1>     push esi
  1076 000008F9 BE[F2050000]        <1>     mov  esi,int05msg
  1077 000008FE E865040000          <1>     call irq_print_msg
  1078 00000903 5E                  <1>     pop  esi
  1079 00000904 E98C000000          <1>     jmp  int_handler_show_eip
  1080                              <1> 
  1081 00000909 90<rept>            <1> align 4
  1082                              <1> int_handler_invop :
  1083 0000090C 56                  <1>     push esi
  1084 0000090D BE[02060000]        <1>     mov  esi,int06msg
  1085 00000912 E851040000          <1>     call irq_print_msg
  1086 00000917 5E                  <1>     pop  esi
  1087 00000918 EB7B                <1>     jmp  int_handler_show_eip
  1088                              <1> 
  1089 0000091A 90<rept>            <1> align 4
  1090                              <1> int_handler_devna :
  1091                              <1>     ;push esi
  1092                              <1>     ;mov  esi,int07msg
  1093                              <1>     ;call irq_print_msg
  1094                              <1>     ;pop  esi
  1095                              <1>     ; FIXME fxsave/fxrestore the fpu/sse/mmx regs
  1096 0000091C 0F06                <1>     clts                ; sure! you can use the fpu
  1097 0000091E CF                  <1>     iret
  1098                              <1> 
  1099 0000091F 90                  <1> align 4
  1100                              <1> int_handler_cpsego :
  1101 00000920 56                  <1>     push esi
  1102 00000921 BE[34060000]        <1>     mov  esi,int09msg
  1103 00000926 E83D040000          <1>     call irq_print_msg
  1104 0000092B 5E                  <1>     pop  esi
  1105 0000092C EB67                <1>     jmp  int_handler_show_eip
  1106                              <1> 
  1107 0000092E 90<rept>            <1> align 4
  1108                              <1> int_handler_segnp :
  1109                              <1>     ; ec = seg selector
  1110 00000930 56                  <1>     push esi
  1111 00000931 BE[5E060000]        <1>     mov  esi,int11msg
  1112 00000936 E82D040000          <1>     call irq_print_msg
  1113 0000093B 5E                  <1>     pop  esi
  1114 0000093C EB32                <1>     jmp  int_handler_show_ec_eip
  1115                              <1> 
  1116 0000093E 90<rept>            <1> align 4
  1117                              <1> int_handler_stkflt :
  1118                              <1>     ; ec = seg selector
  1119 00000940 56                  <1>     push esi
  1120 00000941 BE[73060000]        <1>     mov  esi,int12msg
  1121 00000946 E81D040000          <1>     call irq_print_msg
  1122 0000094B 5E                  <1>     pop  esi
  1123 0000094C B904000000          <1>     mov  ecx,4
  1124 00000951 83C302              <1>     add  ebx,2
  1125                              <1> int_handler_show_stack_loop :
  1126 00000954 58                  <1>     pop  eax
  1127 00000955 E84EFBFFFF          <1>     call putx_vga
  1128 0000095A E2F8                <1>     loop int_handler_show_stack_loop
  1129 0000095C E95B040000          <1>     jmp  reboot_on_alt_key
  1130                              <1> 
  1131 00000961 90<rept>            <1> align 4
  1132                              <1> int_handler_gpf :
  1133                              <1>     ; ec = various ...
  1134                              <1>     ;test dword [esp+0xc],1 << 17    ; check the eflags vm bit
  1135                              <1>     ;jnz  int_handler_vm_gpf
  1136                              <1> 
  1137 00000964 56                  <1>     push esi
  1138 00000965 BE[80060000]        <1>     mov  esi,int13msg
  1139 0000096A E8F9030000          <1>     call irq_print_msg
  1140 0000096F 5E                  <1>     pop  esi
  1141                              <1> int_handler_show_ec_eip :
  1142 00000970 65C60365            <1>     mov  byte [gs:ebx],'e'
  1143 00000974 83C302              <1>     add  ebx,2
  1144 00000977 65C60363            <1>     mov  byte [gs:ebx],'c'
  1145 0000097B 83C302              <1>     add  ebx,2
  1146 0000097E 65C6033D            <1>     mov  byte [gs:ebx],'='
  1147 00000982 83C302              <1>     add  ebx,2
  1148 00000985 58                  <1>     pop  eax                ; ec
  1149 00000986 E80DFBFFFF          <1>     call putbx_vga
  1150 0000098B 83EB02              <1>     sub  ebx,2
  1151 0000098E 65C60320            <1>     mov  byte [gs:ebx],' '
  1152 00000992 83C302              <1>     add  ebx,2
  1153                              <1> int_handler_show_eip :
  1154 00000995 65C60363            <1>     mov  byte [gs:ebx],'c'
  1155 00000999 83C302              <1>     add  ebx,2
  1156 0000099C 65C60373            <1>     mov  byte [gs:ebx],'s'
  1157 000009A0 83C302              <1>     add  ebx,2
  1158 000009A3 65C6033A            <1>     mov  byte [gs:ebx],':'
  1159 000009A7 83C302              <1>     add  ebx,2
  1160 000009AA 65C60365            <1>     mov  byte [gs:ebx],'e'
  1161 000009AE 83C302              <1>     add  ebx,2
  1162 000009B1 65C60369            <1>     mov  byte [gs:ebx],'i'
  1163 000009B5 83C302              <1>     add  ebx,2
  1164 000009B8 65C60370            <1>     mov  byte [gs:ebx],'p'
  1165 000009BC 83C302              <1>     add  ebx,2
  1166 000009BF 65C6033D            <1>     mov  byte [gs:ebx],'='
  1167 000009C3 83C302              <1>     add  ebx,2
  1168 000009C6 5A                  <1>     pop  edx                ; eip
  1169 000009C7 58                  <1>     pop  eax                ; cs
  1170 000009C8 E8DBFAFFFF          <1>     call putx_vga
  1171 000009CD 83EB02              <1>     sub  ebx,2
  1172 000009D0 65C6033A            <1>     mov  byte [gs:ebx],':'
  1173 000009D4 83C302              <1>     add  ebx,2
  1174 000009D7 89D0                <1>     mov  eax,edx
  1175 000009D9 E8CAFAFFFF          <1>     call putx_vga
  1176 000009DE E9D9030000          <1>     jmp  reboot_on_alt_key
  1177                              <1> 
  1178                              <1> int_handler_vm_gpf :
  1179 000009E3 53                  <1>     push ebx
  1180                              <1>     ;mov  ebx,[esp+8]        ; faulter's eip
  1181 000009E4 2E8A1B              <1>     mov  bl,[cs:ebx]        ; get the opcode that caused the fault
  1182 000009E7 80FBF4              <1>     cmp  bl,0xf4            ; 'hlt' is ok
  1183 000009EA 7452                <1>     jz   int_handler_vm_normal_return
  1184                              <1> 
  1185 000009EC 56                  <1>     push esi
  1186 000009ED 50                  <1>     push eax
  1187 000009EE 53                  <1>     push ebx
  1188 000009EF BE[D4070000]        <1>     mov  esi,intvmmsg
  1189 000009F4 E86F030000          <1>     call irq_print_msg
  1190 000009F9 65C6036F            <1>     mov  byte [gs:ebx],'o'
  1191 000009FD 83C302              <1>     add  ebx,2
  1192 00000A00 65C60370            <1>     mov  byte [gs:ebx],'p'
  1193 00000A04 83C302              <1>     add  ebx,2
  1194 00000A07 65C60363            <1>     mov  byte [gs:ebx],'c'
  1195 00000A0B 83C302              <1>     add  ebx,2
  1196 00000A0E 65C6036F            <1>     mov  byte [gs:ebx],'o'
  1197 00000A12 83C302              <1>     add  ebx,2
  1198 00000A15 65C60364            <1>     mov  byte [gs:ebx],'d'
  1199 00000A19 83C302              <1>     add  ebx,2
  1200 00000A1C 65C60365            <1>     mov  byte [gs:ebx],'e'
  1201 00000A20 83C302              <1>     add  ebx,2
  1202 00000A23 65C60328            <1>     mov  byte [gs:ebx],'('
  1203 00000A27 83C302              <1>     add  ebx,2
  1204 00000A2A 58                  <1>     pop  eax
  1205 00000A2B 25FF000000          <1>     and  eax,0xff
  1206 00000A30 E863FAFFFF          <1>     call putbx_vga
  1207 00000A35 83C302              <1>     add  ebx,2
  1208 00000A38 65C60329            <1>     mov  byte [gs:ebx],')'
  1209 00000A3C 58                  <1>     pop  eax
  1210 00000A3D 5E                  <1>     pop  esi
  1211                              <1> int_handler_vm_normal_return :
  1212 00000A3E 5B                  <1>     pop  ebx
  1213                              <1> 
  1214 00000A3F FF74240C            <1>     push dword [esp+0xc]    ; eflags
  1215 00000A43 9D                  <1>     popf                    ; restore the VM and NT flags
  1216 00000A44 CF                  <1>     iret                    ; chain back via nested task
  1217                              <1>                             ; from v86 tss to original caller
  1218                              <1> 
  1219 00000A45 90<rept>            <1> align 4
  1220                              <1> int_handler_pgflt :
  1221 00000A48 58                  <1>     pop  eax
  1222 00000A49 50                  <1>     push eax
  1223 00000A4A A904000000          <1>     test eax,0x4                        ; user mode or supervisor?
  1224 00000A4F 7407                <1>     jz   int_handler_pgflt_bad_kaddr    ; if not, kernel failed
  1225                              <1> 
  1226                              <1> int_handler_pgflt_bad_uaddr :
  1227 00000A51 BE[B2060000]        <1>     mov  esi,int14umsg
  1228 00000A56 EB05                <1>     jmp  int_handler_pgflt_msg
  1229                              <1> 
  1230                              <1> int_handler_pgflt_bad_kaddr :
  1231 00000A58 BE[9A060000]        <1>     mov  esi,int14kmsg
  1232                              <1> 
  1233                              <1> int_handler_pgflt_msg :
  1234 00000A5D E806030000          <1>     call irq_print_msg
  1235 00000A62 0F20D0              <1>     mov  eax,cr2
  1236 00000A65 E83EFAFFFF          <1>     call putx_vga                       ; print the addres of the fault
  1237 00000A6A E901FFFFFF          <1>     jmp  int_handler_show_ec_eip
  1238                              <1> 
  1239 00000A6F 90                  <1> align 4
  1240                              <1> int_handler_fpuerr :
  1241 00000A70 56                  <1>     push esi
  1242 00000A71 BE[C7060000]        <1>     mov  esi,int16msg
  1243 00000A76 E8ED020000          <1>     call irq_print_msg
  1244                              <1>     ; FIXME flags identify error
  1245                              <1>     ;   IS - FPU stack overflow
  1246                              <1>     ;   IA - Invalid arithmetic operation
  1247                              <1>     ;   Z  - Divide by zero
  1248                              <1>     ;   D  - Source operand is a denormal number
  1249                              <1>     ;   O  - Overflow in result
  1250                              <1>     ;   U  - Underflow in result
  1251                              <1>     ;   P  - Inexact result
  1252 00000A7B E915FFFFFF          <1>     jmp  int_handler_show_eip
  1253                              <1> 
  1254                              <1> align 4
  1255                              <1> int_handler_algnchk :
  1256                              <1>     ; ec = zero
  1257 00000A80 56                  <1>     push esi
  1258 00000A81 BE[DB060000]        <1>     mov  esi,int17msg
  1259 00000A86 E8DD020000          <1>     call irq_print_msg
  1260 00000A8B 5E                  <1>     pop  esi
  1261 00000A8C 58                  <1>     pop  eax                    ; toss the ec
  1262 00000A8D E903FFFFFF          <1>     jmp  int_handler_show_eip
  1263                              <1> 
  1264 00000A92 90<rept>            <1> align 4
  1265                              <1> int_handler_machchk :
  1266 00000A94 56                  <1>     push esi
  1267 00000A95 BE[EC060000]        <1>     mov  esi,int18msg
  1268 00000A9A E8C9020000          <1>     call irq_print_msg
  1269 00000A9F 5E                  <1>     pop  esi
  1270 00000AA0 E9F0FEFFFF          <1>     jmp  int_handler_show_eip
  1271                              <1> 
  1272 00000AA5 90<rept>            <1> align 4
  1273                              <1> int_handler_simdfpe :
  1274 00000AA8 56                  <1>     push esi
  1275 00000AA9 BE[FB060000]        <1>     mov  esi,int19msg
  1276 00000AAE E8B5020000          <1>     call irq_print_msg
  1277 00000AB3 5E                  <1>     pop  esi
  1278 00000AB4 E9DCFEFFFF          <1>     jmp  int_handler_show_eip
  1279                              <1> 
  1280                              <1> ; indicate that an irq has been serviced
  1281                              <1> display_irq :
  1282 00000AB9 50                  <1>     push eax
  1283 00000ABA 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
  1284 00000ABE 8EE8                <1>     mov  gs,ax          
  1285 00000AC0 88F8                <1>     mov  al,bh              ; display irq "number"
  1286 00000AC2 81E3FF000000        <1>     and  ebx,0xff
  1287 00000AC8 658803              <1>     mov  [gs:ebx],al
  1288 00000ACB 658A4301            <1>     mov  al,[gs:ebx+1]
  1289 00000ACF FEC0                <1>     inc  al
  1290 00000AD1 0C08                <1>     or   al,0x8             ; avoid black and dark colors
  1291 00000AD3 240F                <1>     and  al,0xf
  1292 00000AD5 65884301            <1>     mov  [gs:ebx+1],al      ; change character color
  1293 00000AD9 58                  <1>     pop  eax
  1294 00000ADA C3                  <1>     ret
  1295                              <1> 
  1296 00000ADB 90                  <1> align 4
  1297                              <1> int_handler_timer :     
  1298 00000ADC 53                  <1>     push ebx
  1299 00000ADD 66BB3C74            <1>     mov  bx,('t' << 8) + 30*2
  1300 00000AE1 E8D3FFFFFF          <1>     call display_irq
  1301 00000AE6 5B                  <1>     pop  ebx
  1302                              <1> 
  1303 00000AE7 50                  <1>     push eax
  1304                              <1> 
  1305                              <1>     ; ---- wakeup any sleeping cpus (see syscall_sleep)
  1306                              <1> 
  1307 00000AE8 A0[30030000]        <1>     mov  al,[enabled_lapic]
  1308 00000AED 08C0                <1>     or   al,al
  1309 00000AEF 741B                <1>     jz   no_sleepers
  1310                              <1> 
  1311                              <1>     ; the race here is not important, we'll catch them on the next tick
  1312                              <1> 
  1313 00000AF1 A1[1C030000]        <1>     mov  eax,[sleepers]
  1314 00000AF6 09C0                <1>     or   eax,eax
  1315 00000AF8 7412                <1>     jz   no_sleepers
  1316 00000AFA C1E018              <1>     shl  eax,24                     ; FIXME can only handle 8 cpus
  1317 00000AFD A31003E0FE          <1>     mov  dword [0xfee00310],eax     ; via the destination register ...
  1318 00000B02 B8FE480000          <1>     mov  eax,0x04800 + wakeup_int   ; no shrthnd, fixed, logical, edge
  1319 00000B07 A30003E0FE          <1>     mov  dword [0xfee00300],eax
  1320                              <1> 
  1321                              <1> no_sleepers :
  1322 00000B0C B020                <1>     mov  al,0x20        
  1323 00000B0E E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1324 00000B10 58                  <1>     pop  eax
  1325 00000B11 CF                  <1>     iret                
  1326                              <1> 
  1327 00000B12 90<rept>            <1> align 4
  1328                              <1> int_handler_kbd :
  1329 00000B14 53                  <1>     push ebx
  1330 00000B15 66BB3E6B            <1>     mov  bx,('k' << 8) + 31*2
  1331 00000B19 E89BFFFFFF          <1>     call display_irq
  1332 00000B1E 5B                  <1>     pop  ebx
  1333                              <1> 
  1334 00000B1F 50                  <1>     push eax
  1335                              <1> 
  1336 00000B20 53                  <1>     push ebx
  1337 00000B21 BB36000000          <1>     mov  ebx,27*2
  1338 00000B26 E460                <1>     in   al,0x60
  1339 00000B28 50                  <1>     push eax
  1340 00000B29 E86AF9FFFF          <1>     call putbx_vga
  1341 00000B2E 58                  <1>     pop  eax
  1342 00000B2F 5B                  <1>     pop  ebx
  1343                              <1> 
  1344 00000B30 3C53                <1>     cmp  al,0x53            ; scan code for the DEL key
  1345 00000B32 0F848A020000        <1>     jz   reboot
  1346                              <1> 
  1347 00000B38 B020                <1>     mov  al,0x20
  1348 00000B3A E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1349                              <1> 
  1350 00000B3C 58                  <1>     pop  eax
  1351 00000B3D CF                  <1>     iret
  1352                              <1> 
  1353 00000B3E 90<rept>            <1> align 4
  1354                              <1> int_handler_hw02 :          ; cascade
  1355 00000B40 53                  <1>     push ebx
  1356 00000B41 66BB4063            <1>     mov  bx,('c' << 8) + 32*2
  1357 00000B45 E86FFFFFFF          <1>     call display_irq
  1358 00000B4A 5B                  <1>     pop  ebx
  1359                              <1> 
  1360 00000B4B 56                  <1>     push esi
  1361 00000B4C BE[14070000]        <1>     mov  esi,int34msg
  1362 00000B51 E812020000          <1>     call irq_print_msg
  1363 00000B56 5E                  <1>     pop  esi
  1364 00000B57 E960020000          <1>     jmp  reboot_on_alt_key
  1365                              <1> 
  1366                              <1> align 4
  1367                              <1> int_handler_hw03 :          ; serial port 2
  1368 00000B5C 53                  <1>     push ebx
  1369 00000B5D 66BB4233            <1>     mov  bx,('3' << 8) + 33*2
  1370 00000B61 E853FFFFFF          <1>     call display_irq
  1371 00000B66 5B                  <1>     pop  ebx
  1372                              <1> 
  1373 00000B67 56                  <1>     push esi
  1374 00000B68 BE[1E070000]        <1>     mov  esi,int35msg
  1375 00000B6D E8F6010000          <1>     call irq_print_msg
  1376 00000B72 5E                  <1>     pop  esi
  1377 00000B73 E944020000          <1>     jmp  reboot_on_alt_key
  1378                              <1> 
  1379                              <1> align 4
  1380                              <1> int_handler_hw04 :          ; serial port 1
  1381 00000B78 53                  <1>     push ebx
  1382 00000B79 66BB4434            <1>     mov  bx,('4' << 8) + 34*2
  1383 00000B7D E837FFFFFF          <1>     call display_irq
  1384 00000B82 5B                  <1>     pop  ebx
  1385                              <1> 
  1386 00000B83 56                  <1>     push esi
  1387 00000B84 BE[28070000]        <1>     mov  esi,int36msg
  1388 00000B89 E8DA010000          <1>     call irq_print_msg
  1389 00000B8E 5E                  <1>     pop  esi
  1390 00000B8F E928020000          <1>     jmp  reboot_on_alt_key
  1391                              <1> 
  1392                              <1> align 4
  1393                              <1> int_handler_hw05 :          ; parallel port 2 or sound card
  1394 00000B94 53                  <1>     push ebx
  1395 00000B95 66BB4635            <1>     mov  bx,('5' << 8) + 35*2
  1396 00000B99 E81BFFFFFF          <1>     call display_irq
  1397 00000B9E 5B                  <1>     pop  ebx
  1398                              <1> 
  1399 00000B9F 56                  <1>     push esi
  1400 00000BA0 BE[32070000]        <1>     mov  esi,int37msg
  1401 00000BA5 E8BE010000          <1>     call irq_print_msg
  1402 00000BAA 5E                  <1>     pop  esi
  1403 00000BAB E90C020000          <1>     jmp  reboot_on_alt_key
  1404                              <1> 
  1405                              <1> align 4
  1406                              <1> int_handler_hw06 :          ; floppy disk controller
  1407 00000BB0 53                  <1>     push ebx
  1408 00000BB1 66BB4836            <1>     mov  bx,('6' << 8) + 36*2
  1409 00000BB5 E8FFFEFFFF          <1>     call display_irq
  1410 00000BBA 5B                  <1>     pop  ebx
  1411                              <1> 
  1412 00000BBB 56                  <1>     push esi
  1413 00000BBC BE[3C070000]        <1>     mov  esi,int38msg
  1414 00000BC1 E8A2010000          <1>     call irq_print_msg
  1415 00000BC6 5E                  <1>     pop  esi
  1416 00000BC7 E9F0010000          <1>     jmp  reboot_on_alt_key
  1417                              <1> 
  1418                              <1> align 4
  1419                              <1> int_handler_hw07 :          ; parallel port 1
  1420 00000BCC 53                  <1>     push ebx
  1421 00000BCD 66BB4A37            <1>     mov  bx,('7' << 8) + 37*2
  1422 00000BD1 E8E3FEFFFF          <1>     call display_irq
  1423 00000BD6 5B                  <1>     pop  ebx
  1424                              <1> 
  1425                              <1> ;   push esi                ; 7 seems to happen a lot on some boxes
  1426                              <1> ;   mov  esi,int39msg
  1427                              <1> ;   call irq_print_msg
  1428                              <1> ;   pop  esi
  1429 00000BD7 B020                <1>     mov  al,0x20
  1430 00000BD9 E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1431 00000BDB CF                  <1>     iret
  1432                              <1>     ;jmp  reboot_on_alt_key
  1433                              <1> 
  1434                              <1> align 4
  1435                              <1> int_handler_hw08 :          ; RTC
  1436 00000BDC 53                  <1>     push ebx
  1437 00000BDD 66BB4C38            <1>     mov  bx,('8' << 8) + 38*2
  1438 00000BE1 E8D3FEFFFF          <1>     call display_irq
  1439 00000BE6 5B                  <1>     pop  ebx
  1440                              <1> 
  1441 00000BE7 56                  <1>     push esi
  1442 00000BE8 BE[50070000]        <1>     mov  esi,int40msg
  1443 00000BED E876010000          <1>     call irq_print_msg
  1444 00000BF2 5E                  <1>     pop  esi
  1445 00000BF3 E9C4010000          <1>     jmp  reboot_on_alt_key
  1446                              <1> 
  1447                              <1> align 4
  1448                              <1> int_handler_hw09 :          ; acpi
  1449 00000BF8 53                  <1>     push ebx
  1450 00000BF9 66BB4E39            <1>     mov  bx,('9' << 8) + 39*2
  1451 00000BFD E8B7FEFFFF          <1>     call display_irq
  1452 00000C02 5B                  <1>     pop  ebx
  1453                              <1> 
  1454 00000C03 56                  <1>     push esi
  1455 00000C04 BE[5A070000]        <1>     mov  esi,int41msg
  1456 00000C09 E85A010000          <1>     call irq_print_msg
  1457 00000C0E 5E                  <1>     pop  esi
  1458 00000C0F E9A8010000          <1>     jmp  reboot_on_alt_key
  1459                              <1> 
  1460                              <1> align 4
  1461                              <1> int_handler_hw10 :
  1462 00000C14 53                  <1>     push ebx
  1463 00000C15 66BB5061            <1>     mov  bx,('a' << 8) + 40*2
  1464 00000C19 E89BFEFFFF          <1>     call display_irq
  1465 00000C1E 5B                  <1>     pop  ebx
  1466                              <1> 
  1467 00000C1F 56                  <1>     push esi
  1468 00000C20 BE[64070000]        <1>     mov  esi,int42msg
  1469 00000C25 E83E010000          <1>     call irq_print_msg
  1470 00000C2A 5E                  <1>     pop  esi
  1471 00000C2B E98C010000          <1>     jmp  reboot_on_alt_key
  1472                              <1> 
  1473                              <1> align 4
  1474                              <1> int_handler_hw11 :
  1475 00000C30 53                  <1>     push ebx
  1476 00000C31 66BB5262            <1>     mov  bx,('b' << 8) + 41*2
  1477 00000C35 E87FFEFFFF          <1>     call display_irq
  1478 00000C3A 5B                  <1>     pop  ebx
  1479                              <1> 
  1480 00000C3B 56                  <1>     push esi
  1481 00000C3C BE[6E070000]        <1>     mov  esi,int43msg
  1482 00000C41 E822010000          <1>     call irq_print_msg
  1483 00000C46 5E                  <1>     pop  esi
  1484 00000C47 E970010000          <1>     jmp  reboot_on_alt_key
  1485                              <1> 
  1486                              <1> align 4
  1487                              <1> int_handler_hw12 :          ; mouse
  1488 00000C4C 53                  <1>     push ebx
  1489 00000C4D 66BB5463            <1>     mov  bx,('c' << 8) + 42*2
  1490 00000C51 E863FEFFFF          <1>     call display_irq
  1491 00000C56 5B                  <1>     pop  ebx
  1492                              <1> 
  1493 00000C57 56                  <1>     push esi
  1494 00000C58 BE[78070000]        <1>     mov  esi,int44msg
  1495 00000C5D E806010000          <1>     call irq_print_msg
  1496 00000C62 5E                  <1>     pop  esi
  1497 00000C63 E954010000          <1>     jmp  reboot_on_alt_key
  1498                              <1> 
  1499                              <1> align 4
  1500                              <1> int_handler_hw13 :          ; co-processor
  1501 00000C68 53                  <1>     push ebx
  1502 00000C69 66BB5664            <1>     mov  bx,('d' << 8) + 43*2
  1503 00000C6D E847FEFFFF          <1>     call display_irq
  1504 00000C72 5B                  <1>     pop  ebx
  1505                              <1> 
  1506 00000C73 56                  <1>     push esi
  1507 00000C74 BE[82070000]        <1>     mov  esi,int45msg
  1508 00000C79 E8EA000000          <1>     call irq_print_msg
  1509 00000C7E 5E                  <1>     pop  esi
  1510 00000C7F E938010000          <1>     jmp  reboot_on_alt_key
  1511                              <1> 
  1512                              <1> align 4
  1513                              <1> int_handler_hw14 :          ; ata disk controller primary
  1514 00000C84 53                  <1>     push ebx
  1515 00000C85 66BB5865            <1>     mov  bx,('e' << 8) + 44*2
  1516 00000C89 E82BFEFFFF          <1>     call display_irq
  1517 00000C8E 5B                  <1>     pop  ebx
  1518                              <1> 
  1519 00000C8F 56                  <1>     push esi
  1520 00000C90 BE[8C070000]        <1>     mov  esi,int46msg
  1521 00000C95 E8CE000000          <1>     call irq_print_msg
  1522 00000C9A 5E                  <1>     pop  esi
  1523 00000C9B E91C010000          <1>     jmp  reboot_on_alt_key
  1524                              <1> 
  1525                              <1> align 4
  1526                              <1> int_handler_hw15 :          ; ata disk controller secondary
  1527 00000CA0 53                  <1>     push ebx
  1528 00000CA1 66BB5A66            <1>     mov  bx,('f' << 8) + 45*2
  1529 00000CA5 E80FFEFFFF          <1>     call display_irq
  1530 00000CAA 5B                  <1>     pop  ebx
  1531                              <1> 
  1532 00000CAB 56                  <1>     push esi
  1533 00000CAC BE[96070000]        <1>     mov  esi,int47msg
  1534 00000CB1 E8B2000000          <1>     call irq_print_msg
  1535 00000CB6 5E                  <1>     pop  esi
  1536 00000CB7 E900010000          <1>     jmp  reboot_on_alt_key
  1537                              <1> 
  1538                              <1> ; called via the double fault task
  1539                              <1> align 4
  1540                              <1> int_handler_tg_dblflt :
  1541 00000CBC 56                  <1>     push esi
  1542 00000CBD BE[26060000]        <1>     mov  esi,int08msg
  1543 00000CC2 E8A1000000          <1>     call irq_print_msg
  1544 00000CC7 5E                  <1>     pop  esi
  1545 00000CC8 E9EF000000          <1>     jmp  reboot_on_alt_key
  1546                              <1> 
  1547                              <1> ; called via the invalid tss task
  1548 00000CCD 90<rept>            <1> align 4
  1549                              <1> int_handler_tg_invtss :
  1550 00000CD0 56                  <1>     push esi
  1551 00000CD1 BE[51060000]        <1>     mov  esi,int10msg
  1552 00000CD6 E88D000000          <1>     call irq_print_msg
  1553 00000CDB 5E                  <1>     pop  esi
  1554                              <1>     ; FIXME need to go back to previous tss to get ec via that stack
  1555 00000CDC 83C302              <1>     add  ebx,2
  1556 00000CDF 58                  <1>     pop  eax                ; ec == invalid tss selector
  1557 00000CE0 E8C3F7FFFF          <1>     call putx_vga
  1558 00000CE5 E9D2000000          <1>     jmp  reboot_on_alt_key
  1559                              <1> 
  1560 00000CEA 90<rept>            <1> align 4
  1561                              <1> int_handler_spurious :
  1562 00000CEC 56                  <1>     push esi
  1563 00000CED BE[A0070000]        <1>     mov  esi,spuriousmsg
  1564 00000CF2 E871000000          <1>     call irq_print_msg
  1565 00000CF7 5E                  <1>     pop  esi
  1566 00000CF8 CF                  <1>     iret
  1567                              <1> 
  1568 00000CF9 90<rept>            <1> align 4
  1569                              <1> int_handler_apicerr :
  1570 00000CFC 56                  <1>     push esi
  1571 00000CFD BE[AE070000]        <1>     mov  esi,apicerrmsg
  1572 00000D02 E861000000          <1>     call irq_print_msg
  1573 00000D07 5E                  <1>     pop  esi
  1574 00000D08 CF                  <1>     iret
  1575                              <1> 
  1576                              <1> ; serves only to eoi the fixed ipi used for sleep wakeup
  1577 00000D09 90<rept>            <1> align 4
  1578                              <1> wakeup :
  1579 00000D0C 50                  <1>     push eax
  1580 00000D0D 31C0                <1>     xor  eax,eax
  1581 00000D0F A3B000E0FE          <1>     mov  [0xfee000b0],eax    ; lapic eoi
  1582 00000D14 58                  <1>     pop  eax
  1583 00000D15 CF                  <1>     iret
  1584                              <1> 
  1585                              <1> 
  1586 00000D16 90<rept>            <1> align 4
  1587                              <1> ; %if ($ >= 0x8000) bomb
  1588                              <1> sysent :
  1589 00000D18 3D00020000          <1>     cmp  eax,0x0200
  1590 00000D1D 0F84D5020000        <1>     jz   syscall_klog
  1591 00000D23 3D00100000          <1>     cmp  eax,0x1000
  1592 00000D28 0F84DF020000        <1>     jz   syscall_ncpus
  1593 00000D2E 3D00200000          <1>     cmp  eax,0x2000
  1594 00000D33 0F8439030000        <1>     jz   syscall_sleep
  1595 00000D39 3D00210000          <1>     cmp  eax,0x2100
  1596 00000D3E 0F84CF020000        <1>     jz   syscall_new_thread
  1597 00000D44 3D00270000          <1>     cmp  eax,0x2700
  1598 00000D49 0F8458030000        <1>     jz   syscall_request_pmem_access
  1599 00000D4F 3D00FE0000          <1>     cmp  eax,0xfe00
  1600 00000D54 0F84AD020000        <1>     jz   syscall_sipi_vector
  1601 00000D5A BE[BF070000]        <1>     mov  esi,int255msg
  1602 00000D5F E804000000          <1>     call irq_print_msg
  1603 00000D64 31C0                <1>     xor  eax,eax
  1604 00000D66 48                  <1>     dec  eax
  1605 00000D67 CF                  <1>     iret
  1606                              <1> 
  1607                              <1> 
  1608                              <1> ; ---- IRQ support code ---- 
  1609                              <1> 
  1610                              <1> irq_print_msg :
  1611 00000D68 B801000000          <1>     mov  eax,1
  1612 00000D6D 0FC105[E0070000]    <1>     xadd [irq_err_lno],eax
  1613 00000D74 50                  <1>     push eax                ; remember line number
  1614 00000D75 83E003              <1>     and  eax,0x3            ; only four lines
  1615 00000D78 40                  <1>     inc  eax                ; start with line 1
  1616 00000D79 BBA0000000          <1>     mov  ebx,160            ; vga line length
  1617 00000D7E 0FAFC3              <1>     imul eax,ebx
  1618 00000D81 89C3                <1>     mov  ebx,eax
  1619                              <1> 
  1620 00000D83 A0[30030000]        <1>     mov  al,[enabled_lapic]
  1621 00000D88 08C0                <1>     or   al,al
  1622 00000D8A 58                  <1>     pop  eax
  1623 00000D8B 742A                <1>     jz   skip_cpumsg
  1624                              <1> 
  1625 00000D8D 56                  <1>     push esi
  1626 00000D8E 50                  <1>     push eax
  1627 00000D8F BE[9E050000]        <1>     mov  esi,cpumsg
  1628 00000D94 E8E8F6FFFF          <1>     call puts_vga
  1629 00000D99 A12000E0FE          <1>     mov  eax,[0xfee00020]   ; print our apic id
  1630 00000D9E C1E818              <1>     shr  eax,24
  1631 00000DA1 83C030              <1>     add  eax,'0'
  1632 00000DA4 658803              <1>     mov  [gs:ebx],al
  1633 00000DA7 58                  <1>     pop  eax                ; recover line number
  1634 00000DA8 C0E802              <1>     shr  al,2               ; provide a rolling effect for
  1635 00000DAB 240F                <1>     and  al,0xf             ;     unending irq messages
  1636 00000DAD 0C08                <1>     or   al,0x8
  1637 00000DAF 65884301            <1>     mov  [gs:ebx+1],al
  1638 00000DB3 83C304              <1>     add  ebx,4
  1639 00000DB6 5E                  <1>     pop  esi
  1640                              <1> 
  1641                              <1> skip_cpumsg :
  1642 00000DB7 E9C5F6FFFF          <1>     jmp  puts_vga
  1643                              <1> 
  1644                              <1> 
  1645                              <1> reboot_on_alt_key :
  1646                              <1> reboot_on_alt_key_loop :
  1647 00000DBC E460                <1>     in   al,0x60
  1648 00000DBE 3C53                <1>     cmp  al,0x53            ; scan code for the DEL key
  1649 00000DC0 75FA                <1>     jnz  reboot_on_alt_key_loop
  1650                              <1> reboot :
  1651 00000DC2 0F011D[EE0D0000]    <1>     lidt [reboot_idt]       ; restore boot idt (helps qemu ...)
  1652 00000DC9 EA[D00D0000]2800    <1>     jmp  rmcssel:reboot_exit_pmode      ; thankyou hpa
  1653                              <1> reboot_exit_pmode :
  1654                              <1> bits 16
  1655 00000DD0 B83000              <1>     mov  ax,rmdssel
  1656 00000DD3 8ED8                <1>     mov  ds,ax
  1657 00000DD5 8EC0                <1>     mov  es,ax
  1658 00000DD7 8ED0                <1>     mov  ss,ax
  1659 00000DD9 8EE0                <1>     mov  fs,ax
  1660 00000DDB 8EE8                <1>     mov  gs,ax
  1661                              <1> 
  1662 00000DDD 0F20C0              <1>     mov  eax,cr0
  1663 00000DE0 6625FEFFFF7F        <1>     and  eax,0x7ffffffe
  1664 00000DE6 0F22C0              <1>     mov  cr0,eax            ; disable pmode and paging
  1665 00000DE9 EA0000FFFF          <1>     jmp  0xffff:0           ; jump to the warm start vector and
  1666                              <1>                             ; flush the I prefetch queue all at once
  1667                              <1> 
  1668                              <1> reboot_idt :
  1669 00000DEE FFFF                <1>     dw 0xffff
  1670 00000DF0 00000000            <1>     dd 0
  1671                              <1> 
  1672                              <1> 
  1673                              <1> ; ---- IDT initialization table ---- 
  1674                              <1> ;
  1675                              <1> ; One dw (2 bytes per vector) is used which means that all
  1676                              <1> ; int_handler entry points must reside below 0x10000!
  1677                              <1> ;
  1678                              <1> ; And since all int_handler routines are 4 byte aligned,
  1679                              <1> ; the bottom two bits are available to indicate type.
  1680                              <1> ; These bits index into the irq_types table below.
  1681                              <1> 
  1682                              <1> align 4
  1683                              <1> 
  1684                              <1> ; note: these are not gdt/ldt descriptors (see swdev3a 6.11 pg 228)
  1685                              <1> 
  1686 00000DF4 8E                  <1> irq_types   db  0x8e            ; dpl=0 32bit interrupt gate (sets IF flag)
  1687 00000DF5 EE                  <1>             db  0xee            ; dpl=3 32bit app (ring3) interrupt gate
  1688 00000DF6 85                  <1>             db  0x85            ; dpl=0 32bit task gate
  1689 00000DF7 8F                  <1>             db  0x8f            ; dpl=0 32bit trap gate (does not set IF flag)
  1690                              <1> 
  1691                              <1> ; all handlers/selectors are 4 byte aligned - this gives us
  1692                              <1> ; two bits to use to designate 1 of 4 types of idt descriptors ...
  1693                              <1> 
  1694                              <1> irqt_intr   equ 0
  1695                              <1> irqt_app    equ 1
  1696                              <1> irqt_task   equ 2
  1697                              <1> irqt_trap   equ 3
  1698                              <1> 
  1699                              <1> irq_setup_table:
  1700                              <1>     ; cpu defined
  1701 00000DF8 [9B08]              <1>     dw  int_handler_div0      + irqt_trap ; 0
  1702 00000DFA [AF08]              <1>     dw  int_handler_debug     + irqt_trap ; 1
  1703 00000DFC [C008]              <1>     dw  int_handler_nmi       + irqt_intr ; 2
  1704 00000DFE [D108]              <1>     dw  int_handler_brkp      + irqt_app  ; 3
  1705 00000E00 [E508]              <1>     dw  int_handler_ovrflw    + irqt_app  ; 4
  1706 00000E02 [F908]              <1>     dw  int_handler_bound     + irqt_app  ; 5
  1707 00000E04 [0F09]              <1>     dw  int_handler_invop     + irqt_trap ; 6
  1708 00000E06 [1F09]              <1>     dw  int_handler_devna     + irqt_trap ; 7
  1709 00000E08 4200                <1>     dw  tasksel_f08           + irqt_task ; 8   double fault
  1710 00000E0A [2309]              <1>     dw  int_handler_cpsego    + irqt_trap ; 9
  1711 00000E0C 4A00                <1>     dw  tasksel_f10           + irqt_task ; 10  invalid tss
  1712 00000E0E [3309]              <1>     dw  int_handler_segnp     + irqt_trap ; 11
  1713 00000E10 [4309]              <1>     dw  int_handler_stkflt    + irqt_trap ; 12
  1714 00000E12 [6709]              <1>     dw  int_handler_gpf       + irqt_trap ; 13
  1715 00000E14 [480A]              <1>     dw  int_handler_pgflt     + irqt_intr ; 14
  1716 00000E16 0000                <1>     dw  0                                 ; 15  Intel reserved
  1717 00000E18 [730A]              <1>     dw  int_handler_fpuerr    + irqt_trap ; 16
  1718 00000E1A [830A]              <1>     dw  int_handler_algnchk   + irqt_trap ; 17
  1719 00000E1C [970A]              <1>     dw  int_handler_machchk   + irqt_trap ; 18
  1720 00000E1E [AB0A]              <1>     dw  int_handler_simdfpe   + irqt_trap ; 19
  1721 00000E20 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0
  1722 00000E29 000000000000000000- <1>
  1723 00000E32 000000000000        <1>
  1724                              <1>     ; hw defined
  1725                              <1> apic0_irqbase equ ($ - irq_setup_table)/2
  1726 00000E38 [DC0A]              <1>     dw  int_handler_timer     + irqt_intr ; 32  0x20
  1727 00000E3A [140B]              <1>     dw  int_handler_kbd       + irqt_intr ; 33
  1728 00000E3C [400B]              <1>     dw  int_handler_hw02      + irqt_intr ; 34
  1729 00000E3E [5C0B]              <1>     dw  int_handler_hw03      + irqt_intr ; 35
  1730 00000E40 [780B]              <1>     dw  int_handler_hw04      + irqt_intr ; 36
  1731 00000E42 [940B]              <1>     dw  int_handler_hw05      + irqt_intr ; 37
  1732 00000E44 [B00B]              <1>     dw  int_handler_hw06      + irqt_intr ; 38
  1733 00000E46 [CC0B]              <1>     dw  int_handler_hw07      + irqt_intr ; 39
  1734                              <1> apic1_irqbase equ ($ - irq_setup_table)/2
  1735 00000E48 [DC0B]              <1>     dw  int_handler_hw08      + irqt_intr ; 40
  1736 00000E4A [F80B]              <1>     dw  int_handler_hw09      + irqt_intr ; 41
  1737 00000E4C [140C]              <1>     dw  int_handler_hw10      + irqt_intr ; 42
  1738 00000E4E [300C]              <1>     dw  int_handler_hw11      + irqt_intr ; 43
  1739 00000E50 [4C0C]              <1>     dw  int_handler_hw12      + irqt_intr ; 44
  1740 00000E52 [680C]              <1>     dw  int_handler_hw13      + irqt_intr ; 45
  1741 00000E54 [840C]              <1>     dw  int_handler_hw14      + irqt_intr ; 46
  1742 00000E56 [A00C]              <1>     dw  int_handler_hw15      + irqt_intr ; 47  0x2f
  1743                              <1>     ; undefined - hw can expand here
  1744 00000E58 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x30
  1745 00000E61 000000000000000000- <1>
  1746 00000E6A 000000000000000000- <1>
  1747 00000E73 0000000000          <1>
  1748 00000E78 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x40
  1749 00000E81 000000000000000000- <1>
  1750 00000E8A 000000000000000000- <1>
  1751 00000E93 0000000000          <1>
  1752 00000E98 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x50
  1753 00000EA1 000000000000000000- <1>
  1754 00000EAA 000000000000000000- <1>
  1755 00000EB3 0000000000          <1>
  1756 00000EB8 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x60
  1757 00000EC1 000000000000000000- <1>
  1758 00000ECA 000000000000000000- <1>
  1759 00000ED3 0000000000          <1>
  1760 00000ED8 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x70
  1761 00000EE1 000000000000000000- <1>
  1762 00000EEA 000000000000000000- <1>
  1763 00000EF3 0000000000          <1>
  1764 00000EF8 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x80
  1765 00000F01 000000000000000000- <1>
  1766 00000F0A 000000000000000000- <1>
  1767 00000F13 0000000000          <1>
  1768 00000F18 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x90
  1769 00000F21 000000000000000000- <1>
  1770 00000F2A 000000000000000000- <1>
  1771 00000F33 0000000000          <1>
  1772 00000F38 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xa0
  1773 00000F41 000000000000000000- <1>
  1774 00000F4A 000000000000000000- <1>
  1775 00000F53 0000000000          <1>
  1776                              <1>     ; set up cpu thread management tss gates
  1777                              <1>     ; these map 1-to-1 to cpus
  1778                              <1> first_thread_tss_gate equ ($ - irq_setup_table)/2
  1779 00000F58 5A00                <1>     dw  tasksel_u00           + irqt_task
  1780 00000F5A 6A00                <1>     dw  tasksel_u01           + irqt_task
  1781 00000F5C 7A00                <1>     dw  tasksel_u02           + irqt_task
  1782 00000F5E 8A00                <1>     dw  tasksel_u03           + irqt_task
  1783 00000F60 9A00                <1>     dw  tasksel_u04           + irqt_task
  1784 00000F62 AA00                <1>     dw  tasksel_u05           + irqt_task
  1785 00000F64 BA00                <1>     dw  tasksel_u06           + irqt_task
  1786 00000F66 CA00                <1>     dw  tasksel_u07           + irqt_task
  1787                              <1> %ifdef FOO
  1788                              <1>     dw  tasksel_u08           + irqt_task
  1789                              <1>     dw  tasksel_u09           + irqt_task
  1790                              <1>     dw  tasksel_u10           + irqt_task
  1791                              <1>     dw  tasksel_u11           + irqt_task
  1792                              <1>     dw  tasksel_u12           + irqt_task
  1793                              <1>     dw  tasksel_u13           + irqt_task
  1794                              <1>     dw  tasksel_u14           + irqt_task
  1795                              <1>     dw  tasksel_u15           + irqt_task
  1796                              <1> %endif
  1797 00000F68 000000000000000000- <1>     dw                  0,0,0,0,0,0,0,0   ; 0xb0
  1798 00000F71 00000000000000      <1>
  1799 00000F78 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xc0
  1800 00000F81 000000000000000000- <1>
  1801 00000F8A 000000000000000000- <1>
  1802 00000F93 0000000000          <1>
  1803 00000F98 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xd0
  1804 00000FA1 000000000000000000- <1>
  1805 00000FAA 000000000000000000- <1>
  1806 00000FB3 0000000000          <1>
  1807 00000FB8 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     ; 0xe0
  1808 00000FC1 000000000000000000- <1>
  1809 00000FCA 000000000000000000- <1>
  1810 00000FD3 000000              <1>
  1811                              <1> spurious_int equ ($ - irq_setup_table)/2
  1812 00000FD6 [EC0C]              <1>     dw  int_handler_spurious  + irqt_intr
  1813                              <1> apicerr_int equ ($ - irq_setup_table)/2
  1814 00000FD8 [FD0C]              <1>     dw  int_handler_apicerr   + irqt_app
  1815 00000FDA 000000000000000000- <1>     dw    0,0,0,0,0,0,0,0,0,0,0,0,0       ; 0xf0
  1816 00000FE3 000000000000000000- <1>
  1817 00000FEC 0000000000000000    <1>
  1818                              <1>     ; sw defined - expand down if needed
  1819                              <1> wakeup_int equ ($ - irq_setup_table)/2
  1820 00000FF4 [0D0D]              <1>     dw  wakeup                + irqt_app
  1821 00000FF6 [190D]              <1>     dw  sysent                + irqt_app  ; 256  0xff
  1822                              <1> irq_setup_table_size equ ($ - irq_setup_table)/2
  1823                              <1> 
  1824                                  
  1825                                  ; -------- system calls --------
  1826                                  %include "ozsys.asm"
  1827                              <1> ; OZ - A more utopian OS    x86-32 system calls
  1828                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
  1829                              <1> ;
  1830                              <1> ; Copyright (C) 2015  Duane Voth
  1831                              <1> ;
  1832                              <1> ;   This program is free software: you can redistribute it and/or modify
  1833                              <1> ;   it under the terms of the GNU Affero General Public License as
  1834                              <1> ;   published by the Free Software Foundation, either version 3 of the
  1835                              <1> ;   License, or (at your option) any later version.
  1836                              <1> ;
  1837                              <1> ;   This program is distributed in the hope that it will be useful,
  1838                              <1> ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
  1839                              <1> ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1840                              <1> ;   GNU Affero General Public License for more details.
  1841                              <1> ;
  1842                              <1> ;   You should have received a copy of the GNU Affero General Public License
  1843                              <1> ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
  1844                              <1> ;
  1845                              <1> ;
  1846                              <1> ; OZ System Calls  (for ozapps)
  1847                              <1> 
  1848                              <1> bits 32
  1849                              <1> 
  1850                              <1> ;------------------------------------------------------------------
  1851                              <1> ;   syscall_klog : place a message on the vga line reserved for klog  :D
  1852                              <1> ;
  1853                              <1> ;   entry:
  1854                              <1> ;       esi = message address
  1855                              <1> ;   exit:
  1856                              <1> 
  1857                              <1> syscall_klog :
  1858 00000FF8 53                  <1>     push ebx
  1859 00000FF9 BB20030000          <1>     mov  ebx,5 * 160        ; line 6
  1860 00000FFE E87EF4FFFF          <1>     call puts_vga
  1861 00001003 5B                  <1>     pop  ebx
  1862 00001004 31C0                <1>     xor  eax,eax
  1863 00001006 CF                  <1>     iret
  1864                              <1> 
  1865                              <1> ;------------------------------------------------------------------
  1866                              <1> ;   syscall_sipi_vector : get the entry vector for non-boot cpus
  1867                              <1> ;
  1868                              <1> ;   entry:
  1869                              <1> ;   exit:
  1870                              <1> ;       eax = N cpus
  1871                              <1> 
  1872                              <1> syscall_sipi_vector :
  1873 00001007 B800700000          <1>     mov  eax,sipi_vector
  1874 0000100C CF                  <1>     iret
  1875                              <1> 
  1876                              <1> ;------------------------------------------------------------------
  1877                              <1> ;   syscall_ncpus : get how many cpu threads are running
  1878                              <1> ;
  1879                              <1> ;   entry:
  1880                              <1> ;   exit:
  1881                              <1> ;       eax = N cpus
  1882                              <1> 
  1883                              <1> syscall_ncpus :
  1884 0000100D A1[14030000]        <1>     mov  eax,[ncpus]
  1885 00001012 CF                  <1>     iret
  1886                              <1> 
  1887                              <1> ;------------------------------------------------------------------
  1888                              <1> ;   syscall_new_thread : ask for another cpu to execute code in
  1889                              <1> ;                        the current app
  1890                              <1> ;
  1891                              <1> ;   This implementation is quite a bit of a hack - apps can basically
  1892                              <1> ;   commendere any specific non-boot cpu they want ...
  1893                              <1> ;
  1894                              <1> ;   entry:
  1895                              <1> ;       edx = function start address in the app
  1896                              <1> ;       ecx = address of the top of the app's new thread stack
  1897                              <1> ;       ebx = app's new thread index
  1898                              <1> ;   exit:
  1899                              <1> ;       eax = 0 success, -1 failure
  1900                              <1> 
  1901                              <1> syscall_new_thread :
  1902 00001013 09DB                <1>     or   ebx,ebx
  1903 00001015 7459                <1>     jz   new_thread_fail        ; don't get to ask for cpu 0
  1904                              <1> 
  1905 00001017 31C0                <1>     xor  eax,eax
  1906 00001019 A0[30030000]        <1>     mov  al,[enabled_lapic]     ; if the lapics are not enabled,
  1907 0000101E 08C0                <1>     or   al,al                  ; none of this is useful
  1908 00001020 744E                <1>     jz   new_thread_fail
  1909                              <1> 
  1910                              <1>     ; setup the tss
  1911                              <1>     ; slightly squirly - get the tss address from the task selector
  1912                              <1>     ; but there could be a race here: ncpus is updated before
  1913                              <1>     ; create_tss_pair is called, so the task selector could be zero!
  1914                              <1> 
  1915 00001022 89DF                <1>     mov  edi,ebx
  1916 00001024 C1E704              <1>     shl  edi,4                  ; 8 byte selectors in pairs
  1917 00001027 83C758              <1>     add  edi,tasksel_u00
  1918 0000102A 8BB7[02000000]      <1>     mov  esi,[gdt+edi+2]
  1919 00001030 81E6FFFFFF00        <1>     and  esi,0xffffff
  1920 00001036 31C0                <1>     xor  eax,eax
  1921 00001038 8A87[07000000]      <1>     mov  al,[gdt+edi+7]
  1922 0000103E C1E018              <1>     shl  eax,24
  1923 00001041 09C6                <1>     or   esi,eax
  1924 00001043 742B                <1>     jz   new_thread_fail        ; cpu isn't yet ready ...
  1925                              <1> 
  1926                              <1>     ; really should check the previous task link to see if this
  1927                              <1>     ; cpu is busy ...
  1928                              <1> 
  1929 00001045 894E38              <1>     mov  [esi+(tss0_esp-tss0)],ecx  ; set the app's stack
  1930 00001048 895620              <1>     mov  [esi+(tss0_eip-tss0)],edx  ; set the ip to the entry point
  1931                              <1> 
  1932                              <1>     ; lookup the requested cpu's int/taskgate gdt selector
  1933                              <1> 
  1934 0000104B 89DF                <1>     mov  edi,ebx
  1935 0000104D 81C7B0000000        <1>     add  edi,first_thread_tss_gate  ; convert ebx to int/taskgate number
  1936                              <1> 
  1937                              <1>     ; ipi a cpu.  no fancy affinity scheduling yet,
  1938                              <1>     ; just let the app ask for a specific cpu to do the work
  1939                              <1> 
  1940 00001053 B800000001          <1>     mov  eax,0x01000000
  1941 00001058 89D9                <1>     mov  ecx,ebx                    ; recover requested cpu number
  1942 0000105A D3E0                <1>     shl  eax,cl                     ; form the icr destination field
  1943                              <1> 
  1944                              <1>     ; poke the cpu that matches our thread index - we only get 8 :/
  1945                              <1> 
  1946 0000105C A31003E0FE          <1>     mov  dword [0xfee00310],eax
  1947 00001061 B800480000          <1>     mov  eax,0x4800                 ; no shorthand, fixed, logical, edge
  1948 00001066 09F8                <1>     or   eax,edi                    ; make int/taskgate number the vector
  1949 00001068 A30003E0FE          <1>     mov  dword [0xfee00300],eax
  1950                              <1> 
  1951 0000106D 31C0                <1>     xor  eax,eax
  1952 0000106F CF                  <1>     iret
  1953                              <1> 
  1954                              <1> new_thread_fail :
  1955 00001070 48                  <1>     dec  eax                    ; -1
  1956 00001071 C3                  <1>     ret
  1957                              <1> 
  1958                              <1> ;------------------------------------------------------------------
  1959                              <1> ;   syscall_sleep : wait for N timer interrupts
  1960                              <1> ;
  1961                              <1> ;   entry:
  1962                              <1> ;       edx = N ticks
  1963                              <1> ;   exit:
  1964                              <1> 
  1965                              <1> syscall_sleep :
  1966 00001072 A0[30030000]        <1>     mov  al,[enabled_lapic]
  1967 00001077 08C0                <1>     or   al,al
  1968 00001079 7415                <1>     jz   sleep_loop
  1969                              <1> 
  1970 0000107B A12000E0FE          <1>     mov  eax,[0xfee00020]
  1971 00001080 C1E818              <1>     shr  eax,24
  1972 00001083 09C0                <1>     or   eax,eax
  1973 00001085 7409                <1>     jz   sleep_loop         ; the boot cpu services the timer int
  1974 00001087 88C1                <1>     mov  cl,al              ; so don't add it to the sleeper list
  1975 00001089 B801000000          <1>     mov  eax,1
  1976 0000108E D3E0                <1>     shl  eax,cl
  1977                              <1> 
  1978                              <1> sleep_loop :
  1979 00001090 F00905[1C030000]    <1>     lock or [sleepers],eax  ; announce we are sleeping
  1980 00001097 FB                  <1>     sti
  1981 00001098 F4                  <1>     hlt                     ; wait for an int to wake us up
  1982 00001099 4A                  <1>     dec  edx                ; decrement the tick count
  1983 0000109A 75F4                <1>     jnz  sleep_loop
  1984                              <1> 
  1985 0000109C 83F0FF              <1>     xor  eax,-1
  1986 0000109F F02105[1C030000]    <1>     lock and [sleepers],eax ; renounce sleepiness
  1987 000010A6 CF                  <1>     iret
  1988                              <1> 
  1989                              <1> ;------------------------------------------------------------------
  1990                              <1> ;   syscall_request_pmem_access : ask for access to a physical
  1991                              <1> ;            memory address
  1992                              <1> ;
  1993                              <1> ;   entry:
  1994                              <1> ;       edx = phys memory address
  1995                              <1> ;
  1996                              <1> ;   exit:
  1997                              <1> ;       (need to return a logical address in eax)  For now just
  1998                              <1> ;       direct maps the physical address into logical addr space.
  1999                              <1> 
  2000                              <1> syscall_request_pmem_access :
  2001 000010A7 E801000000          <1>     call map_pmem
  2002 000010AC CF                  <1>     iret
  2003                              <1> 
  2004                              <1> ;------------------------------------------------------------------
  2005                              <1> ;   map_pmem - add entries to the current page directory/table
  2006                              <1> ;              to direct map the requested physical memory address
  2007                              <1> ;              (logical identical to physical for now)
  2008                              <1> ;
  2009                              <1> ;   entry:
  2010                              <1> ;       edx = phys memory address
  2011                              <1> ;
  2012                              <1> ;   returns:
  2013                              <1> ;       (need to return a logical address in eax)  For now just
  2014                              <1> ;       direct maps the physical address into logical addr space.
  2015                              <1> ;       eax =  0 success
  2016                              <1> ;       eax = -1 fail
  2017                              <1> 
  2018                              <1> map_pmem :
  2019 000010AD 53                  <1>     push ebx
  2020 000010AE 57                  <1>     push edi
  2021                              <1> 
  2022 000010AF 0F013A              <1>     invlpg [edx]
  2023 000010B2 52                  <1>     push edx
  2024 000010B3 0F20DB              <1>     mov  ebx,cr3
  2025 000010B6 81E300F0FFFF        <1>     and  ebx,0xfffff000
  2026 000010BC 89D7                <1>     mov  edi,edx
  2027 000010BE 81E70000C0FF        <1>     and  edi,0xffc00000
  2028 000010C4 C1EF14              <1>     shr  edi,(22 - 2)           ; calc page directory index
  2029 000010C7 81E200F03F00        <1>     and  edx,0x003ff000
  2030 000010CD C1EA0A              <1>     shr  edx,(12 - 2)           ; calc page table index
  2031                              <1> 
  2032 000010D0 8B043B              <1>     mov  eax,[ebx+edi]
  2033 000010D3 09C0                <1>     or   eax,eax                ; is there a page table here?
  2034 000010D5 750F                <1>     jnz  map_pmem_have_pgtbl
  2035 000010D7 E8F7F3FFFF          <1>     call mem_alloc_kernel_page
  2036 000010DC 09C0                <1>     or   eax,eax
  2037 000010DE 741F                <1>     jz   map_pmem_fail
  2038 000010E0 C1E00C              <1>     shl  eax,12                 ; convert pgno to pgtbl entry
  2039 000010E3 89043B              <1>     mov  [ebx+edi],eax          ; update page table
  2040                              <1> 
  2041                              <1> map_pmem_have_pgtbl :
  2042                              <1>     ; for now, no security check, just direct map the address
  2043                              <1>     ; and mark the pages and the page table r/w by all
  2044 000010E6 830C3B07            <1>     or   dword [ebx+edi],7      ; user, r/w, present
  2045                              <1> 
  2046 000010EA 8B1C3B              <1>     mov  ebx,[ebx+edi]
  2047 000010ED 81E300F0FFFF        <1>     and  ebx,0xfffff000
  2048 000010F3 58                  <1>     pop  eax                    ; recover requested phys mem addr
  2049                              <1>     ; FIXME yup, big security hole if called by ring 0! And it is ...
  2050 000010F4 83C807              <1>     or   eax,7                  ; user, r/w, present
  2051 000010F7 890413              <1>     mov  [ebx+edx],eax          ; update page directory
  2052 000010FA 31C0                <1>     xor  eax,eax                ; 0
  2053                              <1> map_pmem_exit :
  2054 000010FC 5F                  <1>     pop  edi
  2055 000010FD 5B                  <1>     pop  ebx
  2056 000010FE C3                  <1>     ret
  2057                              <1> 
  2058                              <1> map_pmem_fail :
  2059 000010FF 48                  <1>     dec  eax                    ; -1
  2060 00001100 EBFA                <1>     jmp  map_pmem_exit
  2061                              <1> 
  2062                                  
  2063 00001102 00<rept>                align 16, db 0
  2064                                  kernel_text_size equ ($-textstart)
  2065                                  
  2066                                  ; ---------------------------------------------------------------------------
  2067                                  section .data
  2068                                  datastart :
  2069                                  
  2070                                  ; -------- descriptors --------------
  2071                                  ; Intel SW dev manual 3a, 3.4.5, pg 103
  2072                                  ;
  2073                                  ; In my opinion, macros for descriptor entries
  2074                                  ; don't make the code that much more readable.
  2075                                  
  2076                                  descriptor_size equ 8
  2077                                  
  2078                                  gdt :
  2079                                  nullsel equ $-gdt           ; nullsel = 0h
  2080 00000000 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
  2081                                  
  2082                                  codesel equ $-gdt           ; codesel = 8h  4Gb flat over all logical mem
  2083 00000008 FFFF                        dw 0xffff               ; limit 0-15
  2084 0000000A 0000                        dw 0x0000               ; base  0-15
  2085 0000000C 00                          db 0x00                 ; base 16-23
  2086 0000000D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  2087 0000000E CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  2088 0000000F 00                          db 0x00                 ; base 24-31
  2089                                  
  2090                                  datasel equ $-gdt           ; datasel = 10h  4Gb flat over all logical mem
  2091 00000010 FFFF                        dw 0xffff               ; limit 0-15
  2092 00000012 0000                        dw 0x0000               ; base  0-15
  2093 00000014 00                          db 0x00                 ; base 16-23
  2094 00000015 92                          db 0x92                 ; present, dpl=0, data r/w
  2095 00000016 CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  2096 00000017 00                          db 0x00                 ; base 24-31
  2097                                  
  2098                                  stacksel equ $-gdt          ; stacksel = 18h  small limited stack
  2099 00000018 FF1F                        dw kstack_size-1        ; limit
  2100 0000001A 0010                        dw kstack_loc           ; base
  2101 0000001C 00                          db 0
  2102 0000001D 92                          db 0x92                 ; present, dpl=0, data, r/w
  2103 0000001E 40                          db 0x40                 ; byte granular, 32bit/8bit
  2104 0000001F 00                          db 0
  2105                                  
  2106                                  videosel equ $-gdt          ; videosel = 20h
  2107 00000020 9F0F                        dw 3999                 ; limit 80*25*2-1
  2108 00000022 0080                        dw 0x8000               ; base 0xb8000
  2109 00000024 0B                          db 0x0b
  2110 00000025 92                          db 0x92                 ; present, dpl=0, data, r/w
  2111 00000026 40                          db 0x40                 ; byte granular, 32bit/8bit
  2112 00000027 00                          db 0
  2113                                  
  2114                                  rmcssel equ $-gdt           ; real mode CS selector = 28h
  2115 00000028 FFFF                        dw 0xffff               ; limit 0-15
  2116 0000002A 0000                        dw 0x0000               ; base  0-15
  2117 0000002C 00                          db 0x00                 ; base 16-23
  2118 0000002D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  2119 0000002E 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  2120 0000002F 00                          db 0x00                 ; base 24-31
  2121                                  
  2122                                  rmdssel equ $-gdt           ; real mode DS selector = 30h
  2123 00000030 FFFF                        dw 0xffff               ; limit 0-15
  2124 00000032 0000                        dw 0x0000               ; base  0-15
  2125 00000034 00                          db 0x00                 ; base 16-23
  2126 00000035 92                          db 0x92                 ; present, dpl=0, data r/w
  2127 00000036 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  2128 00000037 00                          db 0x00                 ; base 24-31
  2129                                  
  2130                                  ldtsel1 equ $-gdt
  2131 00000038 1800                        dw ldt1_len             ; length of the ldt
  2132 0000003A [5001]                      dw ldt1                 ; address of the ldt
  2133 0000003C 00                          db 0
  2134 0000003D 82                          db 0x82                 ; present, dpl=0, ldt
  2135 0000003E 40                          db 0x40                 ; byte granular, 32bit/8bit
  2136 0000003F 00                          db 0
  2137                                  
  2138                                  tasksel_f08 equ $-gdt       ; the double fault task selector
  2139 00000040 6800                        dw tss_len              ; tss length
  2140 00000042 [6801]                      dw tss_f08              ; tss physical address
  2141 00000044 00                          db 0
  2142 00000045 89                          db 0x89                 ; present, dpl=0, tss32
  2143 00000046 40                          db 0x40                 ; byte granular, 32bit/8bit
  2144 00000047 00                          db 0
  2145                                  
  2146                                  tasksel_f10 equ $-gdt       ; the invalid tss task selector
  2147 00000048 6800                        dw tss_len              ; tss length
  2148 0000004A [D001]                      dw tss_f10              ; tss physical address
  2149 0000004C 00                          db 0
  2150 0000004D 89                          db 0x89                 ; present, dpl=0, tss32
  2151 0000004E 40                          db 0x40                 ; byte granular, 32bit/8bit
  2152 0000004F 00                          db 0
  2153                                  
  2154                                  ; there is one kernel thread tss (ring 0) and one user thread tss (ring 1)
  2155                                  ; per cpu.  memory for tss structs for the non-boot cpus are allocated as
  2156                                  ; each non-boot cpu comes online (see create_tss_pair).  tasksel_uXX tss
  2157                                  ; gates are installed in the idt (starting at first_thread_tss_gate),
  2158                                  ; they also map 1-to-1 with cpus.  (the thread is launched via an lapic
  2159                                  ; vectored interrupt that jumps immediately into user space - and to call a
  2160                                  ; task gate from an interrupt requires an existing ring 0 tss to be active)
  2161                                  ; tasksel_uXX tsses are initialized in new_thread.
  2162                                  
  2163                                  tasksel_k00 equ $-gdt
  2164 00000050 6800[3802]00894000                              dw tss_len, tss0, 0x8900, 0x40
  2165                                  tasksel_u00 equ $-gdt
  2166 00000058 6800[A002]00894000                              dw tss_len, tss1, 0x8900, 0x40
  2167                                  tasksel_k01 equ $-gdt
  2168 00000060 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2169                                  tasksel_u01 equ $-gdt
  2170 00000068 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2171                                  tasksel_k02 equ $-gdt
  2172 00000070 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2173                                  tasksel_u02 equ $-gdt
  2174 00000078 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2175                                  tasksel_k03 equ $-gdt
  2176 00000080 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2177                                  tasksel_u03 equ $-gdt
  2178 00000088 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2179                                  tasksel_k04 equ $-gdt
  2180 00000090 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2181                                  tasksel_u04 equ $-gdt
  2182 00000098 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2183                                  tasksel_k05 equ $-gdt
  2184 000000A0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2185                                  tasksel_u05 equ $-gdt
  2186 000000A8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2187                                  tasksel_k06 equ $-gdt
  2188 000000B0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2189                                  tasksel_u06 equ $-gdt
  2190 000000B8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2191                                  tasksel_k07 equ $-gdt
  2192 000000C0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2193                                  tasksel_u07 equ $-gdt
  2194 000000C8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2195                                  tasksel_k08 equ $-gdt
  2196 000000D0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2197                                  tasksel_u08 equ $-gdt
  2198 000000D8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2199                                  tasksel_k09 equ $-gdt
  2200 000000E0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2201                                  tasksel_u09 equ $-gdt
  2202 000000E8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2203                                  tasksel_k10 equ $-gdt
  2204 000000F0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2205                                  tasksel_u10 equ $-gdt
  2206 000000F8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2207                                  tasksel_k11 equ $-gdt
  2208 00000100 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2209                                  tasksel_u11 equ $-gdt
  2210 00000108 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2211                                  tasksel_k12 equ $-gdt
  2212 00000110 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2213                                  tasksel_u12 equ $-gdt
  2214 00000118 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2215                                  tasksel_k13 equ $-gdt
  2216 00000120 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2217                                  tasksel_u13 equ $-gdt
  2218 00000128 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2219                                  tasksel_k14 equ $-gdt
  2220 00000130 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2221                                  tasksel_u14 equ $-gdt
  2222 00000138 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2223                                  tasksel_k15 equ $-gdt
  2224 00000140 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2225                                  tasksel_u15 equ $-gdt
  2226 00000148 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2227                                  
  2228                                  max_threads equ ($-gdt-tasksel_k00)/descriptor_size/2
  2229                                  
  2230                                  gdt_end :
  2231                                  
  2232                                  ; ---------------------
  2233                                  
  2234                                  ldt1 :
  2235                                  nullsel1 equ $-ldt1         ; nullsel1 = 07h
  2236 00000150 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
  2237                                  
  2238                                  codesel1 equ $-ldt1         ; codesel1 = 0fh  4Gb flat over all logical mem
  2239 00000158 FFFF                        dw 0xffff               ; limit 0-15
  2240 0000015A 0000                        dw 0x0000               ; base  0-15
  2241 0000015C 00                          db 0x00                 ; base 16-23
  2242 0000015D FA                          db 0xfa                 ; present, dpl=3, code e/r
  2243 0000015E CF                          db 0xcf                 ; 4k granular, 32bit, limit 16-19
  2244 0000015F 00                          db 0x00                 ; base 24-31
  2245                                  
  2246                                  datasel1 equ $-ldt1         ; datasel1 = 17h  4Gb flat over all logical mem
  2247 00000160 FFFF                        dw 0xffff               ; limit 0-15
  2248 00000162 0000                        dw 0x0000               ; base  0-15
  2249 00000164 00                          db 0x00                 ; base 16-23
  2250 00000165 F2                          db 0xf2                 ; present, dpl=3, data r/w
  2251 00000166 CF                          db 0xcf                 ; 4k granular, 32bit, limit 16-19
  2252 00000167 00                          db 0x00                 ; base 24-31
  2253                                  
  2254                                  ; gcc wants the ds, es, and ss segment registers to match
  2255                                  ;stacksel1 equ $-ldt1        ; stacksel = 1ch  small limited stack
  2256                                  ;    dw 0xffff               ; limit
  2257                                  ;    dw 0x0000               ; base  0-15
  2258                                  ;    db 0x00
  2259                                  ;    db 0xf2                 ; present, dpl=3, data, r/w
  2260                                  ;    db 0                    ; byte granular, 16 bit
  2261                                  ;    db 0
  2262                                  
  2263                                  ldt1_end :
  2264                                  
  2265                                  ldt1_len equ ldt1_end-ldt1
  2266                                  
  2267                                  ; ---------------------
  2268                                  ; the tss that handles double fault exceptions
  2269                                  
  2270                                  tss_f08 :                   ; intel sw 3a 7.6  pg 287 of 756
  2271 00000168 00000000                    dw 0,0                  ; previous task link
  2272 0000016C 005F0000                    dd tss_f08_stk-0x100    ; esp0
  2273 00000170 10000000                    dw datasel,0            ; ss0
  2274 00000174 00000000                    dd 0                    ; esp1
  2275 00000178 00000000                    dw 0,0                  ; ss1
  2276 0000017C 00000000                    dd 0                    ; esp2
  2277 00000180 00000000                    dw 0,0                  ; ss2
  2278                                  tss_f08_cr3 :
  2279 00000184 00000000                    dd 0                    ; cr3
  2280 00000188 [BC0C0000]                  dd int_handler_tg_dblflt ; eip
  2281 0000018C 00000000                    dd 0                    ; eflags
  2282 00000190 00000000                    dd 0                    ; eax
  2283 00000194 00000000                    dd 0                    ; ecx
  2284 00000198 00000000                    dd 0                    ; edx
  2285 0000019C 00000000                    dd 0                    ; ebx
  2286 000001A0 00600000                    dd tss_f08_stk          ; esp
  2287 000001A4 00000000                    dd 0                    ; ebp
  2288 000001A8 00000000                    dd 0                    ; esi
  2289 000001AC 00000000                    dd 0                    ; edi
  2290 000001B0 10000000                    dw datasel,0            ; es
  2291 000001B4 08000000                    dw codesel,0            ; cs
  2292 000001B8 10000000                    dw datasel,0            ; ss
  2293 000001BC 10000000                    dw datasel,0            ; ds
  2294 000001C0 00000000                    dw 0,0                  ; fs
  2295 000001C4 20000000                    dw videosel,0           ; gs
  2296 000001C8 00000000                    dw 0,0                  ; ldt
  2297 000001CC 0000                        dw 0                    ; trap
  2298 000001CE 0000                        dw 0                    ; iomap
  2299                                  
  2300                                  ; ---------------------
  2301                                  ; the tss that handles invalid tss exceptions
  2302                                  
  2303                                  tss_f10 :                   ; intel sw 3a 7.6  pg 287 of 756
  2304 000001D0 00000000                    dw 0,0                  ; previous task link
  2305 000001D4 006F0000                    dd tss_f10_stk-0x100    ; esp0
  2306 000001D8 10000000                    dw datasel,0            ; ss0
  2307 000001DC 00000000                    dd 0                    ; esp1
  2308 000001E0 00000000                    dw 0,0                  ; ss1
  2309 000001E4 00000000                    dd 0                    ; esp2
  2310 000001E8 00000000                    dw 0,0                  ; ss2
  2311                                  tss_f10_cr3 :
  2312 000001EC 00000000                    dd 0                    ; cr3
  2313 000001F0 [D00C0000]                  dd int_handler_tg_invtss ; eip
  2314 000001F4 00000000                    dd 0                    ; eflags
  2315 000001F8 00000000                    dd 0                    ; eax
  2316 000001FC 00000000                    dd 0                    ; ecx
  2317 00000200 00000000                    dd 0                    ; edx
  2318 00000204 00000000                    dd 0                    ; ebx
  2319 00000208 00700000                    dd tss_f10_stk          ; esp
  2320 0000020C 00000000                    dd 0                    ; ebp
  2321 00000210 00000000                    dd 0                    ; esi
  2322 00000214 00000000                    dd 0                    ; edi
  2323 00000218 10000000                    dw datasel,0            ; es
  2324 0000021C 08000000                    dw codesel,0            ; cs
  2325 00000220 10000000                    dw datasel,0            ; ss
  2326 00000224 10000000                    dw datasel,0            ; ds
  2327 00000228 00000000                    dw 0,0                  ; fs
  2328 0000022C 20000000                    dw videosel,0           ; gs
  2329 00000230 00000000                    dw 0,0                  ; ldt
  2330 00000234 0000                        dw 0                    ; trap
  2331 00000236 0000                        dw 0                    ; iomap
  2332                                  
  2333                                  ; ---------------------
  2334                                  ; tss0 and tss1 are cpu0's pair
  2335                                  
  2336                                  tss0 :                      ; intel swdev3a 7.6  pg 287 of 756
  2337 00000238 00000000                    dw 0,0                  ; previous task link
  2338                                  tss0_esp0 :
  2339 0000023C 00000000                    dd 0                    ; esp0
  2340                                  tss0_ss0 :
  2341 00000240 00000000                    dw 0,0                  ; ss0
  2342 00000244 00000000                    dd 0                    ; esp1
  2343 00000248 00000000                    dw 0,0                  ; ss1
  2344 0000024C 00000000                    dd 0                    ; esp2
  2345 00000250 00000000                    dw 0,0                  ; ss2
  2346                                  tss0_cr3 :
  2347 00000254 00000000                    dd 0                    ; cr3
  2348                                  tss0_eip :
  2349 00000258 00000000                    dd 0                    ; eip
  2350 0000025C 00000000                    dd 0                    ; eflags
  2351                                  tss0_eax :
  2352 00000260 00000000                    dd 0                    ; eax
  2353 00000264 00000000                    dd 0                    ; ecx
  2354 00000268 00000000                    dd 0                    ; edx
  2355 0000026C 00000000                    dd 0                    ; ebx
  2356                                  tss0_esp :
  2357 00000270 00000000                    dd 0                    ; esp
  2358 00000274 00000000                    dd 0                    ; ebp
  2359 00000278 00000000                    dd 0                    ; esi
  2360 0000027C 00000000                    dd 0                    ; edi
  2361                                  tss0_es :
  2362 00000280 00000000                    dw 0,0                  ; es
  2363                                  tss0_cs :
  2364 00000284 00000000                    dw 0,0                  ; cs
  2365                                  tss0_ss :
  2366 00000288 00000000                    dw 0,0                  ; ss
  2367                                  tss0_ds :
  2368 0000028C 00000000                    dw 0,0                  ; ds
  2369 00000290 00000000                    dw 0,0                  ; fs
  2370 00000294 20000000                    dw videosel,0           ; gs
  2371                                  tss0_ldt :
  2372 00000298 00000000                    dw 0,0                  ; ldt
  2373 0000029C 0000                        dw 0                    ; trap
  2374 0000029E 0000                        dw 0                    ; iomap
  2375                                  tss0_end :
  2376                                  
  2377                                  tss_len equ tss0_end-tss0
  2378                                  
  2379                                  ; user tss
  2380                                  
  2381                                  tss1 :                      ; intel sw 3a 7.6  pg 287 of 756
  2382 000002A0 00000000                    dw 0,0                  ; previous task link
  2383                                  tss1_esp0 :
  2384 000002A4 00000000                    dd 0                    ; esp0  (int and irq support)
  2385 000002A8 18000000                    dw stacksel,0           ; ss0   (filled in when running init apps)
  2386 000002AC 00000000                    dd 0                    ; esp1
  2387 000002B0 00000000                    dw 0,0                  ; ss1
  2388 000002B4 00000000                    dd 0                    ; esp2
  2389 000002B8 00000000                    dw 0,0                  ; ss2
  2390                                  tss1_cr3 :
  2391 000002BC 00000000                    dd 0                    ; cr3
  2392                                  tss1_eip :
  2393 000002C0 00000000                    dd 0                    ; eip
  2394 000002C4 00000000                    dd 0                    ; eflags
  2395 000002C8 00000000                    dd 0                    ; eax
  2396 000002CC 00000000                    dd 0                    ; ecx
  2397 000002D0 00000000                    dd 0                    ; edx
  2398 000002D4 00000000                    dd 0                    ; ebx
  2399 000002D8 00000000                    dd 0                    ; esp
  2400 000002DC 00000000                    dd 0                    ; ebp
  2401 000002E0 00000000                    dd 0                    ; esi
  2402 000002E4 00000000                    dd 0                    ; edi
  2403 000002E8 17000000                    dw datasel1+7,0         ; es
  2404 000002EC 0F000000                    dw codesel1+7,0         ; cs
  2405 000002F0 17000000                    dw datasel1+7,0         ; ss
  2406 000002F4 17000000                    dw datasel1+7,0         ; ds
  2407 000002F8 00000000                    dw 0,0                  ; fs
  2408 000002FC 00000000                    dw 0,0                  ; gs
  2409 00000300 3B000000                    dw ldtsel1+3,0          ; ldt
  2410 00000304 0000                        dw 0                    ; trap
  2411 00000306 0000                        dw 0                    ; iomap
  2412                                  
  2413                                  ; ---------------------
  2414                                  
  2415                                  gdtr :
  2416 00000308 4F01                        dw gdt_end - gdt - 1    ; gdt length
  2417 0000030A [00000000]                  dd gdt                  ; gdt physical address
  2418                                  
  2419                                  idtr :
  2420                                      ; irq_setup_table_size == the number of gates in the idt
  2421 0000030E FF07                        dw irq_setup_table_size * 8 - 1     ; idt limit (should be 2k)
  2422                                  idtr_addr :
  2423 00000310 00000000                    dd 0                                ; address of the idt
  2424                                  
  2425 00000314 00000000                ncpus           dd 0        ; number of running cpus
  2426                                  
  2427 00000318 00000000                next_free_page  dd 0        ; initialized after page tables are setup
  2428                                  
  2429 0000031C 0000000000000000        sleepers        dq 0        ; one bit per cpu
  2430                                  
  2431 00000324 00000000                pgdirp          dd 0
  2432 00000328 00000000                pgtb0p          dd 0
  2433 0000032C 00000000                pgtb1p          dd 0
  2434                                  
  2435 00000330 00                      enabled_lapic   db 0        ; set to 1 if an lapic is present and in use
  2436                                  
  2437 00000331 AA55                    dbgwall         db 0xaa,0x55
  2438                                  
  2439 00000333 00<rept>                align 16, db 0
  2440                                  kernel_data_size equ ($-datastart)
  2441                                  
  2442                                  
  2443                                  ; ---------------------
  2444                                  ; Need to align to a physical page boundary here so that appended init apps
  2445                                  ; are always page aligned.  The problem is our text section starts 1k below
  2446                                  ; a page boundary, and so an 'align 4096' doesn't match up with physical
  2447                                  ; memory.
  2448                                  
  2449                                  ; Add larger tests here if the times expression turns up negative, to make
  2450                                  ; the kernel image size right, but your next problem will be that the boot
  2451                                  ; loader will likely refuse to load all these sectors during stage2.
  2452                                  
  2453                                  section .fill
  2454                                  
  2455                                  fill :
  2456                                  
  2457                                  %if total_size > 4096+1024
  2458 00000000 00<rept>                    times (4096+4096+1024-total_size) db 0
  2459                                  %elif total_size > 1024
  2460                                      times (4096+1024-total_size) db 0
  2461                                  %endif
  2462                                  
  2463                                  kend :
  2464                                  
