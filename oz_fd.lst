     1                                  ; OZ - A more utopian OS
     2                                  ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
     3                                  ;
     4                                  ;
     5                                  ;       x86-32 startup 
     6                                  ;
     7                                  ;
     8                                  ; usage:
     9                                  ;	$ qemu-system-i386 -boot a -fda oz_fd.img
    10                                  ;
    11                                  ; requires: nasm-2.07  or later from: http://www.nasm.us
    12                                  ;
    13                                  ; contributors:
    14                                  ;        djv - Duane Voth
    15                                  ;
    16                                  ; history:
    17                                  ; 2007/03/03 - 0.00.01 - djv - begin with various web examples
    18                                  ;                      http://linuxgazette.net/issue82/misc/raghu/code.asm.txt
    19                                  ;                      http://www.osdever.net/tutorials/brunmar/simple_asm.txt
    20                                  ; 2007/03/04 - 0.00.02 - djv - add timer interrupt support with stray int dbg
    21                                  ; 2007/03/05 - 0.00.03 - djv - remove stray int dbg, add mbr data struc back
    22                                  ; 2007/03/11 - 0.00.04 - djv - debug USB boot problem
    23                                  ; 2007/03/28 - 0.01.00 - djv - add a real-mode stage2 loader in the mbr to
    24                                  ;                              load the sectors past the mbr on the boot
    25                                  ;                              device into the memory behind the mbr.  so even
    26                                  ;                              tho the read from the device happens in two
    27                                  ;                              parts, memory contains a linear image of the
    28                                  ;                              first few sectors of the boot device.
    29                                  ; 2009/02/01 - 0.02.00 - djv - begin to define application and dynamic library
    30                                  ;                              binary formats with headers detailing size and
    31                                  ;                              entry points.
    32                                  ; 2009/08/01 - 0.03.00 - djv - create the OZ app execution container using
    33                                  ;                              TSSes, paging, and rings 0 and 3.  begin to
    34                                  ;                              play with system calls.
    35                                  ; 2015/10/07 - 0.03.01 - djv - cleanup, add smp usermode tss structs, sleep,
    36                                  ;                              wakeup, and ipi for user thread creation.
    37                                  
    38                                  %ifdef USB
    39                                  [map symbols oz_usb.map]
    40                                  %else
    41                                  [map symbols oz_fd.map]
    42                                  %endif
    43                                  
    44                                  ; -------- stage 1 ---------------------------------------------------------
    45                                  ; A classic x86 Master Boot Record
    46                                  
    47                                  section .text start=0x7c00  ; PC BIOS boot loader entry point
    48                                  textstart :
    49                                  
    50                                  bios_entry :
    51 00000000 FA                          cli
    52 00000001 EB21                        jmp short load_stage2   ; jump to stage2 loader, skip mbr data struct
    53                                  
    54 00000003 00<rept>                times 6-($-$$)  db 0
    55 00000006 6F7A                    oemid db "oz"
    56                                  
    57 00000008 00<rept>                times 11-($-$$)  db 0
    58                                  
    59                                  ; compute the size of the kernel image in 512 byte sectors
    60                                  total_size equ (kernel_text_size + kernel_data_size)
    61                                  kisectors  equ (total_size)/512 + (APP_SIZE + 512)/512
    62                                  ; compute the end of the kernel image (with apps attached)
    63                                  kilast equ 0x7c00 + kisectors * 512
    64                                  
    65                                  ; MS MBR  (http://support.microsoft.com/kb/140418)
    66                                  %ifdef FLOPPY
    67 0000000B 0002                        dw 512                  ; Bytes per sector
    68 0000000D 01                          db 1                    ; Sectors per cluster
    69 0000000E 3A00                        dw kisectors            ; Number of reserved sectors
    70 00000010 02                          db 2                    ; Number of FATs
    71 00000011 E000                        dw 0x00e0               ; Number of dirs in root
    72 00000013 400B                        dw 0x0b40               ; Number of sectors in volume
    73 00000015 F0                          db 0xf0                 ; Media descriptor
    74 00000016 0900                        dw 9                    ; Number of sectors per FAT
    75 00000018 1200                        dw 18                   ; Number of sectors per track
    76 0000001A 0200                        dw 2                    ; Number of heads
    77 0000001C 00000000                    dd 0                    ; Number of hidden sectors
    78 00000020 00000000                    dd 0                    ; Large Sectors
    79                                  %endif
    80                                  
    81                                  %ifdef USB
    82                                      dw 0                    ; Bytes per sector
    83                                      db 0                    ; Sectors per cluster
    84                                      dw kisectors            ; Number of reserved sectors
    85                                      db 0                    ; Number of FATs
    86                                      dw 0                    ; Number of dirs in root
    87                                      dw 0                    ; Number of sectors in volume
    88                                      db 0                    ; Media descriptor
    89                                      dw 0                    ; Number of sectors per FAT
    90                                      dw 0                    ; Number of sectors per track
    91                                      dw 0                    ; Number of heads
    92                                      dd 0                    ; Number of hidden sectors
    93                                      dd 0                    ; Large Sectors
    94                                  %endif
    95                                  
    96                                  ; -------- stage 2 loader ------------
    97                                  bits 16
    98                                  alignb 2
    99                                  
   100                                  load_stage2 :
   101 00000024 52                          push dx                 ; save BIOS drive number
   102                                  
   103 00000025 B80006                      mov  ax,0x0600          ; ah=6 scroll window up, if al = 0 clrscr
   104 00000028 B90000                      mov  cx,0x0000          ; clear window from 0,0 
   105 0000002B BA4F17                      mov  dx,0x174f          ; to 23,79
   106 0000002E B70F                        mov  bh,0xf             ; fill with hi white
   107 00000030 CD10                        int  0x10               ; clear screen for direct writes to video memory
   108                                  
   109 00000032 BE[A500]                    mov  si,bootmsg
   110 00000035 31DB                        xor  bx,bx
   111 00000037 E85700                      call puts_vga_rm
   112                                                              ; puts_vga_rm leaves gs pointing at video mem
   113 0000003A 65C60601000E                mov  byte [gs:1],0xE    ; turn the first two chars yellow
   114 00000040 65C60603000E                mov  byte [gs:3],0xE
   115                                  
   116                                      ;F - white              
   117                                      ;E - yellow             
   118                                      ;D - magenta            
   119                                      ;C - red                
   120                                      ;B - cyan               
   121                                      ;A - green              
   122                                      ;9 - blue               
   123                                      ;8 - dark grey          
   124                                  
   125 00000046 A1[0002]                    mov  ax,[stage2]         ; check the signature byte
   126 00000049 0306[0202]                  add  ax,[stage2+2]
   127 0000004D 3DA17A                      cmp  ax,0x7a6f+0x32
   128 00000050 741D                        jz   stage2_present
   129                                  
   130                                      ; -------- stage2 boot loader --------
   131                                  
   132                                      ; Assume that the kernel is smaller than whatever space
   133                                      ; is provided prior to file system data structures on the
   134                                      ; boot device, and that it can immediately follow the MBR.
   135                                  
   136 00000052 B402                        mov  ah,02h
   137 00000054 B039                        mov  al,kisectors-1     ; number of sectors to load
   138 00000056 BB[0002]                    mov  bx,stage2
   139 00000059 B90200                      mov  cx,2
   140 0000005C 5A                          pop  dx                 ; recover BIOS drive number
   141 0000005D 0E                          push cs
   142 0000005E 07                          pop  es
   143 0000005F CD13                        int  13h
   144 00000061 7211                        jc   ioerr
   145                                  
   146                                      ; ---- make sure second stage actually got loaded
   147                                  
   148 00000063 A1[0002]                    mov  ax,[stage2]        ; check the signature byte
   149 00000066 0306[0202]                  add  ax,[stage2+2]
   150 0000006A 3DA17A                      cmp  ax,0x7a6f+0x32
   151 0000006D 750A                        jnz  s2err
   152                                  stage2_present :
   153 0000006F EA[0902]0000                jmp  0:start_stage2     ; use an absolute jump so stage 1
   154                                                              ; can be position independent
   155                                  
   156                                  ioerr :                     ; ah has status...
   157 00000074 BE[D500]                    mov  si,ioerrmsg
   158 00000077 EB03                        jmp  print_err
   159                                  
   160                                  s2err :
   161 00000079 BE[BF00]                    mov  si,s2errmsg
   162                                  print_err :
   163 0000007C BBA000                      mov  bx,160
   164 0000007F E80F00                      call puts_vga_rm
   165 00000082 65C60601000C                mov  byte [gs:1],0xC    ; turn the first two vga chars red
   166 00000088 65C60603000C                mov  byte [gs:3],0xC
   167                                  
   168                                  hang :
   169 0000008E F4                          hlt
   170 0000008F EBFD                        jmp  hang
   171                                  
   172                                  ; ----------------------------
   173                                  ;   puts_vga_rm - write a null delimited string to the VGA controller
   174                                  ;                 in real mode
   175                                  ;
   176                                  ;    enter:
   177                                  ;            esi - address of string
   178                                  ;            ebx - screen location (2 bytes per char, 160 bytes per line)
   179                                  ;    exit:
   180                                  ;            eax - destroyed
   181                                  ;             gs - set to video memory selector
   182                                  
   183                                  puts_vga_rm :
   184 00000091 B800B8                      mov  ax,0xb800      ; point gs at video memory
   185 00000094 8EE8                        mov  gs,ax          
   186                                  puts_vga_rm_loop :
   187 00000096 AC                          lodsb
   188 00000097 3C00                        cmp  al,0
   189 00000099 7409                        jz   puts_vga_rm_done
   190 0000009B 658807                      mov  [gs:bx],al
   191 0000009E 6683C302                    add  ebx,2
   192 000000A2 EBF2                        jmp  puts_vga_rm_loop
   193                                  puts_vga_rm_done :
   194 000000A4 C3                          ret
   195                                  
   196 000000A5 4F5A2076302E30332E-     bootmsg     db      "OZ v0.03.01 - 2015/10/07 ",0
   197 000000AE 3031202D2032303135-
   198 000000B7 2F31302F30372000   
   199 000000BF 73746167652032206C-     s2errmsg    db      "stage 2 load failure ",0
   200 000000C8 6F6164206661696C75-
   201 000000D1 72652000           
   202 000000D5 692F6F206572726F72-     ioerrmsg    db      "i/o error loading stage 2 ",0
   203 000000DE 206C6F6164696E6720-
   204 000000E7 737461676520322000 
   205                                  
   206 000000F0 00<rept>                times 446-($-$$) db 0       ; fill with zeros up to partition table
   207                                  
   208                                  tmpstk      equ     $
   209                                  
   210                                  ; If the kernel is loaded from a disk (including usb) the MBR
   211                                  ; must include a partition table based on the device geometry.
   212                                  ; This gets fed into oz.asm here via usbptbl.inc
   213                                  %ifdef USB
   214                                  %include "usbptbl.inc"
   215                                  %else
   216                                      ; If the kernel is placed in memory by some other means
   217                                      ; (PXE, pxelinux, etc.) the partition table is irrelevant
   218                                      ; but the space is still required.  Make the default ptbl
   219                                      ; match a 1.44MB floppy.
   220 000001BE 800101000601124F            db 0x80,0x01,0x01,0x00,0x06,0x01,0x12,0x4f
   221 000001C6 120000002E0B0000            db 0x12,0x00,0x00,0x00,0x2e,0x0b,0x00,0x00
   222 000001CE 000000000000000000-         db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   223 000001D7 00000000000000     
   224 000001DE 000000000000000000-         db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   225 000001E7 00000000000000     
   226 000001EE 000000000000000000-         db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   227 000001F7 00000000000000     
   228                                  %endif
   229                                  
   230                                  %ifdef NEWUSB
   231                                  new usb?  gpt correct?
   232                                  0000 01B0: 00 00 00 00 00 2C 44 63  E0 36 03 00 00 00 80 20  .....,Dc .6.....
   233                                  0000 01C0: 21 00 83 9D 11 4C 00 08  00 00 00 C0 12 00 00 9D  !....L.. ........
   234                                  0000 01D0: 12 4C 83 57 25 F2 00 C8  12 00 00 A0 28 00 00 00  .L.W%... ....(...
   235                                  0000 01E0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ........ ........
   236                                  0000 01F0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 AA  ........ ......U.
   237                                  %endif
   238                                  
   239                                  
   240                                  times 510-($-$$) db 0       ; fill with zeros up to MBR signature
   241                                  
   242 000001FE 55AA                                dw 0x0aa55      ; write aa55 in bytes 511,512 to indicate
   243                                                              ; that it is a boot sector. 
   244                                  
   245                                  ; end of MBR
   246                                  ;
   247                                  ; -------- stage 2 ---------------------------------------------------------
   248                                  ;
   249                                  ; If a boot loader only loads 512 bytes in the first pass, the following
   250                                  ; code won't appear in memory until the code above has completed.  Other
   251                                  ; loaders however can load the entire OZ kernel image into memory in one
   252                                  ; shot.
   253                                  
   254                                  bits 16
   255                                  
   256                                  stage2 :
   257 00000200 6F7A3200                    db "oz2",0                      ; stage2 signature
   258                                  
   259                                  non_boot_cpu_ljmp_instruction :     ; place this in 16 bit code land
   260 00000204 EA00000000                  jmp word 0:0                    ; so we get the right opcode
   261                                  
   262                                  kstack_loc  equ 0x1000      ; must be on a 4k pysical page boundary
   263                                  kstack_size equ 4096*2
   264                                  
   265                                  pgdir equ 0x3000            ; use some of the free memory below us
   266                                  pgtb0 equ 0x4000            ; code below assumes this follows pgdir
   267                                  pgtb1 equ 0x5000            ; code below assumes this follows pgtb0
   268                                  
   269                                  idt   equ 0x7000            ; use some of the free memory below us
   270                                  
   271                                  ; ---------------------
   272                                  
   273                                  start_stage2 :
   274                                  
   275 00000209 B80030                      mov  ax,kstack_loc+kstack_size  ; setup the kernel stack
   276 0000020C 89C4                        mov  sp,ax
   277                                  
   278                                      ; ---- initialize the 8259's while in real mode
   279                                  
   280 0000020E E84305                      call irq_init_hardware
   281                                  
   282                                  ; ------------ main kernel entry point ------------
   283                                  ; all cpus enter here
   284                                  main :
   285                                  
   286                                      ; -------- enter protected mode --------
   287                                  
   288 00000211 0F0116[0803]                lgdt [gdtr]             ; initialize the gdt
   289 00000216 0F20C0                      mov  eax,cr0
   290 00000219 0C01                        or   al,0x01            ; set the protected mode bit (lsb of cr0)
   291 0000021B 0F22C0                      mov  cr0,eax
   292 0000021E EA[2302]0800                jmp  codesel:flush_ip1  ; flush the cpu instruction pipeline
   293                                  flush_ip1: 
   294                                  bits 32                     ; instructions after this point are 32bit
   295                                  
   296 00000223 B801000000                  mov  eax,1
   297 00000228 0FC105[14030000]            xadd [ncpus],eax        ; get our unique cpu number
   298                                                              ; could use the lapic id if available
   299 0000022F 89C6                        mov  esi,eax
   300 00000231 66B81000                    mov  ax,datasel   
   301 00000235 8ED8                        mov  ds,ax              ; initialize the data segments
   302 00000237 8EC0                        mov  es,ax
   303 00000239 66B81800                    mov  ax,stacksel        ; setup a restricted stack segment
   304 0000023D 8ED0                        mov  ss,ax
   305 0000023F BC00200000                  mov  esp,kstack_size
   306 00000244 89F0                        mov  eax,esi
   307 00000246 C1E008                      shl  eax,8              ; divvy up the stack, 256 bytes per cpu
   308 00000249 29C4                        sub  esp,eax
   309                                  
   310 0000024B 89F0                        mov  eax,esi
   311 0000024D 50                          push eax
   312 0000024E 89C3                        mov  ebx,eax
   313 00000250 80C330                      add  bl,'0'             ; boot cpu announces via ascii 0
   314 00000253 BF9E000000                  mov  edi,160-2          ; last chracter on first line of vga
   315 00000258 D1E0                        shl  eax,1
   316 0000025A 29C7                        sub  edi,eax
   317 0000025C 66B82000                    mov  ax,videosel        ; point gs at video memory
   318 00000260 8EE8                        mov  gs,ax
   319 00000262 65881F                      mov  [gs:edi],bl        ; announce cpu presence
   320 00000265 58                          pop  eax
   321                                  
   322 00000266 09C0                        or   eax,eax            ; are we the boot cpu?
   323 00000268 0F8F4E010000                jg   non_boot_init      ; if not, do non_boot_init
   324                                  
   325 0000026E E80A050000                  call irq_init_bsp_apic_hardware
   326                                  
   327                                      ; ---- debug marker
   328 00000273 65C605010000000A            mov  byte [gs:1],0xA    ; turn the first two chars green
   329 0000027B 65C605030000000A            mov  byte [gs:3],0xA
   330                                  
   331                                      ; ---- build the interrupt descriptor table
   332                                  
   333 00000283 BE[E40C0000]                mov  esi,irq_setup_table
   334 00000288 B900010000                  mov  ecx,irq_setup_table_size
   335 0000028D BA00700000                  mov  edx,idt
   336                                  irq_init :
   337 00000292 31C0                        xor  eax,eax
   338 00000294 8902                        mov  [edx],eax                  ; clear the idt entry
   339 00000296 894202                      mov  [edx+2],eax
   340 00000299 66AD                        lodsw
   341 0000029B 6689C3                      mov  bx,ax
   342 0000029E 6625FCFF                    and  ax,strict 0xfffc           ; separate config flags
   343 000002A2 6683E303                    and  bx,3                       ; from selector/offset value
   344 000002A6 6683FB02                    cmp  bx,irqt_task               ; task gates are different
   345 000002AA 7407                        jz   irq_init_task_gate
   346 000002AC 668902                      mov  [edx],ax                   ; store the handler offset
   347 000002AF 66B80800                    mov  ax,codesel
   348                                  irq_init_task_gate :
   349 000002B3 66894202                    mov  word [edx+2],ax
   350 000002B7 678AA7[E00C]                mov  ah,byte [bx+irq_types]
   351 000002BC 30C0                        xor  al,al
   352 000002BE 66894204                    mov  word [edx+4],ax
   353 000002C2 83C208                      add  edx,8
   354 000002C5 E2CB                        loop irq_init
   355                                  
   356 000002C7 0F011D[0E030000]            lidt [idtr]                     ; install the idt
   357                                  
   358                                      ; ---- setup entry point for non_boot_cpus
   359                                  
   360 000002CE A0[04020000]                mov  al,[non_boot_cpu_ljmp_instruction]     ; get the ljmp instruction
   361 000002D3 A200100000                  mov  [kstack_loc],al                        ; place it at a 4k phys mem boundary
   362 000002D8 C70501100000-               mov  dword [kstack_loc+1],main
   363 000002DE [11020000]         
   364                                  
   365                                      ; ---- setup the paging tables
   366                                  
   367 000002E2 BF00300000                  mov  edi,pgdir          ; first the page directory
   368 000002E7 0F22DF                      mov  cr3,edi            ; install the page directory
   369 000002EA B807400000                  mov  eax,pgtb0 + 7      ; page table 0: present, pl=3, r/w
   370 000002EF AB                          stosd                   ; ... pl=3 for now (simplify vga access)
   371 000002F0 B807500000                  mov  eax,pgtb1 + 7      ; page table 1: present, pl=3, r/w
   372 000002F5 AB                          stosd                   ; ... app memory
   373 000002F6 31C0                        xor  eax,eax            ; invalidate the rest of the app laddr space
   374 000002F8 B9FE030000                  mov  ecx,0x400-2        ; (yeah, only one pgdir for kernel+apps for now)
   375 000002FD F3AB                        rep stosd
   376                                  
   377                                              ; assume pgtb0 physically follows the pg dir
   378                                              ; pgtb0 is the page table for kernel memory
   379                                  
   380 000002FF AB                          stosd                   ; access to page 0 will always cause a fault
   381 00000300 B803100000                  mov  eax,0x1000 + 3     ; rest are direct map: present, pl=0, r/w
   382 00000305 B9FF030000                  mov  ecx,0x400-1
   383                                  pgtb0_fill :
   384 0000030A AB                          stosd
   385 0000030B 0500100000                  add  eax,0x1000
   386 00000310 E2F8                        loop pgtb0_fill
   387                                  
   388                                              ; assume pgtb1 physically follows pgtb0
   389                                              ; pgtb1 is the first page table for app code/data/stack
   390                                  
   391 00000312 31C0                        xor  eax,eax            ; invalidate the app logical address space
   392 00000314 B900040000                  mov  ecx,0x400          ; (we'll fill in what we need later)
   393 00000319 F3AB                        rep stosd
   394                                  
   395                                              ; enable paging
   396                                  
   397 0000031B 0F20C0                      mov  eax,cr0
   398 0000031E 0D00000080                  or   eax,0x80000000     ; msb of cr0
   399 00000323 0F22C0                      mov  cr0,eax
   400 00000326 EB00                        jmp  flush_ip2          ; flush the cpu instruction pipeline
   401                                  flush_ip2: 
   402                                  
   403                                              ; establish a "pool" of free pyhsical memory
   404                                  
   405 00000328 B810000000                  mov  eax,((kilast+0x1000) >> 12)    ; include a buffer zone
   406 0000032D A3[19030000]                mov  [next_free_page],eax
   407                                  
   408                                              ; if enabled, create page table entry for the lapic
   409                                  
   410 00000332 A0[18030000]                mov  al,[enabled_lapic]
   411 00000337 08C0                        or   al,al
   412 00000339 740F                        jz   no_lapic_init
   413                                  
   414 0000033B BA0000E0FE                  mov  edx,0xfee00000     ; phys address
   415 00000340 B900100000                  mov  ecx,0x1000         ; length
   416 00000345 E8490C0000                  call map_pmem
   417                                  
   418                                  no_lapic_init :
   419                                  
   420                                      ; ---- establish a current task
   421                                  
   422 0000034A 31C0                        xor  eax,eax
   423 0000034C B050                        mov  al,tasksel_k00
   424 0000034E 0F00D8                      ltr  ax
   425                                  
   426                                      ; ---- check for init apps
   427                                  
   428 00000351 BB[E0000000]                mov  ebx, kend
   429                                  app_loop :
   430 00000356 8B4318                      mov  eax, [ebx+0x18]    ; load the entry address
   431 00000359 813B6F7A6170                cmp  dword [ebx], 0x70617a6f  ; check for "ozap"
   432 0000035F 7402                        jz   have_an_app
   433 00000361 31C0                        xor  eax, eax           ; no app
   434                                  have_an_app :
   435                                  
   436 00000363 83F800                      cmp  eax, 0             ; is there an app to run?
   437 00000366 0F848E000000                jz   idle               ; if not, idle right away
   438                                  
   439                                      ; ---- setup the init task entry point
   440                                  
   441 0000036C BF[C0020000]                mov  edi,tss1_eip
   442 00000371 AB                          stosd
   443                                  
   444                                      ; cheat: reuse the same tss, ldt, and page tables for all
   445                                      ; the init apps - this means they run serialy - each has
   446                                      ; to exit for the next one to run
   447                                  
   448 00000372 31C0                        xor   eax,eax
   449 00000374 A3[A0020000]                mov   [tss1],eax        ; clear out previous task link
   450 00000379 AB                          stosd                   ; and some registers (flags)
   451 0000037A AB                          stosd                   ; (eax)
   452 0000037B AB                          stosd                   ; (ecx)
   453 0000037C AB                          stosd                   ; (edx)
   454 0000037D AB                          stosd                   ; (ebx)
   455 0000037E 8B4310                      mov   eax, [ebx+0x10]   ; get the end of the app
   456                                      ;add   eax,0x8001000     ; (this tests app stack page faults)
   457 00000381 AB                          stosd                   ; (esp)
   458 00000382 31C0                        xor   eax,eax
   459 00000384 AB                          stosd                   ; (ebp)
   460 00000385 AB                          stosd                   ; (esi)
   461 00000386 AB                          stosd                   ; (edi)
   462                                  
   463 00000387 BF00500000                  mov  edi,pgtb1          ; rewrite the app's page table
   464 0000038C 89D8                        mov  eax,ebx
   465 0000038E 83C805                      or   eax,5              ; init app code at 0x400000 (4Mb) present and r/o
   466 00000391 AB                          stosd                   ; assume all the init apps are < 4k
   467 00000392 0502100000                  add  eax,0x1000 + 2     ; add one page for data/bss/stack
   468 00000397 AB                          stosd
   469                                  
   470                                      ; ---- start the app
   471                                  
   472 00000398 53                          push ebx
   473 00000399 FB                          sti
   474 0000039A 9A000000005800              call tasksel_u00:0
   475 000003A1 5B                          pop  ebx
   476                                  
   477                                      ; ---- point to the end of this init app
   478                                  
   479 000003A2 0F013D00004000              invlpg [0x400000]       ; FIXME 80386 needs to reload cr3
   480 000003A9 0F013D00104000              invlpg [0x401000]
   481                                  
   482 000003B0 8B4310                      mov  eax, [ebx+0x10]    ; load the app end address
   483 000003B3 2D00004000                  sub  eax,0x400000
   484 000003B8 01C3                        add  ebx,eax            ; point ebx to the next app
   485 000003BA EB9A                        jmp  app_loop
   486                                  
   487                                  ; -------- non-boot cpu initialization --------
   488                                  
   489                                  non_boot_init :
   490                                  
   491 000003BC 0F011D[0E030000]            lidt [idtr]             ; install the global idt
   492                                  
   493                                      ; ---- enable paging
   494                                  
   495 000003C3 BF00300000                  mov  edi,pgdir          ; load this cpu's paging register
   496 000003C8 0F22DF                      mov  cr3,edi
   497                                  
   498 000003CB 50                          push eax
   499 000003CC 0F20C0                      mov  eax,cr0            ; enable paging
   500 000003CF 0D00000080                  or   eax,0x80000000
   501 000003D4 0F22C0                      mov  cr0,eax
   502 000003D7 EB00                        jmp  flush_ip3          ; flush the cpu instruction pipeline
   503                                  flush_ip3 : 
   504 000003D9 58                          pop  eax
   505                                  
   506                                      ; ---- limit the number of cpus we support here
   507                                  
   508 000003DA 83F810                      cmp  eax,16
   509 000003DD 7317                        jae  nb_idle
   510                                  
   511                                      ; ---- init the lapic
   512                                  
   513 000003DF E8F0030000                  call irq_init_ap_apic_hardware
   514                                  
   515                                      ; setup smbase?
   516                                  
   517                                      ; ---- establish a current task
   518                                  
   519 000003E4 89C3                        mov  ebx,eax            ; move cpu number to ebx
   520 000003E6 E885000000                  call create_tss_pair
   521 000003EB 53                          push ebx
   522 000003EC C1E304                      shl  ebx,4              ; 16x (selector size x2)
   523 000003EF 83C350                      add  ebx,tasksel_k00
   524 000003F2 0F00DB                      ltr  bx                 ; establish a current task
   525 000003F5 5B                          pop  ebx
   526                                  
   527                                      ; test kernel page fault handler
   528                                      ;mov  [321],eax
   529                                  
   530                                  nb_idle :
   531 000003F6 FB                          sti
   532 000003F7 F4                          hlt                     ; wait for something to do
   533 000003F8 EBFC                        jmp  nb_idle            ; (see new_thread)
   534                                  
   535                                      ; -------- boot cpu idle task --------
   536                                      ; could be combined with nb_idle but separating
   537                                      ; these can allow for easier debug
   538                                  
   539                                  idle :
   540 000003FA FB                          sti
   541 000003FB F4                          hlt                     ; wait for interrupts
   542 000003FC EBFC                        jmp  idle
   543                                  
   544                                  
   545                                  ; ----------------------------
   546                                  ;    puts_vga - write a null delimited string to the VGA controller
   547                                  ;               in protected mode
   548                                  ;    enter:
   549                                  ;         esi - address of string
   550                                  ;         ebx - screen location (2 bytes per char, 160 bytes per line)
   551                                  ;    exit:
   552                                  ;         eax - destroyed
   553                                  ;         ebx - next screen location
   554                                  ;          gs - set to video memory selector
   555                                  bits 32
   556                                  
   557                                  puts_vga :
   558 000003FE 66B82000                    mov  ax,videosel        ; point gs at video memory
   559 00000402 8EE8                        mov  gs,ax
   560                                  puts_vga_loop :
   561 00000404 2E8A06                      mov  al,[cs:esi]        ; use cs so irq handlers don't
   562 00000407 46                          inc  esi                ; have to load kernel ds
   563 00000408 3C00                        cmp  al,0
   564 0000040A 7408                        jz   puts_vga_done
   565 0000040C 658803                      mov  [gs:ebx],al
   566 0000040F 83C302                      add  ebx,2
   567 00000412 EBF0                        jmp  puts_vga_loop
   568                                  puts_vga_done :
   569 00000414 C3                          ret
   570                                  
   571                                  ; ----------------------------
   572                                  ;   putx_vga - write the contents of eax in hex to the VGA controller
   573                                  ;              (in protected mode)
   574                                  ;   putbx_vga - write the contents of al in hex to the VGA controller
   575                                  ;
   576                                  ;   enter:
   577                                  ;       eax - value to convert to hex
   578                                  ;       ebx - screen location (2 bytes per char, 160 bytes per line)
   579                                  ;   exit:
   580                                  ;       ebx - next screen location
   581                                  ;        gs - set to video memory selector
   582                                  bits 32
   583                                  
   584                                  putbx_vga :
   585 00000415 51                          push ecx
   586 00000416 B902000000                  mov  ecx,2
   587 0000041B 25FF000000                  and  eax,0xff
   588 00000420 C1C018                      rol  eax,24
   589 00000423 EB06                        jmp putx_vga_loop
   590                                  
   591                                  putx_vga :
   592 00000425 51                          push ecx
   593 00000426 B908000000                  mov  ecx,8
   594                                  putx_vga_loop :
   595 0000042B C1C004                      rol  eax,4
   596 0000042E 50                          push eax
   597 0000042F 240F                        and  al,0xf
   598 00000431 3C09                        cmp  al,9
   599 00000433 7704                        ja   putx_vga_hexdigit
   600 00000435 0430                        add  al,'0'
   601 00000437 EB02                        jmp short putx_vga_putc
   602                                  putx_vga_hexdigit :
   603 00000439 0457                        add  al,'a'-10
   604                                  putx_vga_putc :
   605 0000043B 658803                      mov  [gs:ebx],al
   606 0000043E 83C302                      add  ebx,2
   607 00000441 58                          pop  eax
   608 00000442 83E0F0                      and  eax,0xfffffff0
   609 00000445 E2E4                        loop putx_vga_loop
   610 00000447 65C60320                    mov  byte [gs:ebx],' '
   611 0000044B 83C302                      add  ebx,2
   612 0000044E 59                          pop  ecx
   613 0000044F C3                          ret
   614                                  
   615                                  ;------------------------------------------------------------------
   616                                  ;   mem_alloc_kernel_page - return the 4k page number of 1 page of memory
   617                                  ;                           from the kernel page pool
   618                                  ;
   619                                  ;   returns:    eax = page number, zero means no pages left
   620                                  
   621                                  mem_alloc_kernel_page :
   622 00000450 A1[19030000]                mov  eax,[next_free_page]
   623 00000455 FF05[19030000]              inc  dword [next_free_page]
   624                                      ; probably should check for the end of something ...
   625 0000045B 50                          push eax
   626 0000045C 51                          push ecx
   627 0000045D 57                          push edi
   628 0000045E C1E00C                      shl  eax,12
   629 00000461 B900040000                  mov  ecx,0x1000/4
   630 00000466 89C7                        mov  edi,eax
   631 00000468 31C0                        xor  eax,eax
   632 0000046A F3AB                        rep stosd                   ; zero the page
   633 0000046C 5F                          pop  edi
   634 0000046D 59                          pop  ecx
   635 0000046E 58                          pop  eax
   636 0000046F C3                          ret
   637                                  
   638                                  ;------------------------------------------------------------------
   639                                  ;   create a pair of tss structs for a new cpu
   640                                  ;
   641                                  ;   enter:
   642                                  ;       ebx - cpu number
   643                                  ;   exit:
   644                                  ;       ebx - cpu number
   645                                  
   646                                  create_tss_pair :
   647 00000470 E8DBFFFFFF                  call mem_alloc_kernel_page
   648 00000475 09C0                        or   eax,eax
   649 00000477 0F8495000000                jz   create_tss_pair_fail
   650 0000047D C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   651 00000480 89C7                        mov  edi,eax
   652                                  
   653 00000482 89FE                        mov  esi,edi
   654 00000484 83C668                      add  esi,(tss0_end-tss0)
   655                                  
   656 00000487 B800300000                  mov  eax,pgdir
   657 0000048C 89471C                      mov  [edi+(tss0_cr3-tss0)],eax
   658 0000048F 89461C                      mov  [esi+(tss0_cr3-tss0)],eax
   659                                  
   660 00000492 B817000000                  mov  eax,datasel1+7
   661 00000497 894648                      mov  [esi+(tss0_es-tss0)],eax
   662 0000049A 894650                      mov  [esi+(tss0_ss-tss0)],eax
   663 0000049D 894654                      mov  [esi+(tss0_ds-tss0)],eax
   664 000004A0 B80F000000                  mov  eax,codesel1+7
   665 000004A5 89464C                      mov  [esi+(tss0_cs-tss0)],eax
   666 000004A8 B83B000000                  mov  eax,ldtsel1+3
   667 000004AD 894660                      mov  [esi+(tss0_ldt-tss0)],eax
   668                                  
   669                                      ; setup the tss structs (edi = kernel, esi = user).
   670                                      ; there are three stacks total
   671                                      ;   (1) kernel tss esp0 - placed at the end of this page
   672                                      ;   (2) user tss esp0 (for interrupt handling) - end minus 1k
   673                                      ;   (3) user tss esp3 (esp) - will be set up by new_thread
   674                                  
   675 000004B0 89F8                        mov  eax,edi
   676 000004B2 0500100000                  add  eax,0x1000
   677 000004B7 894704                      mov  [edi+(tss0_esp0-tss0)],eax ; (1) kernel tss esp0
   678 000004BA 2D00040000                  sub  eax,0x400
   679 000004BF 894604                      mov  [esi+(tss0_esp0-tss0)],eax ; (2) user tss esp0
   680                                      ;mov  eax,stacksel
   681 000004C2 B810000000                  mov  eax,datasel
   682 000004C7 894708                      mov  [edi+(tss0_ss0-tss0)],eax
   683 000004CA 894608                      mov  [esi+(tss0_ss0-tss0)],eax
   684                                  
   685                                      ; patch the tss addresses into the reserved gdt selectors
   686                                  
   687 000004CD 89DA                        mov  edx,ebx
   688 000004CF C1E204                      shl  edx,4                      ; 16x because selectors are in pairs
   689 000004D2 83C250                      add  edx,tasksel_k00
   690                                  
   691 000004D5 89F8                        mov  eax,edi
   692 000004D7 C1E818                      shr  eax,24
   693 000004DA 8882[07000000]              mov  byte [gdt+edx+7],al        ; base 24-32
   694 000004E0 81E7FFFFFF00                and  edi,0xffffff
   695 000004E6 0BBA[02000000]              or   edi,[gdt+edx+2]            ; or in flags
   696 000004EC 89BA[02000000]              mov  [gdt+edx+2],edi            ; base 0-23 and flags
   697                                  
   698 000004F2 83C208                      add  edx,8                      ; move to tasksel_uxx
   699                                  
   700 000004F5 89F0                        mov  eax,esi
   701 000004F7 C1E818                      shr  eax,24
   702 000004FA 8882[07000000]              mov  byte [gdt+edx+7],al        ; base 24-32
   703 00000500 81E6FFFFFF00                and  esi,0xffffff
   704 00000506 0BB2[02000000]              or   esi,[gdt+edx+2]            ; or in flags
   705 0000050C 89B2[02000000]              mov  [gdt+edx+2],esi            ; base 0-23 and flags
   706                                  
   707                                  create_tss_pair_fail :
   708 00000512 C3                          ret
   709                                  
   710                                  ; -------- interrupt handlers --------
   711                                  %include "ozirq.asm"
   712                              <1> ; OZ - A more utopian OS
   713                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
   714                              <1> ;
   715                              <1> ; IRQ handling
   716                              <1> 
   717 00000513 63707500            <1> cpumsg      db      "cpu",0
   718                              <1> 
   719 00000517 646976696465206279- <1> int00msg    db      "divide by zero ",0
   720 00000520 207A65726F2000      <1>
   721 00000527 646562756720657863- <1> int01msg    db      "debug exception ",0
   722 00000530 657074696F6E2000    <1>
   723 00000538 6E6D692000          <1> int02msg    db      "nmi ",0
   724 0000053D 627265616B706F696E- <1> int03msg    db      "breakpoint exception ",0
   725 00000546 742065786365707469- <1>
   726 0000054F 6F6E2000            <1>
   727 00000553 6F766572666C6F7720- <1> int04msg    db      "overflow exception ",0
   728 0000055C 657863657074696F6E- <1>
   729 00000565 2000                <1>
   730 00000567 626F756E6420657863- <1> int05msg    db      "bound exceeded ",0
   731 00000570 65656465642000      <1>
   732 00000577 696E76616C6964206F- <1> int06msg    db      "invalid opcode ",0
   733 00000580 70636F64652000      <1>
   734 00000587 64657669636520756E- <1> int07msg    db      "device unavailable ",0
   735 00000590 617661696C61626C65- <1>
   736 00000599 2000                <1>
   737 0000059B 646F75626C65206661- <1> int08msg    db      "double fault ",0
   738 000005A4 756C742000          <1>
   739 000005A9 636F70726F63657373- <1> int09msg    db      "coprocessor segment overrun ",0
   740 000005B2 6F72207365676D656E- <1>
   741 000005BB 74206F76657272756E- <1>
   742 000005C4 2000                <1>
   743 000005C6 696E76616C69642074- <1> int10msg    db      "invalid tss ",0
   744 000005CF 73732000            <1>
   745 000005D3 7365676D656E74206E- <1> int11msg    db      "segment not present ",0
   746 000005DC 6F742070726573656E- <1>
   747 000005E5 742000              <1>
   748 000005E8 737461636B20666175- <1> int12msg    db      "stack fault ",0
   749 000005F1 6C742000            <1>
   750 000005F5 67656E6572616C2070- <1> int13msg    db      "general protection fault ",0
   751 000005FE 726F74656374696F6E- <1>
   752 00000607 206661756C742000    <1>
   753 0000060F 6B65726E656C207061- <1> int14kmsg   db      "kernel page fault addr=",0
   754 00000618 6765206661756C7420- <1>
   755 00000621 616464723D00        <1>
   756 00000627 617070207061676520- <1> int14umsg   db      "app page fault addr=",0
   757 00000630 6661756C7420616464- <1>
   758 00000639 723D00              <1>
   759 0000063C 666C6F6174696E6720- <1> int16msg    db      "floating point err ",0
   760 00000645 706F696E7420657272- <1>
   761 0000064E 2000                <1>
   762 00000650 616C69676E6D656E74- <1> int17msg    db      "alignment check ",0
   763 00000659 20636865636B2000    <1>
   764 00000661 6D616368696E652063- <1> int18msg    db      "machine check ",0
   765 0000066A 6865636B2000        <1>
   766 00000670 73696D6420666C6F61- <1> int19msg    db      "simd floating point err ",0
   767 00000679 74696E6720706F696E- <1>
   768 00000682 74206572722000      <1>
   769                              <1> 
   770 00000689 687720696E74303220- <1> int34msg    db      "hw int02 ",0
   771 00000692 00                  <1>
   772 00000693 687720696E74303320- <1> int35msg    db      "hw int03 ",0
   773 0000069C 00                  <1>
   774 0000069D 687720696E74303420- <1> int36msg    db      "hw int04 ",0
   775 000006A6 00                  <1>
   776 000006A7 687720696E74303520- <1> int37msg    db      "hw int05 ",0
   777 000006B0 00                  <1>
   778 000006B1 687720696E74303620- <1> int38msg    db      "hw int06 ",0
   779 000006BA 00                  <1>
   780 000006BB 687720696E74303720- <1> int39msg    db      "hw int07 ",0
   781 000006C4 00                  <1>
   782 000006C5 687720696E74303820- <1> int40msg    db      "hw int08 ",0
   783 000006CE 00                  <1>
   784 000006CF 687720696E74303920- <1> int41msg    db      "hw int09 ",0
   785 000006D8 00                  <1>
   786 000006D9 687720696E74313020- <1> int42msg    db      "hw int10 ",0
   787 000006E2 00                  <1>
   788 000006E3 687720696E74313120- <1> int43msg    db      "hw int11 ",0
   789 000006EC 00                  <1>
   790 000006ED 687720696E74313220- <1> int44msg    db      "hw int12 ",0
   791 000006F6 00                  <1>
   792 000006F7 687720696E74313320- <1> int45msg    db      "hw int13 ",0
   793 00000700 00                  <1>
   794 00000701 687720696E74313420- <1> int46msg    db      "hw int14 ",0
   795 0000070A 00                  <1>
   796 0000070B 687720696E74313520- <1> int47msg    db      "hw int15 ",0
   797 00000714 00                  <1>
   798                              <1> 
   799 00000715 73707572696F757320- <1> spuriousmsg db      "spurious int ",0
   800 0000071E 696E742000          <1>
   801 00000723 617069636572722069- <1> apicerrmsg  db      "apicerr int ",0
   802 0000072C 6E742000            <1>
   803 00000730 68692000            <1> himsg       db      "hi ",0
   804 00000734 756E6B6E6F776E2073- <1> int255msg           db  "unknown system call ",0
   805 0000073D 797374656D2063616C- <1>
   806 00000746 6C2000              <1>
   807                              <1> 
   808 00000749 766D206661756C743A- <1> intvmmsg            db  "vm fault: ",0
   809 00000752 2000                <1>
   810                              <1> 
   811                              <1> ; ---- IRQ hardware initialization ----
   812                              <1> 
   813                              <1> bits 16
   814                              <1> 
   815                              <1> irq_init_hardware :
   816                              <1> 
   817                              <1>     ; re-program the 8259's to move the hardware vectors out of the
   818                              <1>     ; soft int range ... C'mon, Intel was pretty clear about this!
   819                              <1> 
   820 00000754 B011                <1>     mov  al,0x11
   821 00000756 E620                <1>     out  0x20,al            ; init the 1st 8259
   822 00000758 B011                <1>     mov  al,0x11
   823 0000075A E6A0                <1>     out  0xA0,al            ; init the 2nd 8259
   824 0000075C B020                <1>     mov  al,apic0_irqbase
   825 0000075E E621                <1>     out  0x21,al            ; base for the 1st 8259
   826 00000760 B028                <1>     mov  al,apic1_irqbase
   827 00000762 E6A1                <1>     out  0xA1,al            ; base for the 2nd 8259
   828 00000764 B004                <1>     mov  al,0x04
   829 00000766 E621                <1>     out  0x21,al            ; set 1st 8259 as master
   830 00000768 B002                <1>     mov  al,0x02
   831 0000076A E6A1                <1>     out  0xA1,al            ; set 2nd 8259 as slave
   832 0000076C B001                <1>     mov  al,0x01
   833 0000076E E621                <1>     out  0x21,al
   834 00000770 B001                <1>     mov  al,0x01
   835 00000772 E6A1                <1>     out  0xA1,al
   836 00000774 B000                <1>     mov  al,0x00
   837 00000776 E621                <1>     out  0x21,al
   838 00000778 B000                <1>     mov  al,0x00
   839 0000077A E6A1                <1>     out  0xA1,al
   840 0000077C C3                  <1>     ret
   841                              <1> 
   842                              <1> bits 32
   843                              <1> 
   844                              <1> ; ----------
   845                              <1> 
   846                              <1> irq_init_bsp_apic_hardware :
   847                              <1>     ;jmp  no_apic
   848                              <1> 
   849                              <1>     ; ---- test for an apic
   850                              <1> 
   851 0000077D B801000000          <1>     mov  eax,1
   852 00000782 0FA2                <1>     cpuid
   853 00000784 83F801              <1>     cmp  eax,1
   854 00000787 724A                <1>     jb   no_apic
   855 00000789 81E200020000        <1>     and  edx,1 << 9         ; apic feature
   856 0000078F 7442                <1>     jz   no_apic
   857                              <1> 
   858                              <1> ;   mov  eax,[0xfee00370]
   859                              <1> ;   and  eax,0xffffff00
   860                              <1> ;   or   eax,apicerr_int
   861                              <1> ;   mov  [0xfee00370],eax   ; setup LVT3 error vector
   862                              <1> 
   863 00000791 A13000E0FE          <1>     mov  eax,[0xfee00030]
   864 00000796 25F0000000          <1>     and  eax,0xf0           ; see if it is a local apic
   865 0000079B 83F810              <1>     cmp  eax,0x10
   866 0000079E 7533                <1>     jnz  no_lapic
   867 000007A0 C605[18030000]01    <1>     mov  byte [enabled_lapic],0x1
   868                              <1> 
   869 000007A7 B8F0010000          <1>     mov  eax,0x000001f0     ; enable lapic, use spurious int 0xf0
   870 000007AC A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
   871 000007B1 B800000001          <1>     mov  eax,0x01000000
   872 000007B6 A3D000E0FE          <1>     mov  [0xfee000d0],eax   ; set our LDR
   873 000007BB B8FFFFFFFF          <1>     mov  eax,0xffffffff
   874 000007C0 A3E000E0FE          <1>     mov  [0xfee000e0],eax   ; set our DFR
   875                              <1> 
   876                              <1> ;    ; ---- enable the local apic via msr
   877                              <1> ; but apparently not needed ...
   878                              <1> ;    mov  ecx,0x1b
   879                              <1> ;    xor  edx,edx
   880                              <1> ; ;  mov  eax,0xfffff800
   881                              <1> ;    mov  eax,0x00000800
   882                              <1> ;    wrmsr
   883                              <1> ;    mov  eax,[0xfffff030]
   884                              <1> 
   885                              <1>     ; ---- visual indicator: lapic active
   886                              <1> 
   887 000007C5 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
   888 000007C9 8EE8                <1>     mov  gs,ax          
   889 000007CB 65C605320000002B    <1>     mov  byte [gs:25*2],'+'
   890                              <1> 
   891                              <1> no_apic :
   892                              <1> no_lapic :
   893 000007D3 C3                  <1>     ret
   894                              <1> 
   895                              <1> ; ----------
   896                              <1> 
   897                              <1> irq_init_ap_apic_hardware :
   898                              <1> 
   899                              <1>     ; ---- mtrr for 0xfee00000 -> strong uncachable (UC) ?
   900                              <1> 
   901 000007D4 50                  <1>     push eax                ; save cpu number
   902 000007D5 89C1                <1>     mov  ecx,eax
   903 000007D7 A0[18030000]        <1>     mov  al,[enabled_lapic]
   904 000007DC 08C0                <1>     or   al,al
   905 000007DE 7432                <1>     jz  no_lapic_init2
   906                              <1> 
   907 000007E0 BB00000001          <1>     mov  ebx,0x01000000
   908 000007E5 D3E3                <1>     shl  ebx,cl             ; bit mask based on cpu number
   909 000007E7 891DD000E0FE        <1>     mov  [0xfee000d0],ebx   ; set our LDR
   910                              <1> 
   911 000007ED A17003E0FE          <1>     mov  eax,[0xfee00370]
   912 000007F2 2500FFFFFF          <1>     and  eax,0xffffff00
   913 000007F7 0DF1000000          <1>     or   eax,apicerr_int
   914 000007FC A37003E0FE          <1>     mov  [0xfee00370],eax   ; setup LVT3 error vector
   915                              <1> 
   916 00000801 B8F0010000          <1>     mov  eax,0x00000100 + spurious_int  ; enable lapic
   917 00000806 A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
   918 0000080B 31C0                <1>     xor  eax,eax
   919 0000080D A3B000E0FE          <1>     mov  [0xfee000b0],eax   ; eoi anything outstanding
   920                              <1> no_lapic_init2 :
   921 00000812 58                  <1>     pop  eax
   922 00000813 C3                  <1>     ret
   923                              <1> 
   924                              <1> ; ---- IRQ handlers ----
   925                              <1> 
   926                              <1> align 4
   927                              <1> int_handler_div0 :
   928 00000814 56                  <1>     push esi
   929 00000815 BE[17050000]        <1>     mov  esi,int00msg
   930 0000081A E856040000          <1>     call irq_print_msg
   931 0000081F 5E                  <1>     pop  esi
   932 00000820 E9F0000000          <1>     jmp  int_handler_show_eip
   933                              <1> 
   934 00000825 90<rept>            <1> align 4
   935                              <1> int_handler_debug :
   936 00000828 56                  <1>     push esi
   937 00000829 BE[27050000]        <1>     mov  esi,int01msg
   938 0000082E E842040000          <1>     call irq_print_msg
   939 00000833 5E                  <1>     pop  esi
   940 00000834 E9DC000000          <1>     jmp  int_handler_show_eip
   941                              <1> 
   942 00000839 90<rept>            <1> align 4
   943                              <1> int_handler_nmi :
   944 0000083C 56                  <1>     push esi
   945 0000083D BE[38050000]        <1>     mov  esi,int02msg
   946 00000842 E82E040000          <1>     call irq_print_msg
   947 00000847 5E                  <1>     pop  esi
   948 00000848 E958040000          <1>     jmp  reboot_on_alt_key
   949                              <1> 
   950 0000084D 90<rept>            <1> align 4
   951                              <1> int_handler_brkp :
   952 00000850 56                  <1>     push esi
   953 00000851 BE[3D050000]        <1>     mov  esi,int03msg
   954 00000856 E81A040000          <1>     call irq_print_msg
   955 0000085B 5E                  <1>     pop  esi
   956 0000085C E9B4000000          <1>     jmp  int_handler_show_eip
   957                              <1> 
   958 00000861 90<rept>            <1> align 4
   959                              <1> int_handler_ovrflw :
   960 00000864 56                  <1>     push esi
   961 00000865 BE[53050000]        <1>     mov  esi,int04msg
   962 0000086A E806040000          <1>     call irq_print_msg
   963 0000086F 5E                  <1>     pop  esi
   964 00000870 E9A0000000          <1>     jmp  int_handler_show_eip
   965                              <1> 
   966 00000875 90<rept>            <1> align 4
   967                              <1> int_handler_bound :
   968 00000878 56                  <1>     push esi
   969 00000879 BE[67050000]        <1>     mov  esi,int05msg
   970 0000087E E8F2030000          <1>     call irq_print_msg
   971 00000883 5E                  <1>     pop  esi
   972 00000884 E98C000000          <1>     jmp  int_handler_show_eip
   973                              <1> 
   974 00000889 90<rept>            <1> align 4
   975                              <1> int_handler_invop :
   976 0000088C 56                  <1>     push esi
   977 0000088D BE[77050000]        <1>     mov  esi,int06msg
   978 00000892 E8DE030000          <1>     call irq_print_msg
   979 00000897 5E                  <1>     pop  esi
   980 00000898 EB7B                <1>     jmp  int_handler_show_eip
   981                              <1> 
   982 0000089A 90<rept>            <1> align 4
   983                              <1> int_handler_devna :
   984                              <1>     ;push esi
   985                              <1>     ;mov  esi,int07msg
   986                              <1>     ;call irq_print_msg
   987                              <1>     ;pop  esi
   988                              <1>     ; FIXME fxsave/fxrestore the fpu/sse/mmx regs
   989 0000089C 0F06                <1>     clts
   990 0000089E CF                  <1>     iret
   991                              <1> 
   992 0000089F 90                  <1> align 4
   993                              <1> int_handler_cpsego :
   994 000008A0 56                  <1>     push esi
   995 000008A1 BE[A9050000]        <1>     mov  esi,int09msg
   996 000008A6 E8CA030000          <1>     call irq_print_msg
   997 000008AB 5E                  <1>     pop  esi
   998 000008AC EB67                <1>     jmp  int_handler_show_eip
   999                              <1> 
  1000 000008AE 90<rept>            <1> align 4
  1001                              <1> int_handler_segnp :
  1002                              <1>     ; ec = seg selector
  1003 000008B0 56                  <1>     push esi
  1004 000008B1 BE[D3050000]        <1>     mov  esi,int11msg
  1005 000008B6 E8BA030000          <1>     call irq_print_msg
  1006 000008BB 5E                  <1>     pop  esi
  1007 000008BC EB32                <1>     jmp  int_handler_show_ec_eip
  1008                              <1> 
  1009 000008BE 90<rept>            <1> align 4
  1010                              <1> int_handler_stkflt :
  1011                              <1>     ; ec = seg selector
  1012 000008C0 56                  <1>     push esi
  1013 000008C1 BE[E8050000]        <1>     mov  esi,int12msg
  1014 000008C6 E8AA030000          <1>     call irq_print_msg
  1015 000008CB 5E                  <1>     pop  esi
  1016 000008CC B904000000          <1>     mov  ecx,4
  1017 000008D1 83C302              <1>     add  ebx,2
  1018                              <1> int_handler_show_stack_loop :
  1019 000008D4 58                  <1>     pop  eax
  1020 000008D5 E84BFBFFFF          <1>     call putx_vga
  1021 000008DA E2F8                <1>     loop int_handler_show_stack_loop
  1022 000008DC E9C4030000          <1>     jmp  reboot_on_alt_key
  1023                              <1> 
  1024 000008E1 90<rept>            <1> align 4
  1025                              <1> int_handler_gpf :
  1026                              <1>     ; ec = various ...
  1027                              <1>     ;test dword [esp+0xc],1 << 17    ; check the eflags vm bit
  1028                              <1>     ;jnz  int_handler_vm_gpf
  1029                              <1> 
  1030 000008E4 56                  <1>     push esi
  1031 000008E5 BE[F5050000]        <1>     mov  esi,int13msg
  1032 000008EA E886030000          <1>     call irq_print_msg
  1033 000008EF 5E                  <1>     pop  esi
  1034                              <1> int_handler_show_ec_eip :
  1035 000008F0 65C60365            <1>     mov  byte [gs:ebx],'e'
  1036 000008F4 83C302              <1>     add  ebx,2
  1037 000008F7 65C60363            <1>     mov  byte [gs:ebx],'c'
  1038 000008FB 83C302              <1>     add  ebx,2
  1039 000008FE 65C6033D            <1>     mov  byte [gs:ebx],'='
  1040 00000902 83C302              <1>     add  ebx,2
  1041 00000905 58                  <1>     pop  eax                ; ec
  1042 00000906 E80AFBFFFF          <1>     call putbx_vga
  1043 0000090B 83EB02              <1>     sub  ebx,2
  1044 0000090E 65C60320            <1>     mov  byte [gs:ebx],' '
  1045 00000912 83C302              <1>     add  ebx,2
  1046                              <1> int_handler_show_eip :
  1047 00000915 65C60363            <1>     mov  byte [gs:ebx],'c'
  1048 00000919 83C302              <1>     add  ebx,2
  1049 0000091C 65C60373            <1>     mov  byte [gs:ebx],'s'
  1050 00000920 83C302              <1>     add  ebx,2
  1051 00000923 65C6033A            <1>     mov  byte [gs:ebx],':'
  1052 00000927 83C302              <1>     add  ebx,2
  1053 0000092A 65C60365            <1>     mov  byte [gs:ebx],'e'
  1054 0000092E 83C302              <1>     add  ebx,2
  1055 00000931 65C60369            <1>     mov  byte [gs:ebx],'i'
  1056 00000935 83C302              <1>     add  ebx,2
  1057 00000938 65C60370            <1>     mov  byte [gs:ebx],'p'
  1058 0000093C 83C302              <1>     add  ebx,2
  1059 0000093F 65C6033D            <1>     mov  byte [gs:ebx],'='
  1060 00000943 83C302              <1>     add  ebx,2
  1061 00000946 5A                  <1>     pop  edx                ; eip
  1062 00000947 58                  <1>     pop  eax                ; cs
  1063 00000948 E8D8FAFFFF          <1>     call putx_vga
  1064 0000094D 83EB02              <1>     sub  ebx,2
  1065 00000950 65C6033A            <1>     mov  byte [gs:ebx],':'
  1066 00000954 83C302              <1>     add  ebx,2
  1067 00000957 89D0                <1>     mov  eax,edx
  1068 00000959 E8C7FAFFFF          <1>     call putx_vga
  1069 0000095E E942030000          <1>     jmp  reboot_on_alt_key
  1070                              <1> 
  1071                              <1> int_handler_vm_gpf :
  1072 00000963 53                  <1>     push ebx
  1073                              <1>     ;mov  ebx,[esp+8]        ; faulter's eip
  1074 00000964 2E8A1B              <1>     mov  bl,[cs:ebx]        ; get the opcode that caused the fault
  1075 00000967 80FBF4              <1>     cmp  bl,0xf4            ; 'hlt' is ok
  1076 0000096A 7452                <1>     jz   int_handler_vm_normal_return
  1077                              <1> 
  1078 0000096C 56                  <1>     push esi
  1079 0000096D 50                  <1>     push eax
  1080 0000096E 53                  <1>     push ebx
  1081 0000096F BE[49070000]        <1>     mov  esi,intvmmsg
  1082 00000974 E8FC020000          <1>     call irq_print_msg
  1083 00000979 65C6036F            <1>     mov  byte [gs:ebx],'o'
  1084 0000097D 83C302              <1>     add  ebx,2
  1085 00000980 65C60370            <1>     mov  byte [gs:ebx],'p'
  1086 00000984 83C302              <1>     add  ebx,2
  1087 00000987 65C60363            <1>     mov  byte [gs:ebx],'c'
  1088 0000098B 83C302              <1>     add  ebx,2
  1089 0000098E 65C6036F            <1>     mov  byte [gs:ebx],'o'
  1090 00000992 83C302              <1>     add  ebx,2
  1091 00000995 65C60364            <1>     mov  byte [gs:ebx],'d'
  1092 00000999 83C302              <1>     add  ebx,2
  1093 0000099C 65C60365            <1>     mov  byte [gs:ebx],'e'
  1094 000009A0 83C302              <1>     add  ebx,2
  1095 000009A3 65C60328            <1>     mov  byte [gs:ebx],'('
  1096 000009A7 83C302              <1>     add  ebx,2
  1097 000009AA 58                  <1>     pop  eax
  1098 000009AB 25FF000000          <1>     and  eax,0xff
  1099 000009B0 E860FAFFFF          <1>     call putbx_vga
  1100 000009B5 83C302              <1>     add  ebx,2
  1101 000009B8 65C60329            <1>     mov  byte [gs:ebx],')'
  1102 000009BC 58                  <1>     pop  eax
  1103 000009BD 5E                  <1>     pop  esi
  1104                              <1> int_handler_vm_normal_return :
  1105 000009BE 5B                  <1>     pop  ebx
  1106                              <1> 
  1107 000009BF FF74240C            <1>     push dword [esp+0xc]    ; eflags
  1108 000009C3 9D                  <1>     popf                    ; restore the VM and NT flags
  1109 000009C4 CF                  <1>     iret                    ; chain back via nested task
  1110                              <1>                             ; from v86 tss to original caller
  1111                              <1> 
  1112 000009C5 90<rept>            <1> align 4
  1113                              <1> int_handler_pgflt :
  1114 000009C8 58                  <1>     pop  eax
  1115 000009C9 50                  <1>     push eax
  1116 000009CA A904000000          <1>     test eax,0x4                        ; user mode or supervisor?
  1117 000009CF 7407                <1>     jz   int_handler_pgflt_bad_kaddr    ; if not, kernel failed
  1118                              <1> 
  1119                              <1> int_handler_pgflt_bad_uaddr :
  1120 000009D1 BE[27060000]        <1>     mov  esi,int14umsg
  1121 000009D6 EB05                <1>     jmp  int_handler_pgflt_msg
  1122                              <1> 
  1123                              <1> int_handler_pgflt_bad_kaddr :
  1124 000009D8 BE[0F060000]        <1>     mov  esi,int14kmsg
  1125                              <1> 
  1126                              <1> int_handler_pgflt_msg :
  1127 000009DD E893020000          <1>     call irq_print_msg
  1128 000009E2 0F20D0              <1>     mov  eax,cr2
  1129 000009E5 E83BFAFFFF          <1>     call putx_vga                       ; print the addres of the fault
  1130 000009EA E901FFFFFF          <1>     jmp  int_handler_show_ec_eip
  1131                              <1> 
  1132 000009EF 90                  <1> align 4
  1133                              <1> int_handler_fpuerr :
  1134 000009F0 56                  <1>     push esi
  1135 000009F1 BE[3C060000]        <1>     mov  esi,int16msg
  1136 000009F6 E87A020000          <1>     call irq_print_msg
  1137                              <1>     ; FIXME flags identify error
  1138                              <1>     ;   IS - FPU stack overflow
  1139                              <1>     ;   IA - Invalid arithmetic operation
  1140                              <1>     ;   Z  - Divide by zero
  1141                              <1>     ;   D  - Source operand is a denormal number
  1142                              <1>     ;   O  - Overflow in result
  1143                              <1>     ;   U  - Underflow in result
  1144                              <1>     ;   P  - Inexact result
  1145 000009FB E915FFFFFF          <1>     jmp  int_handler_show_eip
  1146                              <1> 
  1147                              <1> align 4
  1148                              <1> int_handler_algnchk :
  1149                              <1>     ; ec = zero
  1150 00000A00 56                  <1>     push esi
  1151 00000A01 BE[50060000]        <1>     mov  esi,int17msg
  1152 00000A06 E86A020000          <1>     call irq_print_msg
  1153 00000A0B 5E                  <1>     pop  esi
  1154 00000A0C 58                  <1>     pop  eax                    ; toss the ec
  1155 00000A0D E903FFFFFF          <1>     jmp  int_handler_show_eip
  1156                              <1> 
  1157 00000A12 90<rept>            <1> align 4
  1158                              <1> int_handler_machchk :
  1159 00000A14 56                  <1>     push esi
  1160 00000A15 BE[61060000]        <1>     mov  esi,int18msg
  1161 00000A1A E856020000          <1>     call irq_print_msg
  1162 00000A1F 5E                  <1>     pop  esi
  1163 00000A20 E9F0FEFFFF          <1>     jmp  int_handler_show_eip
  1164                              <1> 
  1165 00000A25 90<rept>            <1> align 4
  1166                              <1> int_handler_simdfpe :
  1167 00000A28 56                  <1>     push esi
  1168 00000A29 BE[70060000]        <1>     mov  esi,int19msg
  1169 00000A2E E842020000          <1>     call irq_print_msg
  1170 00000A33 5E                  <1>     pop  esi
  1171 00000A34 E9DCFEFFFF          <1>     jmp  int_handler_show_eip
  1172                              <1> 
  1173 00000A39 90<rept>            <1> align 4
  1174                              <1> int_handler_timer :     
  1175                              <1>     ;cli
  1176 00000A3C 60                  <1>     pusha
  1177 00000A3D 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
  1178 00000A41 8EE8                <1>     mov  gs,ax          
  1179 00000A43 658A1D01000000      <1>     mov  bl,byte [gs:1]     ; inc the color of the first two chars
  1180 00000A4A FEC3                <1>     inc  bl
  1181 00000A4C 80E30F              <1>     and  bl,0xf             ; just the foreground
  1182 00000A4F 65881D01000000      <1>     mov  byte [gs:1],bl
  1183 00000A56 65881D03000000      <1>     mov  byte [gs:3],bl
  1184                              <1> 
  1185                              <1>     ; ---- wakeup any sleeping cpus (see syscall_sleep)
  1186                              <1> 
  1187 00000A5D A0[18030000]        <1>     mov  al,[enabled_lapic]
  1188 00000A62 08C0                <1>     or   al,al
  1189 00000A64 741B                <1>     jz   no_sleepers
  1190                              <1> 
  1191                              <1>     ; the race here is not important, we'll catch them on the next tick
  1192                              <1> 
  1193 00000A66 A1[1D030000]        <1>     mov  eax,[sleepers]
  1194 00000A6B 09C0                <1>     or   eax,eax
  1195 00000A6D 7412                <1>     jz   no_sleepers
  1196 00000A6F C1E018              <1>     shl  eax,24                     ; FIXME can only handle 8 cpus
  1197 00000A72 A31003E0FE          <1>     mov  dword [0xfee00310],eax     ; via the destination register ...
  1198 00000A77 B8FE480000          <1>     mov  eax,0x04800 + wakeup_int   ; no shrthnd, fixed, logical, edge
  1199 00000A7C A30003E0FE          <1>     mov  dword [0xfee00300],eax
  1200                              <1> 
  1201                              <1> no_sleepers :
  1202 00000A81 B020                <1>     mov  al,0x20        
  1203 00000A83 E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1204 00000A85 61                  <1>     popa
  1205 00000A86 CF                  <1>     iret                
  1206                              <1> 
  1207 00000A87 90                  <1> align 4
  1208                              <1> int_handler_kbd :
  1209                              <1>     ;cli
  1210 00000A88 B020                <1>     mov  al,0x20
  1211 00000A8A E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1212                              <1> 
  1213 00000A8C 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
  1214 00000A90 8EE8                <1>     mov  gs,ax          
  1215                              <1> 
  1216 00000A92 53                  <1>     push ebx
  1217 00000A93 BB3C000000          <1>     mov  ebx,30*2
  1218 00000A98 E460                <1>     in   al,0x60
  1219 00000A9A 50                  <1>     push eax
  1220 00000A9B E875F9FFFF          <1>     call putbx_vga
  1221 00000AA0 58                  <1>     pop  eax
  1222                              <1> 
  1223 00000AA1 3C5B                <1>     cmp  al,0x5b            ; scan code for "the windows key"
  1224 00000AA3 0F8403020000        <1>     jz   reboot
  1225                              <1> 
  1226 00000AA9 65A044000000        <1>     mov  al,[gs:34*2]
  1227 00000AAF FEC0                <1>     inc  al
  1228 00000AB1 65A244000000        <1>     mov  [gs:34*2],al       ; change a character on screen
  1229                              <1> 
  1230 00000AB7 5B                  <1>     pop  ebx
  1231 00000AB8 CF                  <1>     iret
  1232                              <1> 
  1233 00000AB9 90<rept>            <1> align 4
  1234                              <1> int_handler_hw02 :
  1235 00000ABC 56                  <1>     push esi
  1236 00000ABD BE[89060000]        <1>     mov  esi,int34msg
  1237 00000AC2 E8AE010000          <1>     call irq_print_msg
  1238 00000AC7 5E                  <1>     pop  esi
  1239 00000AC8 E9D8010000          <1>     jmp  reboot_on_alt_key
  1240                              <1> 
  1241 00000ACD 90<rept>            <1> align 4
  1242                              <1> int_handler_hw03 :
  1243 00000AD0 56                  <1>     push esi
  1244 00000AD1 BE[93060000]        <1>     mov  esi,int35msg
  1245 00000AD6 E89A010000          <1>     call irq_print_msg
  1246 00000ADB 5E                  <1>     pop  esi
  1247 00000ADC E9C4010000          <1>     jmp  reboot_on_alt_key
  1248                              <1> 
  1249 00000AE1 90<rept>            <1> align 4
  1250                              <1> int_handler_hw04 :
  1251 00000AE4 56                  <1>     push esi
  1252 00000AE5 BE[9D060000]        <1>     mov  esi,int36msg
  1253 00000AEA E886010000          <1>     call irq_print_msg
  1254 00000AEF 5E                  <1>     pop  esi
  1255 00000AF0 E9B0010000          <1>     jmp  reboot_on_alt_key
  1256                              <1> 
  1257 00000AF5 90<rept>            <1> align 4
  1258                              <1> int_handler_hw05 :
  1259 00000AF8 56                  <1>     push esi
  1260 00000AF9 BE[A7060000]        <1>     mov  esi,int37msg
  1261 00000AFE E872010000          <1>     call irq_print_msg
  1262 00000B03 5E                  <1>     pop  esi
  1263 00000B04 E99C010000          <1>     jmp  reboot_on_alt_key
  1264                              <1> 
  1265 00000B09 90<rept>            <1> align 4
  1266                              <1> int_handler_hw06 :
  1267 00000B0C 56                  <1>     push esi
  1268 00000B0D BE[B1060000]        <1>     mov  esi,int38msg
  1269 00000B12 E85E010000          <1>     call irq_print_msg
  1270 00000B17 5E                  <1>     pop  esi
  1271 00000B18 E988010000          <1>     jmp  reboot_on_alt_key
  1272                              <1> 
  1273 00000B1D 90<rept>            <1> align 4
  1274                              <1> int_handler_hw07 :
  1275 00000B20 56                  <1>     push esi
  1276 00000B21 BE[BB060000]        <1>     mov  esi,int39msg
  1277 00000B26 E84A010000          <1>     call irq_print_msg
  1278 00000B2B 5E                  <1>     pop  esi
  1279 00000B2C E974010000          <1>     jmp  reboot_on_alt_key
  1280                              <1> 
  1281 00000B31 90<rept>            <1> align 4
  1282                              <1> int_handler_hw08 :
  1283 00000B34 56                  <1>     push esi
  1284 00000B35 BE[C5060000]        <1>     mov  esi,int40msg
  1285 00000B3A E836010000          <1>     call irq_print_msg
  1286 00000B3F 5E                  <1>     pop  esi
  1287 00000B40 E960010000          <1>     jmp  reboot_on_alt_key
  1288                              <1> 
  1289 00000B45 90<rept>            <1> align 4
  1290                              <1> int_handler_hw09 :
  1291 00000B48 56                  <1>     push esi
  1292 00000B49 BE[CF060000]        <1>     mov  esi,int41msg
  1293 00000B4E E822010000          <1>     call irq_print_msg
  1294 00000B53 5E                  <1>     pop  esi
  1295 00000B54 E94C010000          <1>     jmp  reboot_on_alt_key
  1296                              <1> 
  1297 00000B59 90<rept>            <1> align 4
  1298                              <1> int_handler_hw10 :
  1299 00000B5C 56                  <1>     push esi
  1300 00000B5D BE[D9060000]        <1>     mov  esi,int42msg
  1301 00000B62 E80E010000          <1>     call irq_print_msg
  1302 00000B67 5E                  <1>     pop  esi
  1303 00000B68 E938010000          <1>     jmp  reboot_on_alt_key
  1304                              <1> 
  1305 00000B6D 90<rept>            <1> align 4
  1306                              <1> int_handler_hw11 :
  1307 00000B70 56                  <1>     push esi
  1308 00000B71 BE[E3060000]        <1>     mov  esi,int43msg
  1309 00000B76 E8FA000000          <1>     call irq_print_msg
  1310 00000B7B 5E                  <1>     pop  esi
  1311 00000B7C E924010000          <1>     jmp  reboot_on_alt_key
  1312                              <1> 
  1313 00000B81 90<rept>            <1> align 4
  1314                              <1> int_handler_hw12 :
  1315 00000B84 56                  <1>     push esi
  1316 00000B85 BE[ED060000]        <1>     mov  esi,int44msg
  1317 00000B8A E8E6000000          <1>     call irq_print_msg
  1318 00000B8F 5E                  <1>     pop  esi
  1319 00000B90 E910010000          <1>     jmp  reboot_on_alt_key
  1320                              <1> 
  1321 00000B95 90<rept>            <1> align 4
  1322                              <1> int_handler_hw13 :
  1323 00000B98 56                  <1>     push esi
  1324 00000B99 BE[F7060000]        <1>     mov  esi,int45msg
  1325 00000B9E E8D2000000          <1>     call irq_print_msg
  1326 00000BA3 5E                  <1>     pop  esi
  1327 00000BA4 E9FC000000          <1>     jmp  reboot_on_alt_key
  1328                              <1> 
  1329 00000BA9 90<rept>            <1> align 4
  1330                              <1> int_handler_hw14 :
  1331 00000BAC 56                  <1>     push esi
  1332 00000BAD BE[01070000]        <1>     mov  esi,int46msg
  1333 00000BB2 E8BE000000          <1>     call irq_print_msg
  1334 00000BB7 5E                  <1>     pop  esi
  1335 00000BB8 E9E8000000          <1>     jmp  reboot_on_alt_key
  1336                              <1> 
  1337 00000BBD 90<rept>            <1> align 4
  1338                              <1> int_handler_hw15 :
  1339 00000BC0 56                  <1>     push esi
  1340 00000BC1 BE[0B070000]        <1>     mov  esi,int47msg
  1341 00000BC6 E8AA000000          <1>     call irq_print_msg
  1342 00000BCB 5E                  <1>     pop  esi
  1343 00000BCC E9D4000000          <1>     jmp  reboot_on_alt_key
  1344                              <1> 
  1345                              <1> ; called via the double fault task
  1346 00000BD1 90<rept>            <1> align 4
  1347                              <1> int_handler_tg_dblflt :
  1348 00000BD4 56                  <1>     push esi
  1349 00000BD5 BE[9B050000]        <1>     mov  esi,int08msg
  1350 00000BDA E896000000          <1>     call irq_print_msg
  1351 00000BDF 5E                  <1>     pop  esi
  1352 00000BE0 E9C0000000          <1>     jmp  reboot_on_alt_key
  1353                              <1> 
  1354                              <1> ; called via the invalid tss task
  1355 00000BE5 90<rept>            <1> align 4
  1356                              <1> int_handler_tg_invtss :
  1357 00000BE8 56                  <1>     push esi
  1358 00000BE9 BE[C6050000]        <1>     mov  esi,int10msg
  1359 00000BEE E882000000          <1>     call irq_print_msg
  1360 00000BF3 5E                  <1>     pop  esi
  1361                              <1>     ; FIXME need to go back to previous tss to get ec via that stack
  1362 00000BF4 83C302              <1>     add  ebx,2
  1363 00000BF7 58                  <1>     pop  eax                ; ec == invalid tss selector
  1364 00000BF8 E828F8FFFF          <1>     call putx_vga
  1365 00000BFD E9A3000000          <1>     jmp  reboot_on_alt_key
  1366                              <1> 
  1367 00000C02 90<rept>            <1> align 4
  1368                              <1> int_handler_spurious :
  1369 00000C04 56                  <1>     push esi
  1370 00000C05 BE[15070000]        <1>     mov  esi,spuriousmsg
  1371 00000C0A E866000000          <1>     call irq_print_msg
  1372 00000C0F 5E                  <1>     pop  esi
  1373 00000C10 CF                  <1>     iret
  1374                              <1> 
  1375 00000C11 90<rept>            <1> align 4
  1376                              <1> int_handler_apicerr :
  1377 00000C14 56                  <1>     push esi
  1378 00000C15 BE[23070000]        <1>     mov  esi,apicerrmsg
  1379 00000C1A E856000000          <1>     call irq_print_msg
  1380 00000C1F 5E                  <1>     pop  esi
  1381 00000C20 CF                  <1>     iret
  1382                              <1> 
  1383                              <1> ; serves only to eoi the fixed ipi used for sleep wakeup
  1384 00000C21 90<rept>            <1> align 4
  1385                              <1> wakeup :
  1386 00000C24 50                  <1>     push eax
  1387 00000C25 31C0                <1>     xor  eax,eax
  1388 00000C27 A3B000E0FE          <1>     mov  [0xfee000b0],eax    ; lapic eoi
  1389 00000C2C 58                  <1>     pop  eax
  1390 00000C2D CF                  <1>     iret
  1391                              <1> 
  1392                              <1> 
  1393 00000C2E 90<rept>            <1> align 4
  1394                              <1> ; %if ($ >= 0x8000) bomb
  1395                              <1> sysent :
  1396 00000C30 3D00020000          <1>     cmp  eax,0x0200
  1397 00000C35 0F84A9020000        <1>     jz   syscall_klog
  1398 00000C3B 3D00100000          <1>     cmp  eax,0x1000
  1399 00000C40 0F84AD020000        <1>     jz   syscall_ncpus
  1400 00000C46 3D00200000          <1>     cmp  eax,0x2000
  1401 00000C4B 0F8407030000        <1>     jz   syscall_sleep
  1402 00000C51 3D00210000          <1>     cmp  eax,0x2100
  1403 00000C56 0F849D020000        <1>     jz   syscall_new_thread
  1404 00000C5C 3D00270000          <1>     cmp  eax,0x2700
  1405 00000C61 0F8426030000        <1>     jz   syscall_request_pmem_access
  1406 00000C67 BE[34070000]        <1>     mov  esi,int255msg
  1407 00000C6C E804000000          <1>     call irq_print_msg
  1408 00000C71 31C0                <1>     xor  eax,eax
  1409 00000C73 48                  <1>     dec  eax
  1410 00000C74 CF                  <1>     iret
  1411                              <1> 
  1412                              <1> 
  1413                              <1> ; ---- IRQ support code ---- 
  1414                              <1> 
  1415                              <1> irq_print_msg :
  1416 00000C75 BBA0000000          <1>     mov  ebx,160            ; line 2
  1417 00000C7A A0[18030000]        <1>     mov  al,[enabled_lapic]
  1418 00000C7F 08C0                <1>     or   al,al
  1419 00000C81 741D                <1>     jz   skip_cpumsg
  1420                              <1> 
  1421 00000C83 56                  <1>     push esi
  1422 00000C84 BE[13050000]        <1>     mov  esi,cpumsg
  1423 00000C89 E870F7FFFF          <1>     call puts_vga
  1424 00000C8E A12000E0FE          <1>     mov  eax,[0xfee00020]   ; print our apic id
  1425 00000C93 C1E818              <1>     shr  eax,24
  1426 00000C96 83C030              <1>     add  eax,'0'
  1427 00000C99 658803              <1>     mov  [gs:ebx],al
  1428 00000C9C 83C304              <1>     add  ebx,4
  1429 00000C9F 5E                  <1>     pop  esi
  1430                              <1> 
  1431                              <1> skip_cpumsg :
  1432 00000CA0 E959F7FFFF          <1>     jmp  puts_vga
  1433                              <1> 
  1434                              <1> 
  1435                              <1> reboot_on_alt_key :
  1436 00000CA5 FA                  <1>     cli
  1437                              <1> reboot_on_alt_key_loop :
  1438 00000CA6 E460                <1>     in   al,0x60
  1439 00000CA8 3C38                <1>     cmp  al,'8'             ; part of the scan code for ALT
  1440 00000CAA 75FA                <1>     jnz  reboot_on_alt_key_loop
  1441                              <1> reboot :
  1442 00000CAC FA                  <1>     cli
  1443 00000CAD 0F011D[D90C0000]    <1>     lidt [reboot_idt]       ; restore boot idt (helps qemu ...)
  1444 00000CB4 EA[BB0C0000]2800    <1>     jmp  rmcssel:reboot_exit_pmode      ; thankyou hpa
  1445                              <1> reboot_exit_pmode :
  1446                              <1> bits 16
  1447 00000CBB B83000              <1>     mov  ax,rmdssel
  1448 00000CBE 8ED8                <1>     mov  ds,ax
  1449 00000CC0 8EC0                <1>     mov  es,ax
  1450 00000CC2 8ED0                <1>     mov  ss,ax
  1451 00000CC4 8EE0                <1>     mov  fs,ax
  1452 00000CC6 8EE8                <1>     mov  gs,ax
  1453                              <1> 
  1454 00000CC8 0F20C0              <1>     mov  eax,cr0
  1455 00000CCB 6625FEFFFF7F        <1>     and  eax,0x7ffffffe
  1456 00000CD1 0F22C0              <1>     mov  cr0,eax            ; disable pmode and paging
  1457 00000CD4 EA0000FFFF          <1>     jmp  0xffff:0           ; jump to the warm start vector and
  1458                              <1>                             ; flush the I prefetch queue all at once
  1459                              <1> 
  1460                              <1> reboot_idt :
  1461 00000CD9 FFFF                <1>     dw 0xffff
  1462 00000CDB 00000000            <1>     dd 0
  1463                              <1> 
  1464                              <1> 
  1465                              <1> ; ---- IDT initialization table ---- 
  1466                              <1> ;
  1467                              <1> ; One dw (2 bytes per vector) is used which means that all
  1468                              <1> ; int_handler entry points must reside below 0x10000!
  1469                              <1> ;
  1470                              <1> ; And since all int_handler routines are 4 byte aligned,
  1471                              <1> ; the bottom two bits are available to indicate type.
  1472                              <1> ; These bits index into the irq_types table below.
  1473                              <1> 
  1474 00000CDF 90                  <1> align 4
  1475                              <1> 
  1476                              <1> ; note: these are not gdt/ldt descriptors (see swdev3a 6.11 pg 228)
  1477                              <1> 
  1478 00000CE0 8E                  <1> irq_types   db  0x8e            ; dpl=0 32bit interrupt gate (sets IF flag)
  1479 00000CE1 EE                  <1>             db  0xee            ; dpl=3 32bit app (ring3) interrupt gate
  1480 00000CE2 85                  <1>             db  0x85            ; dpl=0 32bit task gate
  1481 00000CE3 8F                  <1>             db  0x8f            ; dpl=0 32bit trap gate (does not set IF flag)
  1482                              <1> 
  1483                              <1> ; all handlers/selectors are 4 byte aligned - this gives us
  1484                              <1> ; two bits to use to designate 1 of 4 types of idt descriptors ...
  1485                              <1> 
  1486                              <1> irqt_intr   equ 0
  1487                              <1> irqt_app    equ 1
  1488                              <1> irqt_task   equ 2
  1489                              <1> irqt_trap   equ 3
  1490                              <1> 
  1491                              <1> irq_setup_table:
  1492                              <1>     ; cpu defined
  1493 00000CE4 [1708]              <1>     dw  int_handler_div0      + irqt_trap ; 0
  1494 00000CE6 [2B08]              <1>     dw  int_handler_debug     + irqt_trap ; 1
  1495 00000CE8 [3C08]              <1>     dw  int_handler_nmi       + irqt_intr ; 2
  1496 00000CEA [5108]              <1>     dw  int_handler_brkp      + irqt_app  ; 3
  1497 00000CEC [6508]              <1>     dw  int_handler_ovrflw    + irqt_app  ; 4
  1498 00000CEE [7908]              <1>     dw  int_handler_bound     + irqt_app  ; 5
  1499 00000CF0 [8F08]              <1>     dw  int_handler_invop     + irqt_trap ; 6
  1500 00000CF2 [9F08]              <1>     dw  int_handler_devna     + irqt_trap ; 7
  1501 00000CF4 4200                <1>     dw  tasksel_f08           + irqt_task ; 8   double fault
  1502 00000CF6 [A308]              <1>     dw  int_handler_cpsego    + irqt_trap ; 9
  1503 00000CF8 4A00                <1>     dw  tasksel_f10           + irqt_task ; 10  invalid tss
  1504 00000CFA [B308]              <1>     dw  int_handler_segnp     + irqt_trap ; 11
  1505 00000CFC [C308]              <1>     dw  int_handler_stkflt    + irqt_trap ; 12
  1506 00000CFE [E708]              <1>     dw  int_handler_gpf       + irqt_trap ; 13
  1507 00000D00 [C809]              <1>     dw  int_handler_pgflt     + irqt_intr ; 14
  1508 00000D02 0000                <1>     dw  0                                 ; 15  Intel reserved
  1509 00000D04 [F309]              <1>     dw  int_handler_fpuerr    + irqt_trap ; 16
  1510 00000D06 [030A]              <1>     dw  int_handler_algnchk   + irqt_trap ; 17
  1511 00000D08 [170A]              <1>     dw  int_handler_machchk   + irqt_trap ; 18
  1512 00000D0A [2B0A]              <1>     dw  int_handler_simdfpe   + irqt_trap ; 19
  1513 00000D0C 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0
  1514 00000D15 000000000000000000- <1>
  1515 00000D1E 000000000000        <1>
  1516                              <1>     ; hw defined
  1517                              <1> apic0_irqbase equ ($ - irq_setup_table)/2
  1518 00000D24 [3C0A]              <1>     dw  int_handler_timer     + irqt_intr ; 32  0x20
  1519 00000D26 [880A]              <1>     dw  int_handler_kbd       + irqt_intr ; 33
  1520 00000D28 [BC0A]              <1>     dw  int_handler_hw02      + irqt_intr ; 34
  1521 00000D2A [D00A]              <1>     dw  int_handler_hw03      + irqt_intr ; 35
  1522 00000D2C [E40A]              <1>     dw  int_handler_hw04      + irqt_intr ; 36
  1523 00000D2E [F80A]              <1>     dw  int_handler_hw05      + irqt_intr ; 37
  1524 00000D30 [0C0B]              <1>     dw  int_handler_hw06      + irqt_intr ; 38
  1525 00000D32 [200B]              <1>     dw  int_handler_hw07      + irqt_intr ; 39
  1526                              <1> apic1_irqbase equ ($ - irq_setup_table)/2
  1527 00000D34 [340B]              <1>     dw  int_handler_hw08      + irqt_intr ; 40
  1528 00000D36 [480B]              <1>     dw  int_handler_hw09      + irqt_intr ; 41
  1529 00000D38 [5C0B]              <1>     dw  int_handler_hw10      + irqt_intr ; 42
  1530 00000D3A [700B]              <1>     dw  int_handler_hw11      + irqt_intr ; 43
  1531 00000D3C [840B]              <1>     dw  int_handler_hw12      + irqt_intr ; 44
  1532 00000D3E [980B]              <1>     dw  int_handler_hw13      + irqt_intr ; 45
  1533 00000D40 [AC0B]              <1>     dw  int_handler_hw14      + irqt_intr ; 46
  1534 00000D42 [C00B]              <1>     dw  int_handler_hw15      + irqt_intr ; 47  0x2f
  1535                              <1>     ; undefined - hw can expand here
  1536 00000D44 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x30
  1537 00000D4D 000000000000000000- <1>
  1538 00000D56 000000000000000000- <1>
  1539 00000D5F 0000000000          <1>
  1540 00000D64 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x40
  1541 00000D6D 000000000000000000- <1>
  1542 00000D76 000000000000000000- <1>
  1543 00000D7F 0000000000          <1>
  1544 00000D84 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x50
  1545 00000D8D 000000000000000000- <1>
  1546 00000D96 000000000000000000- <1>
  1547 00000D9F 0000000000          <1>
  1548 00000DA4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x60
  1549 00000DAD 000000000000000000- <1>
  1550 00000DB6 000000000000000000- <1>
  1551 00000DBF 0000000000          <1>
  1552 00000DC4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x70
  1553 00000DCD 000000000000000000- <1>
  1554 00000DD6 000000000000000000- <1>
  1555 00000DDF 0000000000          <1>
  1556 00000DE4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x80
  1557 00000DED 000000000000000000- <1>
  1558 00000DF6 000000000000000000- <1>
  1559 00000DFF 0000000000          <1>
  1560 00000E04 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x90
  1561 00000E0D 000000000000000000- <1>
  1562 00000E16 000000000000000000- <1>
  1563 00000E1F 0000000000          <1>
  1564 00000E24 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xa0
  1565 00000E2D 000000000000000000- <1>
  1566 00000E36 000000000000000000- <1>
  1567 00000E3F 0000000000          <1>
  1568                              <1>     ; set up cpu thread management tss gates
  1569                              <1>     ; these map 1-to-1 to cpus
  1570                              <1> first_thread_tss_gate equ ($ - irq_setup_table)/2
  1571 00000E44 5A00                <1>     dw  tasksel_u00           + irqt_task
  1572 00000E46 6A00                <1>     dw  tasksel_u01           + irqt_task
  1573 00000E48 7A00                <1>     dw  tasksel_u02           + irqt_task
  1574 00000E4A 8A00                <1>     dw  tasksel_u03           + irqt_task
  1575 00000E4C 9A00                <1>     dw  tasksel_u04           + irqt_task
  1576 00000E4E AA00                <1>     dw  tasksel_u05           + irqt_task
  1577 00000E50 BA00                <1>     dw  tasksel_u06           + irqt_task
  1578 00000E52 CA00                <1>     dw  tasksel_u07           + irqt_task
  1579                              <1> %ifdef FOO
  1580                              <1>     dw  tasksel_u08           + irqt_task
  1581                              <1>     dw  tasksel_u09           + irqt_task
  1582                              <1>     dw  tasksel_u10           + irqt_task
  1583                              <1>     dw  tasksel_u11           + irqt_task
  1584                              <1>     dw  tasksel_u12           + irqt_task
  1585                              <1>     dw  tasksel_u13           + irqt_task
  1586                              <1>     dw  tasksel_u14           + irqt_task
  1587                              <1>     dw  tasksel_u15           + irqt_task
  1588                              <1> %endif
  1589 00000E54 000000000000000000- <1>     dw                  0,0,0,0,0,0,0,0   ; 0xb0
  1590 00000E5D 00000000000000      <1>
  1591 00000E64 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xc0
  1592 00000E6D 000000000000000000- <1>
  1593 00000E76 000000000000000000- <1>
  1594 00000E7F 0000000000          <1>
  1595 00000E84 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xd0
  1596 00000E8D 000000000000000000- <1>
  1597 00000E96 000000000000000000- <1>
  1598 00000E9F 0000000000          <1>
  1599 00000EA4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xe0
  1600 00000EAD 000000000000000000- <1>
  1601 00000EB6 000000000000000000- <1>
  1602 00000EBF 0000000000          <1>
  1603                              <1> spurious_int equ ($ - irq_setup_table)/2
  1604 00000EC4 [040C]              <1>     dw  int_handler_spurious  + irqt_intr
  1605                              <1> apicerr_int equ ($ - irq_setup_table)/2
  1606 00000EC6 [150C]              <1>     dw  int_handler_apicerr   + irqt_app
  1607 00000EC8 000000000000000000- <1>     dw      0,0,0,0,0,0,0,0,0,0,0,0       ; 0xf0
  1608 00000ED1 000000000000000000- <1>
  1609 00000EDA 000000000000        <1>
  1610                              <1>     ; sw defined - expand down if needed
  1611                              <1> wakeup_int equ ($ - irq_setup_table)/2
  1612 00000EE0 [250C]              <1>     dw  wakeup                + irqt_app
  1613 00000EE2 [310C]              <1>     dw  sysent                + irqt_app  ; 256  0xff
  1614                              <1> irq_setup_table_size equ ($ - irq_setup_table)/2
  1615                              <1> 
  1616                                  
  1617                                  ; -------- system calls --------
  1618                                  %include "ozsys.asm"
  1619                              <1> ; OZ - A more utopian OS
  1620                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
  1621                              <1> ;
  1622                              <1> ; OZ System Calls  (for ozapps)
  1623                              <1> 
  1624                              <1> bits 32
  1625                              <1> 
  1626                              <1> ;------------------------------------------------------------------
  1627                              <1> ;   syscall_klog : place a message on the vga line reserved for klog  :D
  1628                              <1> ;
  1629                              <1> ;   entry:
  1630                              <1> ;       esi = message address
  1631                              <1> ;   exit:
  1632                              <1> 
  1633                              <1> syscall_klog :
  1634 00000EE4 60                  <1>     pusha
  1635 00000EE5 BB40010000          <1>     mov  ebx,2 * 160        ; line 3
  1636 00000EEA E80FF5FFFF          <1>     call puts_vga
  1637 00000EEF 61                  <1>     popa
  1638 00000EF0 31C0                <1>     xor  eax,eax
  1639 00000EF2 CF                  <1>     iret
  1640                              <1> 
  1641                              <1> ;------------------------------------------------------------------
  1642                              <1> ;   syscall_ncpus : get how many cpu threads are running
  1643                              <1> ;
  1644                              <1> ;   entry:
  1645                              <1> ;   exit:
  1646                              <1> ;       eax = N cpus
  1647                              <1> 
  1648                              <1> syscall_ncpus :
  1649 00000EF3 A1[14030000]        <1>     mov  eax,[ncpus]
  1650 00000EF8 CF                  <1>     iret
  1651                              <1> 
  1652                              <1> ;------------------------------------------------------------------
  1653                              <1> ;   syscall_new_thread : ask for another cpu to execute code in
  1654                              <1> ;                        the current app
  1655                              <1> ;
  1656                              <1> ;   This implementation is quite a bit of a hack - apps can basically
  1657                              <1> ;   commendere any specific non-boot cpu they want ...
  1658                              <1> ;
  1659                              <1> ;   entry:
  1660                              <1> ;       edx = function start address in the app
  1661                              <1> ;       ecx = address of the top of the app's new thread stack
  1662                              <1> ;       ebx = app's new thread index
  1663                              <1> ;   exit:
  1664                              <1> ;       eax = 0 success, -1 failure
  1665                              <1> 
  1666                              <1> syscall_new_thread :
  1667 00000EF9 09DB                <1>     or   ebx,ebx
  1668 00000EFB 7459                <1>     jz   new_thread_fail        ; don't get to ask for cpu 0
  1669                              <1> 
  1670 00000EFD 31C0                <1>     xor  eax,eax
  1671 00000EFF A0[18030000]        <1>     mov  al,[enabled_lapic]     ; if the lapics are not enabled,
  1672 00000F04 08C0                <1>     or   al,al                  ; none of this is useful
  1673 00000F06 744E                <1>     jz   new_thread_fail
  1674                              <1> 
  1675                              <1>     ; setup the tss
  1676                              <1>     ; slightly squirly - get the tss address from the task selector
  1677                              <1>     ; but there could be a race here: ncpus is updated before
  1678                              <1>     ; create_tss_pair is called, so the task selector could be zero!
  1679                              <1> 
  1680 00000F08 89DF                <1>     mov  edi,ebx
  1681 00000F0A C1E704              <1>     shl  edi,4                  ; 8 byte selectors in pairs
  1682 00000F0D 83C758              <1>     add  edi,tasksel_u00
  1683 00000F10 8BB7[02000000]      <1>     mov  esi,[gdt+edi+2]
  1684 00000F16 81E6FFFFFF00        <1>     and  esi,0xffffff
  1685 00000F1C 31C0                <1>     xor  eax,eax
  1686 00000F1E 8A87[07000000]      <1>     mov  al,[gdt+edi+7]
  1687 00000F24 C1E018              <1>     shl  eax,24
  1688 00000F27 09C6                <1>     or   esi,eax
  1689 00000F29 742B                <1>     jz   new_thread_fail        ; cpu isn't yet ready ...
  1690                              <1> 
  1691                              <1>     ; really should check the previous task link to see if this
  1692                              <1>     ; cpu is busy ...
  1693                              <1> 
  1694 00000F2B 894E38              <1>     mov  [esi+(tss0_esp-tss0)],ecx  ; set the app's stack
  1695 00000F2E 895620              <1>     mov  [esi+(tss0_eip-tss0)],edx  ; set the ip to the entry point
  1696                              <1> 
  1697                              <1>     ; lookup the requested cpu's int/taskgate gdt selector
  1698                              <1> 
  1699 00000F31 89DF                <1>     mov  edi,ebx
  1700 00000F33 81C7B0000000        <1>     add  edi,first_thread_tss_gate  ; convert ebx to int/taskgate number
  1701                              <1> 
  1702                              <1>     ; ipi a cpu.  no fancy affinity scheduling yet,
  1703                              <1>     ; just let the app ask for a specific cpu to do the work
  1704                              <1> 
  1705 00000F39 B800000001          <1>     mov  eax,0x01000000
  1706 00000F3E 89D9                <1>     mov  ecx,ebx                    ; recover requested cpu number
  1707 00000F40 D3E0                <1>     shl  eax,cl                     ; form the icr destination field
  1708                              <1> 
  1709                              <1>     ; poke the cpu that matches our thread index - we only get 8 :/
  1710                              <1> 
  1711 00000F42 A31003E0FE          <1>     mov  dword [0xfee00310],eax
  1712 00000F47 B800480000          <1>     mov  eax,0x4800                 ; no shorthand, fixed, logical, edge
  1713 00000F4C 09F8                <1>     or   eax,edi                    ; make int/taskgate number the vector
  1714 00000F4E A30003E0FE          <1>     mov  dword [0xfee00300],eax
  1715                              <1> 
  1716 00000F53 31C0                <1>     xor  eax,eax
  1717 00000F55 CF                  <1>     iret
  1718                              <1> 
  1719                              <1> new_thread_fail :
  1720 00000F56 48                  <1>     dec  eax                    ; -1
  1721 00000F57 C3                  <1>     ret
  1722                              <1> 
  1723                              <1> ;------------------------------------------------------------------
  1724                              <1> ;   syscall_sleep : wait for N timer interrupts
  1725                              <1> ;
  1726                              <1> ;   entry:
  1727                              <1> ;       edx = N ticks
  1728                              <1> ;   exit:
  1729                              <1> 
  1730                              <1> syscall_sleep :
  1731 00000F58 A0[18030000]        <1>     mov  al,[enabled_lapic]
  1732 00000F5D 08C0                <1>     or   al,al
  1733 00000F5F 7415                <1>     jz   sleep_loop
  1734                              <1> 
  1735 00000F61 A12000E0FE          <1>     mov  eax,[0xfee00020]
  1736 00000F66 C1E818              <1>     shr  eax,24
  1737 00000F69 09C0                <1>     or   eax,eax
  1738 00000F6B 7409                <1>     jz   sleep_loop         ; the boot cpu services the timer int
  1739 00000F6D 88C1                <1>     mov  cl,al              ; so don't add it to the sleeper list
  1740 00000F6F B801000000          <1>     mov  eax,1
  1741 00000F74 D3E0                <1>     shl  eax,cl
  1742                              <1> 
  1743                              <1> sleep_loop :
  1744 00000F76 F00905[1D030000]    <1>     lock or [sleepers],eax  ; announce we are sleeping
  1745 00000F7D FB                  <1>     sti
  1746 00000F7E F4                  <1>     hlt                     ; wait for an int to wake us up
  1747 00000F7F 4A                  <1>     dec  edx                ; decrement the tick count
  1748 00000F80 75F4                <1>     jnz  sleep_loop
  1749                              <1> 
  1750 00000F82 83F0FF              <1>     xor  eax,-1
  1751 00000F85 F02105[1D030000]    <1>     lock and [sleepers],eax ; renounce sleepiness
  1752 00000F8C CF                  <1>     iret
  1753                              <1> 
  1754                              <1> ;------------------------------------------------------------------
  1755                              <1> ;   syscall_request_pmem_access : ask for access to a physical
  1756                              <1> ;            memory address
  1757                              <1> ;
  1758                              <1> ;   entry:
  1759                              <1> ;       edx = phys memory address
  1760                              <1> ;
  1761                              <1> ;   exit:
  1762                              <1> ;       (need to return a logical address in eax)  For now just
  1763                              <1> ;       direct maps the physical address into logical addr space.
  1764                              <1> 
  1765                              <1> syscall_request_pmem_access :
  1766 00000F8D E801000000          <1>     call map_pmem
  1767 00000F92 CF                  <1>     iret
  1768                              <1> 
  1769                              <1> ;------------------------------------------------------------------
  1770                              <1> ;   map_pmem - add entries to the current page directory/table
  1771                              <1> ;              to direct map the requested physical memory address
  1772                              <1> ;
  1773                              <1> ;   entry:
  1774                              <1> ;       edx = phys memory address
  1775                              <1> ;
  1776                              <1> ;   returns:
  1777                              <1> ;       (need to return a logical address in eax)  For now just
  1778                              <1> ;       direct maps the physical address into logical addr space.
  1779                              <1> ;       eax =  0 success
  1780                              <1> ;       eax = -1 fail
  1781                              <1> 
  1782                              <1> map_pmem :
  1783 00000F93 60                  <1>     pusha
  1784 00000F94 52                  <1>     push edx
  1785 00000F95 0F20DB              <1>     mov  ebx,cr3
  1786 00000F98 81E300F0FFFF        <1>     and  ebx,0xfffff000
  1787 00000F9E 89D7                <1>     mov  edi,edx
  1788 00000FA0 81E70000C0FF        <1>     and  edi,0xffc00000
  1789 00000FA6 C1EF14              <1>     shr  edi,(22 - 2)           ; calc page directory index
  1790 00000FA9 81E200F03F00        <1>     and  edx,0x003ff000
  1791 00000FAF C1EA0A              <1>     shr  edx,(12 - 2)           ; calc page table index
  1792                              <1> 
  1793 00000FB2 8B043B              <1>     mov  eax,[ebx+edi]
  1794 00000FB5 09C0                <1>     or   eax,eax                ; is there a page table here?
  1795 00000FB7 750F                <1>     jnz  map_pmem_have_pgtbl
  1796 00000FB9 E892F4FFFF          <1>     call mem_alloc_kernel_page
  1797 00000FBE 09C0                <1>     or   eax,eax
  1798 00000FC0 741E                <1>     jz   map_pmem_fail
  1799 00000FC2 C1E00C              <1>     shl  eax,12                 ; convert pgno to pgtbl entry
  1800 00000FC5 89043B              <1>     mov  [ebx+edi],eax          ; update page table
  1801                              <1> 
  1802                              <1> map_pmem_have_pgtbl :
  1803                              <1>     ; for now, no security check, just direct map the address
  1804                              <1>     ; and mark the pages and the page table r/w by all
  1805 00000FC8 830C3B07            <1>     or   dword [ebx+edi],7      ; user, r/w, present
  1806                              <1> 
  1807 00000FCC 8B1C3B              <1>     mov  ebx,[ebx+edi]
  1808 00000FCF 81E300F0FFFF        <1>     and  ebx,0xfffff000
  1809 00000FD5 58                  <1>     pop  eax                    ; recover requested phys mem addr
  1810                              <1>     ; FIXME yup, big security hole if called by ring 0! And it is ...
  1811 00000FD6 83C807              <1>     or   eax,7                  ; user, r/w, present
  1812 00000FD9 890413              <1>     mov  [ebx+edx],eax          ; update page directory
  1813 00000FDC 61                  <1>     popa
  1814 00000FDD 31C0                <1>     xor  eax,eax                ; 0
  1815 00000FDF C3                  <1>     ret
  1816                              <1> 
  1817                              <1> map_pmem_fail :
  1818 00000FE0 48                  <1>     dec  eax                    ; -1
  1819 00000FE1 C3                  <1>     ret
  1820                              <1> 
  1821                                  
  1822 00000FE2 00<rept>                align 16, db 0
  1823                                  kernel_text_size equ ($-textstart)
  1824                                  
  1825                                  ; ---------------------------------------------------------------------------
  1826                                  section .data
  1827                                  datastart :
  1828                                  
  1829                                  ; -------- descriptors --------------
  1830                                  ; Intel SW dev manual 3a, 3.4.5, pg 103
  1831                                  ;
  1832                                  ; In my opinion, macros for descriptor entries
  1833                                  ; don't make the code that much more readable.
  1834                                  
  1835                                  gdt :
  1836                                  nullsel equ $-gdt           ; nullsel = 0h
  1837 00000000 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
  1838                                  
  1839                                  codesel equ $-gdt           ; codesel = 8h  4Gb flat over all logical mem
  1840 00000008 FFFF                        dw 0xffff               ; limit 0-15
  1841 0000000A 0000                        dw 0x0000               ; base  0-15
  1842 0000000C 00                          db 0x00                 ; base 16-23
  1843 0000000D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  1844 0000000E CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  1845 0000000F 00                          db 0x00                 ; base 24-31
  1846                                  
  1847                                  datasel equ $-gdt           ; datasel = 10h  4Gb flat over all logical mem
  1848 00000010 FFFF                        dw 0xffff               ; limit 0-15
  1849 00000012 0000                        dw 0x0000               ; base  0-15
  1850 00000014 00                          db 0x00                 ; base 16-23
  1851 00000015 92                          db 0x92                 ; present, dpl=0, data r/w
  1852 00000016 CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  1853 00000017 00                          db 0x00                 ; base 24-31
  1854                                  
  1855                                  stacksel equ $-gdt          ; stacksel = 18h  small limited stack
  1856 00000018 FF1F                        dw kstack_size-1        ; limit
  1857 0000001A 0010                        dw kstack_loc           ; base
  1858 0000001C 00                          db 0
  1859 0000001D 92                          db 0x92                 ; present, dpl=0, data, r/w
  1860 0000001E 40                          db 0x40                 ; byte granular, 32bit/8bit
  1861 0000001F 00                          db 0
  1862                                  
  1863                                  videosel equ $-gdt          ; videosel = 20h
  1864 00000020 9F0F                        dw 3999                 ; limit 80*25*2-1
  1865 00000022 0080                        dw 0x8000               ; base 0xb8000
  1866 00000024 0B                          db 0x0b
  1867 00000025 92                          db 0x92                 ; present, dpl=0, data, r/w
  1868 00000026 40                          db 0x40                 ; byte granular, 32bit/8bit
  1869 00000027 00                          db 0
  1870                                  
  1871                                  rmcssel equ $-gdt           ; real mode CS selector = 28h
  1872 00000028 FFFF                        dw 0x0ffff              ; limit 0-15
  1873 0000002A 0000                        dw 0x0000               ; base  0-15
  1874 0000002C 00                          db 0x00                 ; base 16-23
  1875 0000002D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  1876 0000002E 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  1877 0000002F 00                          db 0x00                 ; base 24-31
  1878                                  
  1879                                  rmdssel equ $-gdt           ; real mode DS selector = 30h
  1880 00000030 FFFF                        dw 0x0ffff              ; limit 0-15
  1881 00000032 0000                        dw 0x0000               ; base  0-15
  1882 00000034 00                          db 0x00                 ; base 16-23
  1883 00000035 92                          db 0x92                 ; present, dpl=0, data r/w
  1884 00000036 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  1885 00000037 00                          db 0x00                 ; base 24-31
  1886                                  
  1887                                  ldtsel1 equ $-gdt
  1888 00000038 1800                        dw ldt1_len             ; length of the ldt
  1889 0000003A [5001]                      dw ldt1                 ; address of the ldt
  1890 0000003C 00                          db 0
  1891 0000003D 82                          db 0x82                 ; present, dpl=0, ldt
  1892 0000003E 40                          db 0x40                 ; byte granular, 32bit/8bit
  1893 0000003F 00                          db 0
  1894                                  
  1895                                  tasksel_f08 equ $-gdt       ; the double fault task selector
  1896 00000040 6800                        dw tss_len              ; tss length
  1897 00000042 [6801]                      dw tss_f08              ; tss physical address
  1898 00000044 00                          db 0
  1899 00000045 89                          db 0x89                 ; present, dpl=0, tss32
  1900 00000046 40                          db 0x40                 ; byte granular, 32bit/8bit
  1901 00000047 00                          db 0
  1902                                  
  1903                                  tasksel_f10 equ $-gdt       ; the invalid tss task selector
  1904 00000048 6800                        dw tss_len              ; tss length
  1905 0000004A [D001]                      dw tss_f10              ; tss physical address
  1906 0000004C 00                          db 0
  1907 0000004D 89                          db 0x89                 ; present, dpl=0, tss32
  1908 0000004E 40                          db 0x40                 ; byte granular, 32bit/8bit
  1909 0000004F 00                          db 0
  1910                                  
  1911                                  ; there is one kernel thread tss (ring 0) and one user thread tss (ring 1)
  1912                                  ; per cpu.  memory for tss structs for the non-boot cpus are allocated as
  1913                                  ; each non-boot cpu comes online (see create_tss_pair).  tasksel_uXX tss
  1914                                  ; gates are installed in the idt (starting at first_thread_tss_gate),
  1915                                  ; they also map 1-to-1 with cpus.  (the thread is launched via an lapic
  1916                                  ; vectored interrupt that jumps immediately into user space - and to call a
  1917                                  ; task gate from an interrupt requires an existing ring 0 tss to be active)
  1918                                  ; tasksel_uXX tsses are initialized in new_thread.
  1919                                  
  1920                                  tasksel_k00 equ $-gdt
  1921 00000050 6800[3802]00894000                              dw tss_len, tss0, 0x8900, 0x40
  1922                                  tasksel_u00 equ $-gdt
  1923 00000058 6800[A002]00894000                              dw tss_len, tss1, 0x8900, 0x40
  1924                                  tasksel_k01 equ $-gdt
  1925 00000060 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1926                                  tasksel_u01 equ $-gdt
  1927 00000068 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1928                                  tasksel_k02 equ $-gdt
  1929 00000070 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1930                                  tasksel_u02 equ $-gdt
  1931 00000078 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1932                                  tasksel_k03 equ $-gdt
  1933 00000080 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1934                                  tasksel_u03 equ $-gdt
  1935 00000088 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1936                                  tasksel_k04 equ $-gdt
  1937 00000090 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1938                                  tasksel_u04 equ $-gdt
  1939 00000098 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1940                                  tasksel_k05 equ $-gdt
  1941 000000A0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1942                                  tasksel_u05 equ $-gdt
  1943 000000A8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1944                                  tasksel_k06 equ $-gdt
  1945 000000B0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1946                                  tasksel_u06 equ $-gdt
  1947 000000B8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1948                                  tasksel_k07 equ $-gdt
  1949 000000C0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1950                                  tasksel_u07 equ $-gdt
  1951 000000C8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1952                                  ;%ifdef FOO
  1953                                  tasksel_k08 equ $-gdt
  1954 000000D0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1955                                  tasksel_u08 equ $-gdt
  1956 000000D8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1957                                  tasksel_k09 equ $-gdt
  1958 000000E0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1959                                  tasksel_u09 equ $-gdt
  1960 000000E8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1961                                  tasksel_k10 equ $-gdt
  1962 000000F0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1963                                  tasksel_u10 equ $-gdt
  1964 000000F8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1965                                  tasksel_k11 equ $-gdt
  1966 00000100 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1967                                  tasksel_u11 equ $-gdt
  1968 00000108 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1969                                  tasksel_k12 equ $-gdt
  1970 00000110 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1971                                  tasksel_u12 equ $-gdt
  1972 00000118 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1973                                  tasksel_k13 equ $-gdt
  1974 00000120 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1975                                  tasksel_u13 equ $-gdt
  1976 00000128 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1977                                  tasksel_k14 equ $-gdt
  1978 00000130 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1979                                  tasksel_u14 equ $-gdt
  1980 00000138 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1981                                  tasksel_k15 equ $-gdt
  1982 00000140 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1983                                  tasksel_u15 equ $-gdt
  1984 00000148 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1985                                  ;%endif
  1986                                  gdt_end :
  1987                                  
  1988                                  ; ---------------------
  1989                                  
  1990                                  ldt1 :
  1991                                  nullsel1 equ $-ldt1         ; nullsel1 = 07h
  1992 00000150 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
  1993                                  
  1994                                  codesel1 equ $-ldt1         ; codesel1 = 0fh  4Gb flat over all logical mem
  1995 00000158 FFFF                        dw 0xffff               ; limit 0-15
  1996 0000015A 0000                        dw 0x0000               ; base  0-15
  1997 0000015C 00                          db 0x00                 ; base 16-23
  1998 0000015D FA                          db 0xfa                 ; present, dpl=3, code e/r
  1999 0000015E CF                          db 0xcf                 ; 4k granular, 32bit, limit 16-19
  2000 0000015F 00                          db 0x00                 ; base 24-31
  2001                                  
  2002                                  datasel1 equ $-ldt1         ; datasel1 = 17h  4Gb flat over all logical mem
  2003 00000160 FFFF                        dw 0xffff               ; limit 0-15
  2004 00000162 0000                        dw 0x0000               ; base  0-15
  2005 00000164 00                          db 0x00                 ; base 16-23
  2006 00000165 F2                          db 0xf2                 ; present, dpl=3, data r/w
  2007 00000166 CF                          db 0xcf                 ; 4k granular, 32bit, limit 16-19
  2008 00000167 00                          db 0x00                 ; base 24-31
  2009                                  
  2010                                  ; gcc wants the ds, es, and ss segment registers to match
  2011                                  ;stacksel1 equ $-ldt1        ; stacksel = 1ch  small limited stack
  2012                                  ;    dw 0xffff               ; limit
  2013                                  ;    dw 0x0000               ; base  0-15
  2014                                  ;    db 0x00
  2015                                  ;    db 0xf2                 ; present, dpl=3, data, r/w
  2016                                  ;    db 0                    ; byte granular, 16 bit
  2017                                  ;    db 0
  2018                                  
  2019                                  ldt1_end :
  2020                                  
  2021                                  ldt1_len equ ldt1_end-ldt1
  2022                                  
  2023                                  ; ---------------------
  2024                                  ; the tss that handles double fault exceptions
  2025                                  
  2026                                  tss_f08 :                   ; intel sw 3a 7.6  pg 287 of 756
  2027 00000168 00000000                    dw 0,0                  ; previous task link
  2028 0000016C 00000000                    dd 0                    ; esp0
  2029 00000170 00000000                    dw 0,0                  ; ss0
  2030 00000174 00000000                    dd 0                    ; esp1
  2031 00000178 00000000                    dw 0,0                  ; ss1
  2032 0000017C 00000000                    dd 0                    ; esp2
  2033 00000180 00000000                    dw 0,0                  ; ss2
  2034 00000184 00300000                    dd pgdir                ; cr3
  2035 00000188 [D40B0000]                  dd int_handler_tg_dblflt ; eip
  2036 0000018C 00000000                    dd 0                    ; eflags
  2037 00000190 00000000                    dd 0                    ; eax
  2038 00000194 00000000                    dd 0                    ; ecx
  2039 00000198 00000000                    dd 0                    ; edx
  2040 0000019C 00000000                    dd 0                    ; ebx
  2041 000001A0 00080000                    dd kstack_size/4        ; esp
  2042 000001A4 00000000                    dd 0                    ; ebp
  2043 000001A8 00000000                    dd 0                    ; esi
  2044 000001AC 00000000                    dd 0                    ; edi
  2045 000001B0 10000000                    dw datasel,0            ; es
  2046 000001B4 08000000                    dw codesel,0            ; cs
  2047 000001B8 10000000                    dw datasel,0            ; ss
  2048 000001BC 10000000                    dw datasel,0            ; ds
  2049 000001C0 00000000                    dw 0,0                  ; fs
  2050 000001C4 20000000                    dw videosel,0           ; gs
  2051 000001C8 00000000                    dw 0,0                  ; ldt
  2052 000001CC 0000                        dw 0                    ; trap
  2053 000001CE 0000                        dw 0                    ; iomap
  2054                                  
  2055                                  ; ---------------------
  2056                                  ; the tss that handles invalid tss exceptions
  2057                                  
  2058                                  tss_f10 :                   ; intel sw 3a 7.6  pg 287 of 756
  2059 000001D0 00000000                    dw 0,0                  ; previous task link
  2060 000001D4 00000000                    dd 0                    ; esp0
  2061 000001D8 00000000                    dw 0,0                  ; ss0
  2062 000001DC 00000000                    dd 0                    ; esp1
  2063 000001E0 00000000                    dw 0,0                  ; ss1
  2064 000001E4 00000000                    dd 0                    ; esp2
  2065 000001E8 00000000                    dw 0,0                  ; ss2
  2066 000001EC 00300000                    dd pgdir                ; cr3
  2067 000001F0 [E80B0000]                  dd int_handler_tg_invtss ; eip
  2068 000001F4 00000000                    dd 0                    ; eflags
  2069 000001F8 00000000                    dd 0                    ; eax
  2070 000001FC 00000000                    dd 0                    ; ecx
  2071 00000200 00000000                    dd 0                    ; edx
  2072 00000204 00000000                    dd 0                    ; ebx
  2073 00000208 00100000                    dd kstack_size/2        ; esp
  2074 0000020C 00000000                    dd 0                    ; ebp
  2075 00000210 00000000                    dd 0                    ; esi
  2076 00000214 00000000                    dd 0                    ; edi
  2077 00000218 10000000                    dw datasel,0            ; es
  2078 0000021C 08000000                    dw codesel,0            ; cs
  2079 00000220 10000000                    dw datasel,0            ; ss
  2080 00000224 10000000                    dw datasel,0            ; ds
  2081 00000228 00000000                    dw 0,0                  ; fs
  2082 0000022C 20000000                    dw videosel,0           ; gs
  2083 00000230 00000000                    dw 0,0                  ; ldt
  2084 00000234 0000                        dw 0                    ; trap
  2085 00000236 0000                        dw 0                    ; iomap
  2086                                  
  2087                                  ; ---------------------
  2088                                  ; tss0 and tss1 are cpu0's pair, these are also templates for other
  2089                                  ; cpus that come online.
  2090                                  
  2091                                  tss0 :                      ; intel swdev3a 7.6  pg 287 of 756
  2092 00000238 00000000                    dw 0,0                  ; previous task link
  2093                                  tss0_esp0 :
  2094 0000023C 00000000                    dd 0                    ; esp0
  2095                                  tss0_ss0 :
  2096 00000240 00000000                    dw 0,0                  ; ss0
  2097 00000244 00000000                    dd 0                    ; esp1
  2098 00000248 00000000                    dw 0,0                  ; ss1
  2099 0000024C 00000000                    dd 0                    ; esp2
  2100 00000250 00000000                    dw 0,0                  ; ss2
  2101                                  tss0_cr3 :
  2102 00000254 00300000                    dd pgdir                ; cr3
  2103                                  tss0_eip :
  2104 00000258 00000000                    dd 0                    ; eip
  2105 0000025C 00000000                    dd 0                    ; eflags
  2106                                  tss0_eax :
  2107 00000260 00000000                    dd 0                    ; eax
  2108 00000264 00000000                    dd 0                    ; ecx
  2109 00000268 00000000                    dd 0                    ; edx
  2110 0000026C 00000000                    dd 0                    ; ebx
  2111                                  tss0_esp :
  2112 00000270 00000000                    dd 0                    ; esp
  2113 00000274 00000000                    dd 0                    ; ebp
  2114 00000278 00000000                    dd 0                    ; esi
  2115 0000027C 00000000                    dd 0                    ; edi
  2116                                  tss0_es :
  2117 00000280 00000000                    dw 0,0                  ; es
  2118                                  tss0_cs :
  2119 00000284 00000000                    dw 0,0                  ; cs
  2120                                  tss0_ss :
  2121 00000288 00000000                    dw 0,0                  ; ss
  2122                                  tss0_ds :
  2123 0000028C 00000000                    dw 0,0                  ; ds
  2124 00000290 00000000                    dw 0,0                  ; fs
  2125 00000294 20000000                    dw videosel,0           ; gs
  2126                                  tss0_ldt :
  2127 00000298 00000000                    dw 0,0                  ; ldt
  2128 0000029C 0000                        dw 0                    ; trap
  2129 0000029E 0000                        dw 0                    ; iomap
  2130                                  tss0_end :
  2131                                  
  2132                                  tss_len equ tss0_end-tss0
  2133                                  
  2134                                  ; user tss
  2135                                  
  2136                                  tss1 :                      ; intel sw 3a 7.6  pg 287 of 756
  2137 000002A0 00000000                    dw 0,0                  ; previous task link
  2138 000002A4 E01F0000                    dd kstack_size-32       ; esp0  (int and irq support)
  2139 000002A8 10000000                    dw datasel,0            ; ss0   (-32 leaves some stack space for main)
  2140 000002AC 00000000                    dd 0                    ; esp1
  2141 000002B0 00000000                    dw 0,0                  ; ss1
  2142 000002B4 00000000                    dd 0                    ; esp2
  2143 000002B8 00000000                    dw 0,0                  ; ss2
  2144 000002BC 00300000                    dd pgdir                ; cr3
  2145                                  tss1_eip :
  2146 000002C0 00000000                    dd 0                    ; eip
  2147 000002C4 00000000                    dd 0                    ; eflags
  2148 000002C8 00000000                    dd 0                    ; eax
  2149 000002CC 00000000                    dd 0                    ; ecx
  2150 000002D0 00000000                    dd 0                    ; edx
  2151 000002D4 00000000                    dd 0                    ; ebx
  2152 000002D8 00000000                    dd 0                    ; esp
  2153 000002DC 00000000                    dd 0                    ; ebp
  2154 000002E0 00000000                    dd 0                    ; esi
  2155 000002E4 00000000                    dd 0                    ; edi
  2156 000002E8 17000000                    dw datasel1+7,0         ; es
  2157 000002EC 0F000000                    dw codesel1+7,0         ; cs
  2158 000002F0 17000000                    dw datasel1+7,0         ; ss
  2159 000002F4 17000000                    dw datasel1+7,0         ; ds
  2160 000002F8 00000000                    dw 0,0                  ; fs
  2161 000002FC 00000000                    dw 0,0                  ; gs
  2162 00000300 3B000000                    dw ldtsel1+3,0          ; ldt
  2163 00000304 0000                        dw 0                    ; trap
  2164 00000306 0000                        dw 0                    ; iomap
  2165                                  
  2166                                  ; ---------------------
  2167                                  
  2168                                  gdtr :
  2169 00000308 4F01                        dw gdt_end - gdt - 1    ; gdt length
  2170 0000030A [00000000]                  dd gdt                  ; gdt physical address
  2171                                  
  2172                                  idtr :
  2173                                      ; irq_setup_table_size == the number of gates in the idt
  2174 0000030E FF07                        dw irq_setup_table_size * 8 - 1     ; idt limit (should be 2k)
  2175 00000310 00700000                    dd idt                              ; address of the idt
  2176                                  
  2177 00000314 00000000                ncpus           dd 0        ; number of running cpus
  2178                                  
  2179 00000318 00                      enabled_lapic   db 0        ; set to 1 if an lapic is present and in use
  2180                                  
  2181 00000319 00000000                next_free_page  dd 0        ; initialized after page tables are setup
  2182                                  
  2183 0000031D 0000000000000000        sleepers        dq 0        ; one bit per cpu
  2184                                  
  2185 00000325 00<rept>                align 16, db 0
  2186                                  kernel_data_size equ ($-datastart)
  2187                                  
  2188                                  
  2189                                  ; ---------------------
  2190                                  ; Need to align to a physical page boundary here so that appended init apps
  2191                                  ; are always page aligned.  The problem is our text section starts 1k below
  2192                                  ; a page boundary, and so an 'align 4096' doesn't match up with physical
  2193                                  ; memory.
  2194                                  
  2195                                  ; Add larger tests here if the times expression turns up negative, to make
  2196                                  ; the kernel image size right, but your next problem will be that the boot
  2197                                  ; loader will likely refuse to load all these sectors in one pass.
  2198                                  
  2199                                  section .fill
  2200                                  
  2201                                  fill :
  2202                                  
  2203                                  %if total_size > 4096+1024
  2204                                      times (4096+4096+1024-total_size) db 0
  2205                                  %elif total_size > 1024
  2206 00000000 00<rept>                    times (4096+1024-total_size) db 0
  2207                                  %endif
  2208                                  
  2209                                  kend :
  2210                                  
