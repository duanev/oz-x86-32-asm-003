     1                                  ; OZ - A more utopian OS   x86-32 startup
     2                                  ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
     3                                  ;
     4                                  ; Copyright (C) 2015-2018  Duane Voth
     5                                  ;
     6                                  ;   This program is free software: you can redistribute it and/or modify
     7                                  ;   it under the terms of the GNU Affero General Public License as
     8                                  ;   published by the Free Software Foundation, either version 3 of the
     9                                  ;   License, or (at your option) any later version.
    10                                  ;
    11                                  ;   This program is distributed in the hope that it will be useful,
    12                                  ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
    13                                  ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    14                                  ;   GNU Affero General Public License for more details.
    15                                  ;
    16                                  ;   You should have received a copy of the GNU Affero General Public License
    17                                  ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
    18                                  ;
    19                                  ;
    20                                  ;
    21                                  ; usage:
    22                                  ;	$ qemu-system-i386 -boot a -fda oz_fd -monitor stdio
    23                                  ;
    24                                  ; requires: nasm-2.07  or later from: http://www.nasm.us
    25                                  ;
    26                                  ; credits:
    27                                  ;       many thanks to the folks at wiki.osdev.org who archive great info.
    28                                  ;
    29                                  ; contributors:
    30                                  ;        djv - Duane Voth
    31                                  ;
    32                                  ; history:
    33                                  ; 2007/03/03 - 0.00.01 - djv - begin with various web examples
    34                                  ;                      http://linuxgazette.net/issue82/misc/raghu/code.asm.txt
    35                                  ;                      http://www.osdever.net/tutorials/brunmar/simple_asm.txt
    36                                  ; 2007/03/04 - 0.00.02 - djv - add timer interrupt support with stray int dbg
    37                                  ; 2007/03/05 - 0.00.03 - djv - remove stray int dbg, add mbr data struc back
    38                                  ; 2007/03/11 - 0.00.04 - djv - debug USB boot problem
    39                                  ; 2007/03/28 - 0.01.00 - djv - add a real-mode stage2 loader in the mbr to
    40                                  ;                              load the sectors past the mbr on the boot
    41                                  ;                              device into the memory behind the mbr.  so even
    42                                  ;                              tho the read from the device happens in two
    43                                  ;                              parts, memory contains a linear image of the
    44                                  ;                              first few sectors of the boot device.
    45                                  ; 2009/02/01 - 0.02.00 - djv - begin to define application and dynamic library
    46                                  ;                              binary formats with headers detailing size and
    47                                  ;                              entry points.
    48                                  ; 2009/08/01 - 0.03.00 - djv - create the OZ app execution container using
    49                                  ;                              TSSes, paging, and rings 0 and 3.  begin to
    50                                  ;                              play with system calls.
    51                                  ; 2015/10/26 - 0.03.01 - djv - cleanup, add smp usermode tss structs, sleep,
    52                                  ;                              wakeup, and ipi for user thread creation.
    53                                  ; 2017/08/05 - 0.03.02 - djv - fixed smp races, restructured thread creation,
    54                                  ;                              handle 128 cores, move stacks to safer places
    55                                  
    56                                  %ifdef USB
    57                                  [map symbols oz_usb.map]
    58                                  %else
    59                                  [map symbols oz_fd.map]
    60                                  %endif
    61                                  
    62                                  ; -------- stage 1 ---------------------------------------------------------
    63                                  ; A classic x86 Master Boot Record
    64                                  
    65                                  section .text start=0x7c00  ; PC BIOS boot loader entry point
    66                                  textstart :
    67                                  
    68                                  bios_entry :
    69 00000000 FA                          cli
    70 00000001 EA[2400]0000                jmp 0:load_stage2       ; load cs, skip over mbr data struct
    71                                  
    72                                  times 6-($-$$)  db 0
    73 00000006 6F7A                    oemid db "oz"
    74                                  
    75 00000008 00<rept>                times 11-($-$$)  db 0
    76                                  
    77                                  ; compute the size of the kernel image in 512 byte sectors
    78                                  total_size equ (kernel_text_size + kernel_data_size)
    79                                  kisectors  equ (total_size + 512)/512 + (APP_SIZE + 512)/512
    80                                  ; compute the end of the kernel image (with apps attached)
    81                                  kilast equ 0x7c00 + kisectors * 512
    82                                  
    83                                  ; MS MBR  (http://support.microsoft.com/kb/140418)
    84                                  %ifdef FLOPPY
    85 0000000B 0002                        dw 512                  ; Bytes per sector
    86 0000000D 01                          db 1                    ; Sectors per cluster
    87 0000000E 4800                        dw kisectors            ; Number of reserved sectors
    88 00000010 02                          db 2                    ; Number of FATs
    89 00000011 E000                        dw 0x00e0               ; Number of dirs in root
    90 00000013 400B                        dw 0x0b40               ; Number of sectors in volume
    91 00000015 F0                          db 0xf0                 ; Media descriptor
    92 00000016 0900                        dw 9                    ; Number of sectors per FAT
    93 00000018 1200                        dw 18                   ; Number of sectors per track
    94 0000001A 0200                        dw 2                    ; Number of heads
    95 0000001C 00000000                    dd 0                    ; Number of hidden sectors
    96 00000020 00000000                    dd 0                    ; Large Sectors
    97                                  %endif
    98                                  
    99                                  %ifdef USB
   100                                      dw 0                    ; Bytes per sector
   101                                      db 0                    ; Sectors per cluster
   102                                      dw kisectors            ; Number of reserved sectors
   103                                      db 0                    ; Number of FATs
   104                                      dw 0                    ; Number of dirs in root
   105                                      dw 0                    ; Number of sectors in volume
   106                                      db 0                    ; Media descriptor
   107                                      dw 0                    ; Number of sectors per FAT
   108                                      dw 0                    ; Number of sectors per track
   109                                      dw 0                    ; Number of heads
   110                                      dd 0                    ; Number of hidden sectors
   111                                      dd 0                    ; Large Sectors
   112                                  %endif
   113                                  
   114                                  ; -------- stage 2 loader ------------
   115                                  bits 16
   116                                  alignb 2
   117                                  
   118                                  load_stage2 :
   119 00000024 B80030                      mov  ax,kstack_loc0+kstack_size0
   120 00000027 89C4                        mov  sp,ax
   121 00000029 31C0                        xor  ax,ax
   122 0000002B 8ED0                        mov  ss,ax
   123 0000002D 8EC0                        mov  es,ax
   124 0000002F 8ED8                        mov  ds,ax
   125 00000031 8EE0                        mov  fs,ax
   126 00000033 8EE8                        mov  gs,ax
   127 00000035 FC                          cld
   128                                  
   129                                      ; debug - pattern the stack so we can see what gets used
   130 00000036 66B811111111                mov  eax,0x11111111
   131 0000003C BF0010                      mov  di,kstack_loc0
   132 0000003F B90008                      mov  cx,kstack_size0/4
   133 00000042 F366AB                      rep stosd
   134                                  
   135 00000045 52                          push dx                 ; save BIOS boot drive number
   136                                  
   137 00000046 B80006                      mov  ax,0x0600          ; ah=06h : scroll window up, if al = 0 clrscr
   138 00000049 B90000                      mov  cx,0x0000          ; clear window from 0,0 
   139 0000004C BA4F17                      mov  dx,0x174f          ; to 23,79
   140 0000004F B70F                        mov  bh,0xf             ; fill with hi white
   141 00000051 CD10                        int  0x10               ; clear screen for direct writes to video memory
   142                                  
   143 00000053 BE[1001]                    mov  si,bootmsg
   144 00000056 31DB                        xor  bx,bx
   145 00000058 E8A100                      call puts_vga_rm
   146                                                              ; puts_vga_rm leaves gs pointing at video mem
   147 0000005B 65C60601000E                mov  byte [gs:1],0xE    ; turn the first two chars yellow
   148 00000061 65C60603000E                mov  byte [gs:3],0xE
   149                                  
   150                                      ;F - white              
   151                                      ;E - yellow             
   152                                      ;D - magenta            
   153                                      ;C - red                
   154                                      ;B - cyan               
   155                                      ;A - green              
   156                                      ;9 - blue               
   157                                      ;8 - dark grey          
   158                                  
   159                                      ; -------- stage2 boot loader --------
   160                                  
   161                                  ;   mov  ax,[8400h]         ; was everything loaded? (crdoms only do 3 sectors?)
   162                                  ;   cmp  ax,0               ; FIXME  hax hax hax ...
   163                                  ;   jnz  stage2_present
   164                                  
   165                                      ; omg, chs was such a disaster ... floppys give 64k dma errors ...
   166                                      ; is there any One Way to Read Them All?  So the 64k DMA issue
   167                                      ; forces us to read one sector at a time...
   168                                  
   169 00000067 5A                          pop  dx                 ; recover boot drive number
   170 00000068 30F6                        xor  dh,dh              ; extend it to 32b
   171 0000006A 52                          push dx
   172 0000006B 31FF                        xor  di,di
   173 0000006D 57                          push di
   174 0000006E 07                          pop  es
   175 0000006F B80008                      mov  ax,800h            ; get CHS parms for the boot drive
   176 00000072 CD13                        int  13h
   177 00000074 83E13F                      and  cx,3fh             ; ignore cylinder count
   178 00000077 FEC6                        inc  dh                 ; we need number of heads
   179 00000079 88F5                        mov  ch,dh
   180 0000007B 5A                          pop  dx                 ; recover boot drive again
   181 0000007C 51                          push cx                 ; save N heads & N sectors on the stack
   182                                  
   183 0000007D 30F6                        xor  dh,dh              ; starting head
   184 0000007F 52                          push dx
   185 00000080 B90100                      mov  cx,1h              ; starting cyl & sector (0 based) skip the mbr
   186 00000083 51                          push cx
   187 00000084 BB[0002]                    mov  bx,stage2          ; load address
   188 00000087 C1EB04                      shr  bx,4               ; in segment form
   189 0000008A 53                          push bx
   190 0000008B B84800                      mov  ax,kisectors       ; number of sectors to read
   191 0000008E 50                          push ax
   192 0000008F 6689E5                      mov  ebp,esp
   193                                  
   194                                          ; stack is now
   195                                          ;    boot drive number
   196                                          ;    N heads & N sectors for this drive
   197                                          ;    next head
   198                                          ;    next cyl & sector
   199                                          ;    load address (segment)
   200                                          ; bp number of sectors to read
   201                                  
   202                                  stage2_ldr :
   203                                          ;    bx = load address segment
   204                                          ;    cl = starting sector on this cyl & head
   205                                          ;    ch = cylinder number
   206                                          ;    dl = drive number
   207                                          ;    dh = head number
   208                                  
   209 00000092 53                          push bx
   210 00000093 07                          pop  es
   211 00000094 31DB                        xor  bx,bx
   212 00000096 FEC1                        inc  cl                 ; silly BIOS function uses 1 based sectors ...
   213 00000098 B80102                      mov  ax,0201h           ; one sector at a time
   214 0000009B CD13                        int  13h
   215 0000009D 7240                        jc   ioerr
   216                                  
   217 0000009F 59                          pop  cx                 ; remaining sectors
   218 000000A0 29C1                        sub  cx,ax              ; subtract what we just read
   219                                  
   220 000000A2 5B                          pop  bx
   221 000000A3 C1E005                      shl  ax,(9-4)           ; * 512  but its in segment form
   222 000000A6 01C3                        add  bx,ax              ; compute next load address
   223                                  
   224 000000A8 91                          xchg ax,cx
   225                                  
   226 000000A9 59                          pop  cx
   227 000000AA 5A                          pop  dx
   228 000000AB 53                          push bx                 ; need a reg for calc
   229 000000AC 678B5D08                    mov  bx,[ebp+8]         ; last head & sector
   230 000000B0 FEC1                        inc  cl
   231 000000B2 38D9                        cmp  cl,bl
   232 000000B4 720C                        jb   stage2_next
   233 000000B6 30C9                        xor  cl,cl              ; sector to zero
   234 000000B8 FEC6                        inc  dh                 ; next head
   235 000000BA 38FE                        cmp  dh,bh
   236 000000BC 7204                        jb   stage2_next
   237 000000BE 30F6                        xor  dh,dh              ; head to zero
   238 000000C0 FEC5                        inc  ch                 ; next cyl
   239                                  stage2_next :
   240 000000C2 5B                          pop  bx                 ; restore addr, don't disturb flags
   241 000000C3 83F800                      cmp  ax,0
   242 000000C6 7606                        jbe  stage2_done
   243 000000C8 52                          push dx
   244 000000C9 51                          push cx
   245 000000CA 53                          push bx
   246 000000CB 50                          push ax
   247 000000CC EBC4                        jmp  stage2_ldr
   248                                  
   249                                  stage2_done :
   250                                  
   251                                      ; ---- make sure second stage actually got loaded
   252                                  
   253 000000CE A1[0002]                    mov  ax,[stage2]        ; check the signature byte
   254 000000D1 0306[0202]                  add  ax,[stage2+2]
   255 000000D5 3DA17A                      cmp  ax,0x7a6f+0x32
   256 000000D8 750A                        jnz  s2err
   257                                  stage2_present :
   258 000000DA EA[0902]0000                jmp  0:start_stage2     ; use an absolute jump so stage 1
   259                                                              ; can be position independent
   260                                  
   261                                  ioerr :                     ; ah has status...
   262 000000DF BE[4001]                    mov  si,ioerrmsg
   263 000000E2 EB03                        jmp  print_err
   264                                  
   265                                  s2err :
   266 000000E4 BE[2A01]                    mov  si,s2errmsg
   267                                  print_err :
   268 000000E7 BBA000                      mov  bx,160
   269 000000EA E80F00                      call puts_vga_rm
   270 000000ED 65C60601000C                mov  byte [gs:1],0xC    ; turn the first two vga chars red
   271 000000F3 65C60603000C                mov  byte [gs:3],0xC
   272                                  
   273                                  hang :
   274 000000F9 F4                          hlt
   275 000000FA EBFD                        jmp  hang
   276                                  
   277                                  ; ----------------------------
   278                                  ;   puts_vga_rm - write a null delimited string to the VGA controller
   279                                  ;                 in real mode
   280                                  ;
   281                                  ;    enter:
   282                                  ;            esi - address of string
   283                                  ;            ebx - screen location (2 bytes per char, 160 bytes per line)
   284                                  ;    exit:
   285                                  ;            eax - destroyed
   286                                  ;             gs - set to video memory selector
   287                                  
   288                                  puts_vga_rm :
   289 000000FC B800B8                      mov  ax,0xb800      ; point gs at video memory
   290 000000FF 8EE8                        mov  gs,ax
   291                                  puts_vga_rm_loop :
   292 00000101 AC                          lodsb
   293 00000102 3C00                        cmp  al,0
   294 00000104 7409                        jz   puts_vga_rm_done
   295 00000106 658807                      mov  [gs:bx],al
   296 00000109 6683C302                    add  ebx,2
   297 0000010D EBF2                        jmp  puts_vga_rm_loop
   298                                  puts_vga_rm_done :
   299 0000010F C3                          ret
   300                                  
   301 00000110 4F5A2076302E30332E-     bootmsg     db      "OZ v0.03.02 - 2017/08/22 ",0
   301 00000119 3032202D2032303137-
   301 00000122 2F30382F32322000   
   302 0000012A 73746167652032206C-     s2errmsg    db      "stage 2 load failure ",0
   302 00000133 6F6164206661696C75-
   302 0000013C 72652000           
   303 00000140 692F6F206572726F72-     ioerrmsg    db      "i/o error loading stage 2 ",0
   303 00000149 206C6F6164696E6720-
   303 00000152 737461676520322000 
   304                                  
   305 0000015B 00<rept>                times 446-($-$$) db 0       ; fill with zeros up to partition table
   306                                  
   307                                  ; If the kernel is loaded from a disk (including usb) the MBR
   308                                  ; must include a partition table based on the device geometry.
   309                                  ; This gets fed into oz.asm here via usbptbl.inc
   310                                  %ifdef USB
   311                                  %include "usbptbl.inc"
   312                                  %else
   313                                      ; If the kernel is placed in memory by some other means
   314                                      ; (PXE, pxelinux, etc.) the partition table is irrelevant
   315                                      ; but the space is still required.  Make the default ptbl
   316                                      ; match a 1.44MB floppy.
   317 000001BE 800101000601124F            db 0x80,0x01,0x01,0x00,0x06,0x01,0x12,0x4f
   318 000001C6 120000002E0B0000            db 0x12,0x00,0x00,0x00,0x2e,0x0b,0x00,0x00
   319 000001CE 000000000000000000-         db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   319 000001D7 00000000000000     
   320 000001DE 000000000000000000-         db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   320 000001E7 00000000000000     
   321 000001EE 000000000000000000-         db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   321 000001F7 00000000000000     
   322                                  %endif
   323                                  
   324                                  %ifdef NEWUSB
   325                                  new usb?  gpt correct?
   326                                  0000 01B0: 00 00 00 00 00 2C 44 63  E0 36 03 00 00 00 80 20  .....,Dc .6.....
   327                                  0000 01C0: 21 00 83 9D 11 4C 00 08  00 00 00 C0 12 00 00 9D  !....L.. ........
   328                                  0000 01D0: 12 4C 83 57 25 F2 00 C8  12 00 00 A0 28 00 00 00  .L.W%... ....(...
   329                                  0000 01E0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ........ ........
   330                                  0000 01F0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 AA  ........ ......U.
   331                                  %endif
   332                                  
   333                                  
   334                                  times 510-($-$$) db 0       ; fill with zeros up to MBR signature
   335                                  
   336 000001FE 55AA                                dw 0x0aa55      ; write aa55 in bytes 511,512 to indicate
   337                                                              ; that it is a boot sector. 
   338                                  
   339                                  ; end of MBR
   340                                  ;
   341                                  ; -------- stage 2 ---------------------------------------------------------
   342                                  ;
   343                                  ; If a boot loader only loads 512 bytes in the first pass, the following
   344                                  ; code won't appear in memory until the code above has completed.  Other
   345                                  ; loaders however can load the entire OZ kernel image into memory in one
   346                                  ; shot. (pxe)
   347                                  
   348                                  bits 16
   349                                  
   350                                  stage2 :
   351 00000200 6F7A3200                    db "oz2",0                      ; stage2 signature
   352                                  
   353                                  non_boot_cpu_ljmp_instruction :     ; place this in 16 bit code land
   354 00000204 EA00000000                  jmp word 0:0                    ; so we get the right opcode
   355                                  
   356                                  ; adjust this if you want to change the supported number of cpus
   357                                  max_ncpus      equ 128
   358                                  
   359                                  ; adjust this to change the size of the initial boot stacks for each cpu
   360                                  kstack_size_percpu_l2 equ 8     ; log2 stack size for each cpu (256B)
   361                                  
   362                                  ; boot stacks for all the cpus follow the kernel image
   363                                  kistacks equ ((kilast+0x1000) & 0xfffff000)    ; align to 4k
   364                                  ; pages for memory allocation follow the boot stacks
   365                                  first_free_page equ ((kistacks + max_ncpus * (1 << kstack_size_percpu_l2)) >> 12)
   366                                  
   367                                  kstack_size equ ((first_free_page << 12) - kistacks)
   368                                  kstack_loc  equ (kistacks)
   369                                  
   370                                  ; adjust these if you want to move other things around
   371                                  kstack_loc0 equ 0x1000      ; base for boot loader stack
   372                                  kstack_size0 equ (1 << 13)
   373                                  tss_f08_stk equ 0x6000      ; stack for double fault (grows down from ...)
   374                                  tss_f10_stk equ 0x7000      ; stack for tss fault (grows down from ...)
   375                                  sipi_vector equ 0x7000      ; where the non-boot cpus will start
   376                                  
   377                                  ; ---------------------
   378                                  
   379                                  start_stage2 :
   380                                  
   381                                      ; ---- initialize the 8259's while in real mode
   382                                  
   383 00000209 E87C06                      call irq_init_hardware
   384                                  
   385                                  ; ------------ main kernel entry point ------------
   386                                  ; all cpus enter here
   387                                  main :
   388 0000020C FA                          cli                     ; appears to stabilize recent machines a bit
   389                                  
   390                                      ; ---- enable processor features?
   391                                  
   392 0000020D 66B801000000                mov  eax,1
   393 00000213 0FA2                        cpuid
   394 00000215 6683E220                    and  edx,20h            ; is rdmsr supported
   395 00000219 7400                        jz   no_msr
   396                                      ; arch/x86/include/uapi/asm/msr-index.h
   397                                  
   398                                  %ifdef SETMSR
   399                                      ; don't need this, mwait is on by default
   400                                      mov  ecx,1a0h           ; ia32_misc
   401                                      rdmsr
   402                                      or   eax,(1<<18)
   403                                      wrmsr                   ; attemt to enable monitor/mwait
   404                                  %endif
   405                                  
   406                                  no_msr :
   407                                  
   408                                      ; -------- enter protected mode --------
   409                                  
   410 0000021B 0F0116[F809]                lgdt [gdtr]             ; initialize the gdt
   411 00000220 0F20C0                      mov  eax,cr0
   412 00000223 0C21                        or   al,0x21            ; set the protected mode bit (lsb of cr0)
   413 00000225 0F22C0                      mov  cr0,eax            ;   and enable the native FPU exceptions ...
   414 00000228 EA[2D02]0800                jmp  codesel:flush_ip1  ; flush the cpu instruction pipeline
   415                                  flush_ip1:
   416                                  bits 32                     ; instructions after this point are 32bit
   417                                  
   418 0000022D 66B81000                    mov  ax,datasel
   419 00000231 8ED8                        mov  ds,ax              ; initialize the data segments
   420 00000233 8EC0                        mov  es,ax
   421                                  
   422 00000235 B801000000                  mov  eax,1
   423 0000023A F00FC105[040A0000]          lock xadd [ncpus],eax   ; create our unique cpu number
   424                                                              ; could use the lapic id if available
   425 00000242 89C6                        mov  esi,eax
   426 00000244 66B81800                    mov  ax,stacksel        ; setup a restricted stack segment
   427 00000248 8ED0                        mov  ss,ax
   428 0000024A BC00800000                  mov  esp,kstack_size    ; start at the top of the reserved stack space
   429 0000024F 89F0                        mov  eax,esi
   430 00000251 C1E008                      shl  eax,kstack_size_percpu_l2
   431 00000254 29C4                        sub  esp,eax
   432                                  
   433                                      ; ---- add a marker on the vga
   434                                  
   435 00000256 89F0                        mov  eax,esi
   436 00000258 50                          push eax                ; save cpu index
   437 00000259 89C3                        mov  ebx,eax
   438 0000025B B8A0000000                  mov  eax,160            ; vga line length
   439 00000260 C1EB05                      shr  ebx,5              ; 32 cpus per vga line
   440 00000263 43                          inc  ebx
   441 00000264 F6E3                        mul  bl
   442 00000266 89C7                        mov  edi,eax
   443 00000268 83EF02                      sub  edi,2              ; last chracter on first line of vga
   444 0000026B 58                          pop  eax
   445 0000026C 50                          push eax
   446 0000026D 89C3                        mov  ebx,eax
   447 0000026F 80C330                      add  bl,'0'             ; boot cpu announces via ascii 0
   448 00000272 D1E0                        shl  eax,1
   449 00000274 83E03F                      and  eax,3fh
   450 00000277 29C7                        sub  edi,eax
   451 00000279 66B82000                    mov  ax,videosel        ; point gs at video memory
   452 0000027D 8EE8                        mov  gs,ax
   453 0000027F 65881F                      mov  [gs:edi],bl        ; announce cpu presence
   454 00000282 58                          pop  eax
   455                                  
   456 00000283 09C0                        or   eax,eax            ; are we the boot cpu?
   457 00000285 0F8F00020000                jg   non_boot_init      ; if not, do non_boot_init
   458                                  
   459                                      ; ---- establish a "pool" of free pyhsical memory
   460                                  
   461 0000028B B819000000                  mov  eax,first_free_page
   462 00000290 A3[080A0000]                mov  [next_free_page],eax
   463                                  
   464                                      ; ---- setup the paging tables
   465                                  
   466 00000295 E8C4020000                  call mem_alloc_kernel_page  ; get a page for pgdir
   467 0000029A C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   468 0000029D 89C7                        mov  edi,eax
   469 0000029F A3[1C0A0000]                mov  [pgdirp],eax
   470 000002A4 A3[74080000]                mov  [tss_f08_cr3],eax
   471 000002A9 A3[DC080000]                mov  [tss_f10_cr3],eax
   472 000002AE A3[44090000]                mov  [tss0_cr3],eax
   473 000002B3 A3[AC090000]                mov  [tss1_cr3],eax
   474 000002B8 E8A1020000                  call mem_alloc_kernel_page  ; get a page for pgtb0
   475 000002BD C1E00C                      shl  eax,12
   476 000002C0 89C2                        mov  edx,eax
   477 000002C2 A3[200A0000]                mov  [pgtb0p],eax
   478 000002C7 E892020000                  call mem_alloc_kernel_page  ; get a page for pgtb1
   479 000002CC C1E00C                      shl  eax,12
   480 000002CF 89C1                        mov  ecx,eax
   481 000002D1 A3[240A0000]                mov  [pgtb1p],eax
   482                                  
   483                                              ; first the page directory
   484                                  
   485 000002D6 0F22DF                      mov  cr3,edi            ; install the page directory
   486 000002D9 89D0                        mov  eax,edx
   487 000002DB 83C007                      add  eax,7              ; page table 0: present, pl=3, r/w
   488 000002DE AB                          stosd                   ; ... pl=3 for now (simplify vga access)
   489 000002DF 89C8                        mov  eax,ecx
   490 000002E1 83C007                      add  eax,7              ; page table 1: present, pl=3, r/w
   491 000002E4 AB                          stosd                   ; ... app memory
   492 000002E5 31C0                        xor  eax,eax            ; invalidate the rest of the app laddr space
   493 000002E7 B9FE030000                  mov  ecx,0x400-2        ; (yeah, only one pgdir for kernel+apps for now)
   494 000002EC F3AB                        rep stosd
   495                                  
   496                                              ; pgtb0 is the page table for kernel memory
   497                                  
   498 000002EE 89D7                        mov  edi,edx
   499 000002F0 AB                          stosd                   ; access to page 0 will always cause a fault
   500 000002F1 B803100000                  mov  eax,0x1000 + 3     ; rest are direct map: present, pl=0, r/w
   501 000002F6 B9FF030000                  mov  ecx,0x400-1
   502                                  pgtb0_fill :
   503 000002FB AB                          stosd                   ; kernel gets to touch anything it wants < 4MB
   504 000002FC 0500100000                  add  eax,0x1000
   505 00000301 E2F8                        loop pgtb0_fill
   506                                  
   507                                              ; pgtb1 is the first page table for app code/data/stack it is
   508                                              ; already all zeros (invalid - we'll fill in what we need later)
   509                                  
   510                                              ; enable paging - if we've done it all right, we won't crash
   511                                  
   512 00000303 0F20C0                      mov  eax,cr0
   513 00000306 0D00000080                  or   eax,0x80000000     ; msb of cr0
   514 0000030B 0F22C0                      mov  cr0,eax
   515 0000030E EB00                        jmp  flush_ip2          ; flush the cpu instruction pipeline
   516                                  flush_ip2:
   517                                  
   518                                      ; ---- build the interrupt descriptor table
   519                                  
   520 00000310 E849020000                  call mem_alloc_kernel_page  ; get a page for the idt
   521 00000315 C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   522 00000318 89C2                        mov  edx,eax
   523 0000031A A3[000A0000]                mov  [idtr_addr],eax
   524                                  
   525 0000031F BE[AC0E0000]                mov  esi,irq_setup_table
   526 00000324 B900010000                  mov  ecx,irq_setup_table_size
   527                                  irq_init :
   528 00000329 31C0                        xor  eax,eax
   529 0000032B 8902                        mov  [edx],eax                  ; clear the idt entry
   530 0000032D 894202                      mov  [edx+2],eax
   531 00000330 66AD                        lodsw
   532 00000332 6689C3                      mov  bx,ax
   533 00000335 6625FCFF                    and  ax,strict 0xfffc           ; separate config flags
   534 00000339 6683E303                    and  bx,3                       ; from selector/offset value
   535 0000033D 6683FB02                    cmp  bx,irqt_task               ; task gates are different
   536 00000341 7407                        jz   irq_init_task_gate
   537 00000343 668902                      mov  [edx],ax                   ; store the handler offset
   538 00000346 66B80800                    mov  ax,codesel
   539                                  irq_init_task_gate :
   540 0000034A 66894202                    mov  word [edx+2],ax
   541 0000034E 678AA7[A80E]                mov  ah,byte [bx+irq_types]
   542 00000353 30C0                        xor  al,al
   543 00000355 66894204                    mov  word [edx+4],ax
   544 00000359 83C208                      add  edx,8
   545 0000035C E2CB                        loop irq_init
   546                                  
   547 0000035E 0F011D[FE090000]            lidt [idtr]                     ; install the idt
   548                                  
   549                                      ; ---- let's see what kind of interrupt hardware we've got
   550                                  
   551 00000365 C605[280A0000]00            mov  byte [enabled_lapic],0x0
   552 0000036C B801000000                  mov  eax,1
   553 00000371 0FA2                        cpuid
   554 00000373 09C0                        or   eax,eax
   555 00000375 720F                        jb   no_lapic
   556 00000377 81E200020000                and  edx,1 << 9         ; lapic feature
   557 0000037D 7407                        jz   no_lapic
   558 0000037F C605[280A0000]01            mov  byte [enabled_lapic],0x1
   559                                  no_lapic :
   560                                  
   561                                              ; if enabled, create page table entry for the lapic
   562                                  
   563 00000386 A0[280A0000]                mov  al,[enabled_lapic]
   564 0000038B 08C0                        or   al,al
   565 0000038D 7430                        jz   no_lapic_init
   566                                  
   567 0000038F BA0000E0FE                  mov  edx,0xfee00000     ; phys address
   568 00000394 B900100000                  mov  ecx,0x1000         ; length
   569 00000399 E8930D0000                  call map_pmem
   570                                  
   571                                      ; do the ioapic while we're at it
   572 0000039E BA0000C0FE                  mov  edx,0xfec00000     ; phys address
   573 000003A3 52                          push edx
   574 000003A4 B900100000                  mov  ecx,0x1000         ; length
   575 000003A9 E8830D0000                  call map_pmem
   576 000003AE 5A                          pop  edx
   577 000003AF C70201000000                mov  dword [edx],1
   578 000003B5 A11000C0FE                  mov  eax,[0xfec00010]
   579                                  
   580 000003BA E8F2040000                  call irq_init_bsp_apic_hardware
   581                                  
   582                                  no_lapic_init :
   583                                  
   584                                      ; ---- setup entry point for non_boot_cpus
   585                                  
   586 000003BF A0[04020000]                mov  al,[non_boot_cpu_ljmp_instruction]     ; get the ljmp instruction
   587 000003C4 A200700000                  mov  [sipi_vector],al                       ; place it at a 4k phys mem boundary
   588 000003C9 C70501700000-               mov  dword [sipi_vector+1],main
   588 000003CF [0C020000]         
   589                                  
   590                                      ; ---- establish a current task
   591                                  
   592 000003D3 31C0                        xor  eax,eax
   593 000003D5 B058                        mov  al,tasksel_k00
   594 000003D7 0F00D8                      ltr  ax
   595                                  
   596                                      ; ---- check for init apps
   597                                  
   598 000003DA BB[80070000]                mov  ebx, kend
   599                                  app_loop :
   600 000003DF 8B4318                      mov  eax, [ebx+0x18]    ; load the entry address
   601 000003E2 813B6F7A6170                cmp  dword [ebx], 0x70617a6f  ; check for "ozap"
   602 000003E8 7402                        jz   have_an_app
   603 000003EA 31C0                        xor  eax, eax           ; no app
   604                                  have_an_app :
   605                                  
   606 000003EC 83F800                      cmp  eax, 0             ; is there an app to run?
   607 000003EF 0F8413010000                jz   idle               ; if not, idle right away
   608                                  
   609                                      ; ---- setup the init task entry point
   610                                  
   611 000003F5 BF[B0090000]                mov  edi,tss1_eip
   612 000003FA AB                          stosd
   613                                  
   614                                      ; reuse the same tss, and page tables for all the
   615                                      ; init apps - this means they run serialy - each has
   616                                      ; to exit for the next one to run
   617                                  
   618 000003FB 31C0                        xor   eax,eax
   619 000003FD A3[90090000]                mov   [tss1],eax        ; clear out previous task link
   620 00000402 AB                          stosd                   ; and some registers (flags)
   621 00000403 AB                          stosd                   ; (eax)
   622 00000404 AB                          stosd                   ; (ecx)
   623 00000405 AB                          stosd                   ; (edx)
   624 00000406 AB                          stosd                   ; (ebx)
   625 00000407 8B4310                      mov   eax, [ebx+0x10]   ; get the end of the app
   626                                      ;add   eax,0x8001000     ; (this tests app stack page faults)
   627 0000040A AB                          stosd                   ; (esp)
   628 0000040B 31C0                        xor   eax,eax
   629 0000040D AB                          stosd                   ; (ebp)
   630 0000040E AB                          stosd                   ; (esi)
   631 0000040F AB                          stosd                   ; (edi)
   632                                  
   633 00000410 8B3D[240A0000]              mov  edi,[pgtb1p]       ; rewrite the app's page table
   634 00000416 89D8                        mov  eax,ebx
   635 00000418 83C805                      or   eax,5              ; init app code at 0x400000 (4Mb) present and r/o
   636 0000041B 8B4B20                      mov  ecx,[ebx+0x20]     ; get the start of the data segment
   637 0000041E 81E900004000                sub  ecx,0x400000
   638 00000424 C1E90C                      shr  ecx,12
   639                                      ; FIXME need to cap ecx here in case app image is corrupted
   640                                  init_pgtb1_ro :
   641 00000427 AB                          stosd
   642 00000428 0500100000                  add  eax,0x1000
   643 0000042D E2F8                        loop init_pgtb1_ro
   644                                  
   645 0000042F 8B4B10                      mov  ecx,[ebx+0x10]     ; get the end of the app
   646 00000432 2B4B20                      sub  ecx,[ebx+0x20]     ; subtract the start of the data segment
   647 00000435 C1E90C                      shr  ecx,12
   648                                      ; FIXME need to cap ecx here in case app image is corrupted
   649 00000438 83C002                      add  eax,2              ; the data/bss/stack pages are r/w
   650                                  init_pgtb1_rw :
   651 0000043B AB                          stosd
   652 0000043C 0500100000                  add  eax,0x1000
   653 00000441 E2F8                        loop init_pgtb1_rw
   654                                  
   655                                      ; ---- debug marker
   656 00000443 65C605010000000A            mov  byte [gs:1],0xA    ; turn the first two chars green
   657 0000044B 65C605030000000A            mov  byte [gs:3],0xA
   658                                  
   659                                      ; ---- use our current stack for system interrupts during the app
   660                                  
   661 00000453 53                          push ebx
   662 00000454 BF[94090000]                mov  edi,tss1_esp0
   663 00000459 89E0                        mov  eax,esp
   664 0000045B AB                          stosd
   665                                  
   666                                      ; ---- start the app
   667                                  
   668 0000045C FB                          sti
   669 0000045D 9A000000006000              call tasksel_u00:0
   670 00000464 5B                          pop  ebx
   671                                  
   672                                      ; ---- point to the end of this init app
   673                                  
   674 00000465 B800004000                  mov  eax,0x400000       ; FIXME 80386 needs to reload cr3
   675 0000046A 8B4B10                      mov  ecx,[ebx+0x10]     ; get the end of the app
   676 0000046D 29C1                        sub  ecx,eax
   677 0000046F C1E90C                      shr  ecx,12
   678                                      ; FIXME need to cap ecx here in case app image is corrupted
   679                                  invl_app :
   680 00000472 0F0138                      invlpg [eax]
   681 00000475 0500100000                  add  eax,0x1000
   682 0000047A E2F6                        loop invl_app
   683                                  
   684 0000047C 8B4310                      mov  eax, [ebx+0x10]    ; load the app end address
   685 0000047F 2D00004000                  sub  eax,0x400000
   686 00000484 01C3                        add  ebx,eax            ; point ebx to the next app
   687 00000486 E954FFFFFF                  jmp  app_loop
   688                                  
   689                                  ; -------- non-boot cpu initialization --------
   690                                  
   691                                  non_boot_init :
   692                                  
   693 0000048B 0F011D[FE090000]            lidt [idtr]             ; install the global idt
   694                                  
   695                                      ; ---- enable paging
   696                                  
   697 00000492 8B3D[1C0A0000]              mov  edi,[pgdirp]       ; load this cpu's paging register
   698 00000498 0F22DF                      mov  cr3,edi
   699                                  
   700 0000049B 50                          push eax
   701 0000049C 0F20C0                      mov  eax,cr0            ; enable paging
   702 0000049F 0D00000080                  or   eax,0x80000000
   703 000004A4 0F22C0                      mov  cr0,eax
   704 000004A7 EB00                        jmp  flush_ip3          ; flush the instruction pipeline
   705                                  flush_ip3 :
   706 000004A9 58                          pop  eax
   707                                  
   708                                      ; ---- limit the number of threads we support here
   709                                  
   710                                      ;cmp  eax,2
   711 000004AA 3D80000000                  cmp  eax,max_threads
   712 000004AF 7357                        jae  idle
   713                                  
   714                                      ; ---- establish a current task
   715                                  
   716 000004B1 89C3                        mov  ebx,eax            ; move cpu number to ebx
   717 000004B3 E8EA000000                  call create_tss_pair
   718 000004B8 83F800                      cmp  eax,0              ; memory alloc errs nix this core
   719 000004BB 744B                        jz   idle
   720                                  
   721 000004BD 53                          push ebx
   722 000004BE C1E304                      shl  ebx,4              ; 8 byte selectors in pairs
   723 000004C1 83C358                      add  ebx,tasksel_k00
   724 000004C4 0F00DB                      ltr  bx                 ; establish a current task
   725 000004C7 89DF                        mov  edi,ebx
   726                                  
   727                                      ; ---- init the lapic
   728                                  
   729 000004C9 E817040000                  call irq_init_ap_apic_hardware
   730 000004CE 5B                          pop  ebx
   731                                  
   732                                      ; setup smbase?
   733                                  
   734                                      ; test kernel page fault handler
   735                                      ;mov  [321],eax
   736                                  
   737 000004CF 83C708                      add  edi,8              ; point edi at tasksel_uXX
   738                                  
   739                                  nb_idle :
   740 000004D2 FB                          sti
   741                                      ; debug
   742                                      ; to test with only one core, uncomment the cli which
   743                                      ; will lock all non-boot cores at the subsquent hlt ...
   744                                      ;cli
   745                                      ; debug end
   746 000004D3 F4                          hlt                     ; wait for something to do
   747                                  
   748 000004D4 FA                          cli			; likely unnecessary
   749 000004D5 8BB7[02000000]              mov  esi,[gdt+edi+2]    ; lookup our tss base address
   750 000004DB 81E6FFFFFF00                and  esi,0xffffff
   751 000004E1 8A87[07000000]              mov  al,[gdt+edi+7]
   752 000004E7 C1E018                      shl  eax,24
   753 000004EA 09C6                        or   esi,eax
   754 000004EC 74E4                        jz   nb_idle            ; tss not initialized
   755 000004EE 837E2000                    cmp  dword [esi+(tss_eip-tss)],0  ; test eip to see if task is ready
   756 000004F2 74DE                        jz   nb_idle
   757                                  
   758 000004F4 8B461C                      mov  eax,[esi+(tss_cr3-tss)]
   759 000004F7 0F22D8                      mov  cr3,eax            ; refresh local cpu tlb (required on real hw)
   760                                  
   761 000004FA 89F8                        mov  eax,edi            ; build a far call on the stack
   762 000004FC 50                          push eax
   763 000004FD 30C0                        xor  al,al
   764 000004FF 50                          push eax
   765 00000500 FF1C24                      call far [esp]          ; the call works, but the return is untested!
   766                                                              ; (i.e. no app using more than the boot cpu has
   767                                                              ;  yet exited any thread ...)
   768 00000503 83C408                      add  esp,8
   769 00000506 EBCA                        jmp nb_idle
   770                                  
   771                                      ; -------- boot cpu (and excess cpu) idle task --------
   772                                  
   773                                  idle :
   774 00000508 FB                          sti
   775 00000509 F4                          hlt                     ; wait for interrupts
   776 0000050A EBFC                        jmp  idle
   777                                  
   778                                  ; ----------------------------
   779                                  ;    puts_vga - write a null delimited string to the VGA controller
   780                                  ;               in protected mode
   781                                  ;    enter:
   782                                  ;         esi - address of string
   783                                  ;         ebx - screen location (2 bytes per char, 160 bytes per line)
   784                                  ;    exit:
   785                                  ;         eax - destroyed
   786                                  ;         ebx - next screen location
   787                                  ;          gs - set to video memory selector
   788                                  bits 32
   789                                  
   790                                  puts_vga :
   791 0000050C 66B82000                    mov  ax,videosel        ; point gs at video memory
   792 00000510 8EE8                        mov  gs,ax
   793                                  puts_vga_loop :
   794 00000512 2E8A06                      mov  al,[cs:esi]        ; use cs so irq handlers don't
   795 00000515 46                          inc  esi                ; have to load kernel ds
   796 00000516 3C00                        cmp  al,0
   797 00000518 7408                        jz   puts_vga_done
   798 0000051A 658803                      mov  [gs:ebx],al
   799 0000051D 83C302                      add  ebx,2
   800 00000520 EBF0                        jmp  puts_vga_loop
   801                                  puts_vga_done :
   802 00000522 C3                          ret
   803                                  
   804                                  ; ----------------------------
   805                                  ;   putx_vga - write the contents of eax in hex to the VGA controller
   806                                  ;              (in protected mode)
   807                                  ;   putbx_vga - write the contents of al in hex to the VGA controller
   808                                  ;
   809                                  ;   enter:
   810                                  ;       eax - value to convert to hex
   811                                  ;       ebx - screen location (2 bytes per char, 160 bytes per line)
   812                                  ;   exit:
   813                                  ;       ebx - next screen location
   814                                  ;        gs - set to video memory selector
   815                                  bits 32
   816                                  
   817                                  putbx_vga :
   818 00000523 51                          push ecx
   819 00000524 B902000000                  mov  ecx,2
   820 00000529 25FF000000                  and  eax,0xff
   821 0000052E C1C018                      rol  eax,24
   822 00000531 EB06                        jmp putx_vga_loop
   823                                  
   824                                  putx_vga :
   825 00000533 51                          push ecx
   826 00000534 B908000000                  mov  ecx,8
   827                                  putx_vga_loop :
   828 00000539 C1C004                      rol  eax,4
   829 0000053C 50                          push eax
   830 0000053D 240F                        and  al,0xf
   831 0000053F 3C09                        cmp  al,9
   832 00000541 7704                        ja   putx_vga_hexdigit
   833 00000543 0430                        add  al,'0'
   834 00000545 EB02                        jmp short putx_vga_putc
   835                                  putx_vga_hexdigit :
   836 00000547 0457                        add  al,'a'-10
   837                                  putx_vga_putc :
   838 00000549 658803                      mov  [gs:ebx],al
   839 0000054C 83C302                      add  ebx,2
   840 0000054F 58                          pop  eax
   841 00000550 83E0F0                      and  eax,0xfffffff0
   842 00000553 E2E4                        loop putx_vga_loop
   843 00000555 65C60320                    mov  byte [gs:ebx],' '
   844 00000559 83C302                      add  ebx,2
   845 0000055C 59                          pop  ecx
   846 0000055D C3                          ret
   847                                  
   848                                  ;------------------------------------------------------------------
   849                                  ;   mem_alloc_kernel_page - return the 4k page number of 1 page of
   850                                  ;                           memory from the kernel page pool
   851                                  ;
   852                                  ;   smp safe
   853                                  ;
   854                                  ;   returns:    eax = page number (zero will mean ... no pages left)
   855                                  
   856                                  mem_alloc_kernel_page :
   857                                      ; FIXME need to expand this above 720K ...
   858 0000055E A1[080A0000]                mov  eax,[next_free_page]
   859 00000563 3DB0000000                  cmp  eax,0xb0               ; stop under the vga
   860 00000568 B800000000                  mov  eax,0
   861 0000056D 7732                        ja   mem_alloc_kernel_page_fail
   862 0000056F B801000000                  mov  eax,1
   863 00000574 F00FC105[080A0000]          lock xadd [next_free_page],eax   ; atomic, making this re-entrant
   864 0000057C 50                          push eax
   865 0000057D 51                          push ecx
   866 0000057E 57                          push edi
   867 0000057F C1E00C                      shl  eax,12
   868 00000582 B900040000                  mov  ecx,0x1000/4
   869 00000587 89C7                        mov  edi,eax
   870 00000589 31C0                        xor  eax,eax
   871 0000058B F3AB                        rep stosd                   ; zero the page
   872 0000058D 5F                          pop  edi
   873 0000058E 59                          pop  ecx
   874 0000058F 58                          pop  eax
   875                                  
   876                                      ; debug - show the last used address on the vga
   877 00000590 50                          push eax
   878 00000591 53                          push ebx
   879 00000592 BB4E000000                  mov  ebx, 39*2
   880 00000597 C1E00C                      shl  eax,12
   881 0000059A E894FFFFFF                  call putx_vga
   882 0000059F 5B                          pop  ebx
   883 000005A0 58                          pop  eax
   884                                      ; debug end
   885                                  
   886                                  mem_alloc_kernel_page_fail :
   887 000005A1 C3                          ret
   888                                  
   889                                  ;------------------------------------------------------------------
   890                                  ;   create a pair of tss structs for a new cpu
   891                                  ;
   892                                  ;   FIXME: I'm pretty sure I don't need two - a single tss should be fine.
   893                                  ;          partially a hold over from using interrupt gates to manage task
   894                                  ;          threads, a pair of tss structs provided register storage for both
   895                                  ;          a kernel thread and a user thread...
   896                                  ;
   897                                  ;   I'm using the tss eip field as a flag to indicate a valid tss.
   898                                  ;   set eip to zero to prevent use of the tss gate (code elsewhere
   899                                  ;   must test the eip field before using the gate).
   900                                  ;
   901                                  ;   enter:
   902                                  ;       ebx - cpu number
   903                                  ;   exit:
   904                                  ;       ebx - cpu number
   905                                  
   906                                  create_tss_pair :
   907 000005A2 E8B7FFFFFF                  call mem_alloc_kernel_page
   908 000005A7 09C0                        or   eax,eax
   909 000005A9 0F8489000000                jz   create_tss_pair_fail
   910 000005AF C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   911 000005B2 89C7                        mov  edi,eax                ; first tss is the kernel ring 0 thread
   912                                  
   913 000005B4 89FE                        mov  esi,edi
   914 000005B6 83C668                      add  esi,tss_len            ; second tss is the user ring 3 thread
   915                                  
   916                                      ; edi = ring 0 tss          (all the offsets will be calculated using the
   917                                      ; esi = ring 3 tss           tss0 values but they are just offsets :)
   918                                  
   919 000005B9 A1[1C0A0000]                mov  eax,[pgdirp]
   920 000005BE 89471C                      mov  [edi+(tss_cr3-tss)],eax
   921 000005C1 89461C                      mov  [esi+(tss_cr3-tss)],eax
   922                                  
   923                                      ; user tss gets ring3 selectors
   924 000005C4 B843000000                  mov  eax,datasel3+3
   925 000005C9 894648                      mov  [esi+(tss_es-tss)],eax
   926 000005CC 894650                      mov  [esi+(tss_ss-tss)],eax
   927 000005CF 894654                      mov  [esi+(tss_ds-tss)],eax
   928 000005D2 894658                      mov  [esi+(tss_fs-tss)],eax
   929 000005D5 89465C                      mov  [esi+(tss_gs-tss)],eax
   930 000005D8 B83B000000                  mov  eax,codesel3+3
   931 000005DD 89464C                      mov  [esi+(tss_cs-tss)],eax
   932                                  
   933                                      ; sloppy: datasel maps all of physical ram, but its easier
   934                                      ; than having to set up a separate gdt stacksel for each cpu.
   935                                      ; pray the apps are trustworthy ...
   936                                  
   937 000005E0 B810000000                  mov  eax,datasel
   938 000005E5 894608                      mov  [esi+(tss_ss0-tss)],eax
   939 000005E8 89F8                        mov  eax,edi
   940 000005EA 05000C0000                  add  eax,0xc00                  ; towards the end of the tss page
   941 000005EF 894604                      mov  [esi+(tss_esp0-tss)],eax
   942                                  
   943 000005F2 89F8                        mov  eax,edi
   944 000005F4 0500040000                  add  eax,0x400
   945 000005F9 894704                      mov  [edi+(tss_esp0-tss)],eax   ; in case the ring0 esp0 is ever used
   946                                  
   947                                      ; patch the tss addresses into our reserved gdt selectors
   948                                  
   949 000005FC 89DA                        mov  edx,ebx
   950 000005FE C1E204                      shl  edx,4                      ; 8 byte selectors in pairs
   951 00000601 83C258                      add  edx,tasksel_k00
   952                                  
   953 00000604 89F8                        mov  eax,edi
   954 00000606 81CF00000089                or   edi,0x89000000             ; available tss
   955 0000060C C1E818                      shr  eax,24
   956 0000060F 89BA[02000000]              mov  [gdt+edx+2],edi            ; base 0-23 and flags
   957 00000615 8882[07000000]              mov  [gdt+edx+7],al             ; base 24-32
   958                                  
   959 0000061B 83C208                      add  edx,8h                     ; move to tasksel_uxx
   960                                  
   961 0000061E 89F0                        mov  eax,esi
   962 00000620 81CE00000089                or   esi,0x89000000             ; available tss
   963 00000626 C1E818                      shr  eax,24
   964 00000629 89B2[02000000]              mov  [gdt+edx+2],esi            ; base 0-23 and flags
   965 0000062F 8882[07000000]              mov  [gdt+edx+7],al             ; base 24-32
   966                                  
   967                                  ; here is a twisty way to write an entire gdt entry at once,
   968                                  ; but apparently there is no race condition here
   969                                  ; so it is not needed.
   970                                  
   971                                      ;sub  esp,8
   972                                  
   973                                      ;mov  eax,edi
   974                                      ;or   edi,0x89000000             ; available tss
   975                                      ;mov  word [esp],(tss_len-1)
   976                                      ;mov  [esp+2],edi
   977                                      ;shr  eax,16
   978                                      ;mov  al,0x40
   979                                      ;mov  [esp+6],ax
   980                                      ;movq mm0,[esp]
   981                                      ;movntq [gdt+edx],mm0
   982                                  
   983                                      ;add  edx,8h                     ; move to tasksel_uxx
   984                                  
   985                                      ;mov  eax,esi
   986                                      ;or   esi,0x89000000             ; available tss
   987                                      ;mov  [esp+2],esi
   988                                      ;shr  eax,16
   989                                      ;mov  al,0x40
   990                                      ;mov  [esp+6],ax
   991                                      ;movq mm0,[esp]
   992                                      ;movntq [gdt+edx],mm0
   993                                  
   994                                      ;add  esp,8
   995                                  
   996 00000635 83C801                      or   eax,1
   997                                  
   998                                  create_tss_pair_fail :
   999 00000638 C3                          ret
  1000                                  
  1001                                  
  1002                                  ; -------- interrupt handlers --------
  1003                                  %include "ozirq.asm"
     1                              <1> ; OZ - A more utopian OS    x86-32 interrupts
     2                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
     3                              <1> ;
     4                              <1> ; Copyright (C) 2015  Duane Voth
     5                              <1> ;
     6                              <1> ;   This program is free software: you can redistribute it and/or modify
     7                              <1> ;   it under the terms of the GNU Affero General Public License as
     8                              <1> ;   published by the Free Software Foundation, either version 3 of the
     9                              <1> ;   License, or (at your option) any later version.
    10                              <1> ;
    11                              <1> ;   This program is distributed in the hope that it will be useful,
    12                              <1> ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
    13                              <1> ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    14                              <1> ;   GNU Affero General Public License for more details.
    15                              <1> ;
    16                              <1> ;   You should have received a copy of the GNU Affero General Public License
    17                              <1> ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
    18                              <1> ;
    19                              <1> ;
    20                              <1> ; IRQ handling
    21                              <1> ;
    22                              <1> ; resources:
    23                              <1> ;       http://forum.osdev.org/viewtopic.php?p=107868#107868
    24                              <1> 
    25 00000639 63707500            <1> cpumsg      db      "cpu",0
    26                              <1> 
    27 0000063D 646976696465206279- <1> int00msg    db      "divide by zero ",0
    27 00000646 207A65726F2000      <1>
    28 0000064D 646562756720657863- <1> int01msg    db      "debug exception ",0
    28 00000656 657074696F6E2000    <1>
    29 0000065E 6E6D692000          <1> int02msg    db      "nmi ",0
    30 00000663 627265616B706F696E- <1> int03msg    db      "breakpoint exception ",0
    30 0000066C 742065786365707469- <1>
    30 00000675 6F6E2000            <1>
    31 00000679 6F766572666C6F7720- <1> int04msg    db      "overflow exception ",0
    31 00000682 657863657074696F6E- <1>
    31 0000068B 2000                <1>
    32 0000068D 626F756E6420657863- <1> int05msg    db      "bound exceeded ",0
    32 00000696 65656465642000      <1>
    33 0000069D 696E76616C6964206F- <1> int06msg    db      "invalid opcode ",0
    33 000006A6 70636F64652000      <1>
    34 000006AD 64657669636520756E- <1> int07msg    db      "device unavailable ",0
    34 000006B6 617661696C61626C65- <1>
    34 000006BF 2000                <1>
    35 000006C1 646F75626C65206661- <1> int08msg    db      "double fault ",0
    35 000006CA 756C742000          <1>
    36 000006CF 636F70726F63657373- <1> int09msg    db      "coprocessor segment overrun ",0
    36 000006D8 6F72207365676D656E- <1>
    36 000006E1 74206F76657272756E- <1>
    36 000006EA 2000                <1>
    37 000006EC 696E76616C69642074- <1> int10msg    db      "invalid tss ",0
    37 000006F5 73732000            <1>
    38 000006F9 7365676D656E74206E- <1> int11msg    db      "segment not present ",0
    38 00000702 6F742070726573656E- <1>
    38 0000070B 742000              <1>
    39 0000070E 737461636B20666175- <1> int12msg    db      "stack fault ",0
    39 00000717 6C742000            <1>
    40 0000071B 67656E6572616C2070- <1> int13msg    db      "general protection fault ",0
    40 00000724 726F74656374696F6E- <1>
    40 0000072D 206661756C742000    <1>
    41 00000735 6B65726E656C207061- <1> int14kmsg   db      "kernel page fault addr=",0
    41 0000073E 6765206661756C7420- <1>
    41 00000747 616464723D00        <1>
    42 0000074D 617070207061676520- <1> int14umsg   db      "app page fault addr=",0
    42 00000756 6661756C7420616464- <1>
    42 0000075F 723D00              <1>
    43 00000762 666C6F6174696E6720- <1> int16msg    db      "floating point err ",0
    43 0000076B 706F696E7420657272- <1>
    43 00000774 2000                <1>
    44 00000776 616C69676E6D656E74- <1> int17msg    db      "alignment check ",0
    44 0000077F 20636865636B2000    <1>
    45 00000787 6D616368696E652063- <1> int18msg    db      "machine check ",0
    45 00000790 6865636B2000        <1>
    46 00000796 73696D6420666C6F61- <1> int19msg    db      "simd floating point err ",0
    46 0000079F 74696E6720706F696E- <1>
    46 000007A8 74206572722000      <1>
    47                              <1> 
    48 000007AF 687720696E74303220- <1> int34msg    db      "hw int02 ",0
    48 000007B8 00                  <1>
    49 000007B9 687720696E74303320- <1> int35msg    db      "hw int03 ",0
    49 000007C2 00                  <1>
    50 000007C3 687720696E74303420- <1> int36msg    db      "hw int04 ",0
    50 000007CC 00                  <1>
    51 000007CD 687720696E74303520- <1> int37msg    db      "hw int05 ",0
    51 000007D6 00                  <1>
    52 000007D7 687720696E74303620- <1> int38msg    db      "hw int06 ",0
    52 000007E0 00                  <1>
    53 000007E1 687720696E74303720- <1> int39msg    db      "hw int07 ",0
    53 000007EA 00                  <1>
    54 000007EB 687720696E74303820- <1> int40msg    db      "hw int08 ",0
    54 000007F4 00                  <1>
    55 000007F5 687720696E74303920- <1> int41msg    db      "hw int09 ",0
    55 000007FE 00                  <1>
    56 000007FF 687720696E74313020- <1> int42msg    db      "hw int10 ",0
    56 00000808 00                  <1>
    57 00000809 687720696E74313120- <1> int43msg    db      "hw int11 ",0
    57 00000812 00                  <1>
    58 00000813 687720696E74313220- <1> int44msg    db      "hw int12 ",0
    58 0000081C 00                  <1>
    59 0000081D 687720696E74313320- <1> int45msg    db      "hw int13 ",0
    59 00000826 00                  <1>
    60 00000827 687720696E74313420- <1> int46msg    db      "hw int14 ",0
    60 00000830 00                  <1>
    61 00000831 687720696E74313520- <1> int47msg    db      "hw int15 ",0
    61 0000083A 00                  <1>
    62                              <1> 
    63 0000083B 73707572696F757320- <1> spuriousmsg db      "spurious int ",0
    63 00000844 696E742000          <1>
    64 00000849 617069636572722069- <1> apicerrmsg  db      "apicerr int ",0
    64 00000852 6E742000            <1>
    65 00000856 68692000            <1> himsg       db      "hi ",0
    66 0000085A 756E6B6E6F776E2073- <1> int255msg           db  "unknown system call ",0
    66 00000863 797374656D2063616C- <1>
    66 0000086C 6C2000              <1>
    67                              <1> 
    68 0000086F 766D206661756C743A- <1> intvmmsg            db  "vm fault: ",0
    68 00000878 2000                <1>
    69                              <1> 
    70 0000087A 90<rept>            <1>   align 4
    71 0000087C 00000000            <1> irq_err_lno dd 0
    72 00000880 00000000            <1> fault_count dd 0
    73 00000884 64000000            <1> ten_secs_counter dd 100
    74                              <1> 
    75                              <1> ; ---- IRQ hardware initialization ----
    76                              <1> 
    77                              <1> bits 16
    78                              <1> 
    79                              <1> irq_init_hardware :
    80                              <1> 
    81                              <1>     ; re-program the 8259's to move the hardware vectors out of the
    82                              <1>     ; soft int range ... C'mon, Intel was pretty clear about this!
    83                              <1> 
    84 00000888 B011                <1>     mov  al,0x11
    85 0000088A E620                <1>     out  0x20,al            ; init the 1st 8259
    86 0000088C B011                <1>     mov  al,0x11
    87 0000088E E6A0                <1>     out  0xA0,al            ; init the 2nd 8259
    88 00000890 B020                <1>     mov  al,apic0_irqbase
    89 00000892 E621                <1>     out  0x21,al            ; base for the 1st 8259
    90 00000894 B028                <1>     mov  al,apic1_irqbase
    91 00000896 E6A1                <1>     out  0xA1,al            ; base for the 2nd 8259
    92 00000898 B004                <1>     mov  al,0x04
    93 0000089A E621                <1>     out  0x21,al            ; set 1st 8259 as master
    94 0000089C B002                <1>     mov  al,0x02
    95 0000089E E6A1                <1>     out  0xA1,al            ; set 2nd 8259 as slave
    96 000008A0 B001                <1>     mov  al,0x01
    97 000008A2 E621                <1>     out  0x21,al
    98 000008A4 B001                <1>     mov  al,0x01
    99 000008A6 E6A1                <1>     out  0xA1,al
   100 000008A8 B0FC                <1>     mov  al,0xfc            ; PIC1 disable all but the timer and kbd
   101 000008AA E621                <1>     out  0x21,al
   102 000008AC B0FF                <1>     mov  al,0xff            ; PIC2 disable everything
   103 000008AE E6A1                <1>     out  0xA1,al
   104 000008B0 C3                  <1>     ret
   105                              <1> 
   106                              <1> bits 32
   107                              <1> 
   108                              <1> ; ----------
   109                              <1> 
   110                              <1> irq_init_bsp_apic_hardware :
   111                              <1>     ;jmp  no_apic
   112                              <1> 
   113                              <1>     ; ---- test for an apic
   114                              <1> 
   115                              <1> ; not needed?  causing problems?
   116                              <1> ;   mov  eax,[0xfee00370]
   117                              <1> ;   and  eax,0xffffff00
   118                              <1> ;   or   eax,apicerr_int
   119                              <1> ;   mov  [0xfee00370],eax   ; setup LVT3 error vector
   120                              <1> 
   121                              <1>     ;mov  eax,0x00000100 + spurious_int    ; enable + spurious int
   122 000008B1 B800010000          <1>     mov  eax,0x00000100     ; enable
   123 000008B6 A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
   124 000008BB B800000001          <1>     mov  eax,0x01000000
   125 000008C0 A3D000E0FE          <1>     mov  [0xfee000d0],eax   ; set our LDR
   126 000008C5 B8FFFFFFFF          <1>     mov  eax,0xffffffff
   127 000008CA A3E000E0FE          <1>     mov  [0xfee000e0],eax   ; set our DFR
   128 000008CF 31C0                <1>     xor  eax,eax
   129 000008D1 A3B000E0FE          <1>     mov  [0xfee000b0],eax   ; eoi anything outstanding
   130                              <1> 
   131                              <1> ;    ; ---- enable the local apic via msr
   132                              <1> ; but apparently not needed ...
   133                              <1> ;    mov  ecx,0x1b
   134                              <1> ;    xor  edx,edx
   135                              <1> ; ;  mov  eax,0xfffff800
   136                              <1> ;    mov  eax,0x00000800
   137                              <1> ;    wrmsr
   138                              <1> ;    mov  eax,[0xfffff030]
   139                              <1> 
   140                              <1>     ; ---- visual indicator: lapic active
   141                              <1> 
   142 000008D6 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
   143 000008DA 8EE8                <1>     mov  gs,ax
   144 000008DC 65C605320000002B    <1>     mov  byte [gs:25*2],'+'
   145                              <1> 
   146 000008E4 C3                  <1>     ret
   147                              <1> 
   148                              <1> ; ----------
   149                              <1> 
   150                              <1> irq_init_ap_apic_hardware :
   151                              <1>     ; eax = cpu number
   152                              <1> 
   153                              <1>     ; ---- mtrr for 0xfee00000 -> strong uncachable (UC) ?
   154                              <1> 
   155 000008E5 50                  <1>     push eax                ; save cpu number
   156 000008E6 89C1                <1>     mov  ecx,eax
   157 000008E8 A0[280A0000]        <1>     mov  al,[enabled_lapic]
   158 000008ED 08C0                <1>     or   al,al
   159 000008EF 741E                <1>     jz  no_lapic_init2
   160                              <1> 
   161 000008F1 BB00000001          <1>     mov  ebx,0x01000000
   162 000008F6 D3E3                <1>     shl  ebx,cl             ; bit mask based on cpu number
   163 000008F8 891DD000E0FE        <1>     mov  [0xfee000d0],ebx   ; set our LDR
   164                              <1> 
   165                              <1> ; not needed?  causing problems?
   166                              <1> ;   mov  eax,[0xfee00370]
   167                              <1> ;   and  eax,0xffffff00
   168                              <1> ;   or   eax,apicerr_int
   169                              <1> ;   mov  [0xfee00370],eax   ; setup LVT3 error vector
   170                              <1> 
   171                              <1>     ;mov  eax,0x00000100 + spurious_int  ; enable + spurious int
   172 000008FE B800010000          <1>     mov  eax,0x00000100     ; enable
   173 00000903 A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
   174 00000908 31C0                <1>     xor  eax,eax
   175 0000090A A3B000E0FE          <1>     mov  [0xfee000b0],eax   ; eoi anything outstanding
   176                              <1> no_lapic_init2 :
   177 0000090F 58                  <1>     pop  eax
   178 00000910 C3                  <1>     ret
   179                              <1> 
   180                              <1> ; ---- IRQ handlers ----
   181                              <1> 
   182 00000911 90<rept>            <1> align 4
   183                              <1> int_handler_div0 :
   184 00000914 56                  <1>     push esi
   185 00000915 BE[3D060000]        <1>     mov  esi,int00msg
   186 0000091A E8FA040000          <1>     call irq_print_msg
   187 0000091F 5E                  <1>     pop  esi
   188 00000920 E9EC000000          <1>     jmp  int_handler_show_eip
   189                              <1> 
   190 00000925 90<rept>            <1> align 4
   191                              <1> int_handler_debug :
   192 00000928 56                  <1>     push esi
   193 00000929 BE[4D060000]        <1>     mov  esi,int01msg
   194 0000092E E8E6040000          <1>     call irq_print_msg
   195 00000933 5E                  <1>     pop  esi
   196 00000934 E9D8000000          <1>     jmp  int_handler_show_eip
   197                              <1> 
   198 00000939 90<rept>            <1> align 4
   199                              <1> int_handler_nmi :
   200 0000093C 56                  <1>     push esi
   201 0000093D BE[5E060000]        <1>     mov  esi,int02msg
   202 00000942 E8D2040000          <1>     call irq_print_msg
   203 00000947 5E                  <1>     pop  esi
   204 00000948 CF                  <1>     iret
   205                              <1>     ;jmp  reboot_on_alt_key
   206                              <1> 
   207 00000949 90<rept>            <1> align 4
   208                              <1> int_handler_brkp :
   209 0000094C 56                  <1>     push esi
   210 0000094D BE[63060000]        <1>     mov  esi,int03msg
   211 00000952 E8C2040000          <1>     call irq_print_msg
   212 00000957 5E                  <1>     pop  esi
   213 00000958 E9B4000000          <1>     jmp  int_handler_show_eip
   214                              <1> 
   215 0000095D 90<rept>            <1> align 4
   216                              <1> int_handler_ovrflw :
   217 00000960 56                  <1>     push esi
   218 00000961 BE[79060000]        <1>     mov  esi,int04msg
   219 00000966 E8AE040000          <1>     call irq_print_msg
   220 0000096B 5E                  <1>     pop  esi
   221 0000096C E9A0000000          <1>     jmp  int_handler_show_eip
   222                              <1> 
   223 00000971 90<rept>            <1> align 4
   224                              <1> int_handler_bound :
   225 00000974 56                  <1>     push esi
   226 00000975 BE[8D060000]        <1>     mov  esi,int05msg
   227 0000097A E89A040000          <1>     call irq_print_msg
   228 0000097F 5E                  <1>     pop  esi
   229 00000980 E98C000000          <1>     jmp  int_handler_show_eip
   230                              <1> 
   231 00000985 90<rept>            <1> align 4
   232                              <1> int_handler_invop :
   233 00000988 56                  <1>     push esi
   234 00000989 BE[9D060000]        <1>     mov  esi,int06msg
   235 0000098E E886040000          <1>     call irq_print_msg
   236 00000993 5E                  <1>     pop  esi
   237 00000994 EB7B                <1>     jmp  int_handler_show_eip
   238                              <1> 
   239 00000996 90<rept>            <1> align 4
   240                              <1> int_handler_devna :
   241                              <1>     ;push esi
   242                              <1>     ;mov  esi,int07msg
   243                              <1>     ;call irq_print_msg
   244                              <1>     ;pop  esi
   245                              <1>     ; FIXME fxsave/fxrestore the fpu/sse/mmx regs
   246 00000998 0F06                <1>     clts                ; sure! everybody can use the fpu
   247 0000099A CF                  <1>     iret
   248                              <1> 
   249 0000099B 90                  <1> align 4
   250                              <1> int_handler_cpsego :
   251 0000099C 56                  <1>     push esi
   252 0000099D BE[CF060000]        <1>     mov  esi,int09msg
   253 000009A2 E872040000          <1>     call irq_print_msg
   254 000009A7 5E                  <1>     pop  esi
   255 000009A8 EB67                <1>     jmp  int_handler_show_eip
   256                              <1> 
   257 000009AA 90<rept>            <1> align 4
   258                              <1> int_handler_segnp :
   259                              <1>     ; ec = seg selector
   260 000009AC 56                  <1>     push esi
   261 000009AD BE[F9060000]        <1>     mov  esi,int11msg
   262 000009B2 E862040000          <1>     call irq_print_msg
   263 000009B7 5E                  <1>     pop  esi
   264 000009B8 EB32                <1>     jmp  int_handler_show_ec_eip
   265                              <1> 
   266 000009BA 90<rept>            <1> align 4
   267                              <1> int_handler_stkflt :
   268                              <1>     ; ec = seg selector
   269 000009BC 56                  <1>     push esi
   270 000009BD BE[0E070000]        <1>     mov  esi,int12msg
   271 000009C2 E852040000          <1>     call irq_print_msg
   272 000009C7 5E                  <1>     pop  esi
   273 000009C8 B904000000          <1>     mov  ecx,4
   274 000009CD 83C302              <1>     add  ebx,2
   275                              <1> int_handler_show_stack_loop :
   276 000009D0 58                  <1>     pop  eax
   277 000009D1 E85DFBFFFF          <1>     call putx_vga
   278 000009D6 E2F8                <1>     loop int_handler_show_stack_loop
   279 000009D8 E990040000          <1>     jmp  reboot_on_alt_key
   280                              <1> 
   281 000009DD 90<rept>            <1> align 4
   282                              <1> int_handler_gpf :
   283                              <1>     ; ec = various ...
   284                              <1>     ;test dword [esp+0xc],1 << 17    ; check the eflags vm bit
   285                              <1>     ;jnz  int_handler_vm_gpf
   286                              <1> 
   287 000009E0 56                  <1>     push esi
   288 000009E1 BE[1B070000]        <1>     mov  esi,int13msg
   289 000009E6 E82E040000          <1>     call irq_print_msg
   290 000009EB 5E                  <1>     pop  esi
   291                              <1> int_handler_show_ec_eip :
   292 000009EC 65C60365            <1>     mov  byte [gs:ebx],'e'
   293 000009F0 83C302              <1>     add  ebx,2
   294 000009F3 65C60363            <1>     mov  byte [gs:ebx],'c'
   295 000009F7 83C302              <1>     add  ebx,2
   296 000009FA 65C6033D            <1>     mov  byte [gs:ebx],'='
   297 000009FE 83C302              <1>     add  ebx,2
   298 00000A01 58                  <1>     pop  eax                ; ec
   299 00000A02 E81CFBFFFF          <1>     call putbx_vga
   300 00000A07 83EB02              <1>     sub  ebx,2
   301 00000A0A 65C60320            <1>     mov  byte [gs:ebx],' '
   302 00000A0E 83C302              <1>     add  ebx,2
   303                              <1> int_handler_show_eip :
   304 00000A11 65C60363            <1>     mov  byte [gs:ebx],'c'
   305 00000A15 83C302              <1>     add  ebx,2
   306 00000A18 65C60373            <1>     mov  byte [gs:ebx],'s'
   307 00000A1C 83C302              <1>     add  ebx,2
   308 00000A1F 65C6033A            <1>     mov  byte [gs:ebx],':'
   309 00000A23 83C302              <1>     add  ebx,2
   310 00000A26 65C60365            <1>     mov  byte [gs:ebx],'e'
   311 00000A2A 83C302              <1>     add  ebx,2
   312 00000A2D 65C60369            <1>     mov  byte [gs:ebx],'i'
   313 00000A31 83C302              <1>     add  ebx,2
   314 00000A34 65C60370            <1>     mov  byte [gs:ebx],'p'
   315 00000A38 83C302              <1>     add  ebx,2
   316 00000A3B 65C6033D            <1>     mov  byte [gs:ebx],'='
   317 00000A3F 83C302              <1>     add  ebx,2
   318 00000A42 5A                  <1>     pop  edx                ; eip
   319 00000A43 58                  <1>     pop  eax                ; cs
   320 00000A44 E8EAFAFFFF          <1>     call putx_vga
   321 00000A49 83EB02              <1>     sub  ebx,2
   322 00000A4C 65C6033A            <1>     mov  byte [gs:ebx],':'
   323 00000A50 83C302              <1>     add  ebx,2
   324 00000A53 89D0                <1>     mov  eax,edx
   325 00000A55 E8D9FAFFFF          <1>     call putx_vga
   326 00000A5A E90E040000          <1>     jmp  reboot_on_alt_key
   327                              <1> 
   328                              <1> int_handler_vm_gpf :
   329 00000A5F 53                  <1>     push ebx
   330                              <1>     ;mov  ebx,[esp+8]        ; faulter's eip
   331 00000A60 2E8A1B              <1>     mov  bl,[cs:ebx]        ; get the opcode that caused the fault
   332 00000A63 80FBF4              <1>     cmp  bl,0xf4            ; 'hlt' is ok
   333 00000A66 7452                <1>     jz   int_handler_vm_normal_return
   334                              <1> 
   335 00000A68 56                  <1>     push esi
   336 00000A69 50                  <1>     push eax
   337 00000A6A 53                  <1>     push ebx
   338 00000A6B BE[6F080000]        <1>     mov  esi,intvmmsg
   339 00000A70 E8A4030000          <1>     call irq_print_msg
   340 00000A75 65C6036F            <1>     mov  byte [gs:ebx],'o'
   341 00000A79 83C302              <1>     add  ebx,2
   342 00000A7C 65C60370            <1>     mov  byte [gs:ebx],'p'
   343 00000A80 83C302              <1>     add  ebx,2
   344 00000A83 65C60363            <1>     mov  byte [gs:ebx],'c'
   345 00000A87 83C302              <1>     add  ebx,2
   346 00000A8A 65C6036F            <1>     mov  byte [gs:ebx],'o'
   347 00000A8E 83C302              <1>     add  ebx,2
   348 00000A91 65C60364            <1>     mov  byte [gs:ebx],'d'
   349 00000A95 83C302              <1>     add  ebx,2
   350 00000A98 65C60365            <1>     mov  byte [gs:ebx],'e'
   351 00000A9C 83C302              <1>     add  ebx,2
   352 00000A9F 65C60328            <1>     mov  byte [gs:ebx],'('
   353 00000AA3 83C302              <1>     add  ebx,2
   354 00000AA6 58                  <1>     pop  eax
   355 00000AA7 25FF000000          <1>     and  eax,0xff
   356 00000AAC E872FAFFFF          <1>     call putbx_vga
   357 00000AB1 83C302              <1>     add  ebx,2
   358 00000AB4 65C60329            <1>     mov  byte [gs:ebx],')'
   359 00000AB8 58                  <1>     pop  eax
   360 00000AB9 5E                  <1>     pop  esi
   361                              <1> int_handler_vm_normal_return :
   362 00000ABA 5B                  <1>     pop  ebx
   363                              <1> 
   364 00000ABB FF74240C            <1>     push dword [esp+0xc]    ; eflags
   365 00000ABF 9D                  <1>     popf                    ; restore the VM and NT flags
   366 00000AC0 CF                  <1>     iret                    ; chain back via nested task
   367                              <1>                             ; from v86 tss to original caller
   368                              <1> 
   369 00000AC1 90<rept>            <1> align 4
   370                              <1> int_handler_pgflt :
   371 00000AC4 58                  <1>     pop  eax
   372 00000AC5 50                  <1>     push eax
   373 00000AC6 A904000000          <1>     test eax,0x4                        ; user mode or supervisor?
   374 00000ACB 7407                <1>     jz   int_handler_pgflt_bad_kaddr    ; if not, kernel failed
   375                              <1> 
   376                              <1> int_handler_pgflt_bad_uaddr :
   377 00000ACD BE[4D070000]        <1>     mov  esi,int14umsg
   378 00000AD2 EB05                <1>     jmp  int_handler_pgflt_msg
   379                              <1> 
   380                              <1> int_handler_pgflt_bad_kaddr :
   381 00000AD4 BE[35070000]        <1>     mov  esi,int14kmsg
   382                              <1> 
   383                              <1> int_handler_pgflt_msg :
   384 00000AD9 E83B030000          <1>     call irq_print_msg
   385 00000ADE 0F20D0              <1>     mov  eax,cr2
   386 00000AE1 E84DFAFFFF          <1>     call putx_vga                       ; print the addres of the fault
   387 00000AE6 E901FFFFFF          <1>     jmp  int_handler_show_ec_eip
   388                              <1> 
   389 00000AEB 90                  <1> align 4
   390                              <1> int_handler_fpuerr :
   391 00000AEC 56                  <1>     push esi
   392 00000AED BE[62070000]        <1>     mov  esi,int16msg
   393 00000AF2 E822030000          <1>     call irq_print_msg
   394                              <1>     ; FIXME flags identify error
   395                              <1>     ;   IS - FPU stack overflow
   396                              <1>     ;   IA - Invalid arithmetic operation
   397                              <1>     ;   Z  - Divide by zero
   398                              <1>     ;   D  - Source operand is a denormal number
   399                              <1>     ;   O  - Overflow in result
   400                              <1>     ;   U  - Underflow in result
   401                              <1>     ;   P  - Inexact result
   402 00000AF7 E915FFFFFF          <1>     jmp  int_handler_show_eip
   403                              <1> 
   404                              <1> align 4
   405                              <1> int_handler_algnchk :
   406                              <1>     ; ec = zero
   407 00000AFC 56                  <1>     push esi
   408 00000AFD BE[76070000]        <1>     mov  esi,int17msg
   409 00000B02 E812030000          <1>     call irq_print_msg
   410 00000B07 5E                  <1>     pop  esi
   411 00000B08 58                  <1>     pop  eax                    ; toss the ec
   412 00000B09 E903FFFFFF          <1>     jmp  int_handler_show_eip
   413                              <1> 
   414 00000B0E 90<rept>            <1> align 4
   415                              <1> int_handler_machchk :
   416 00000B10 56                  <1>     push esi
   417 00000B11 BE[87070000]        <1>     mov  esi,int18msg
   418 00000B16 E8FE020000          <1>     call irq_print_msg
   419 00000B1B 5E                  <1>     pop  esi
   420 00000B1C E9F0FEFFFF          <1>     jmp  int_handler_show_eip
   421                              <1> 
   422 00000B21 90<rept>            <1> align 4
   423                              <1> int_handler_simdfpe :
   424 00000B24 56                  <1>     push esi
   425 00000B25 BE[96070000]        <1>     mov  esi,int19msg
   426 00000B2A E8EA020000          <1>     call irq_print_msg
   427 00000B2F 5E                  <1>     pop  esi
   428 00000B30 E9DCFEFFFF          <1>     jmp  int_handler_show_eip
   429                              <1> 
   430                              <1> ; indicate that an irq has been serviced
   431                              <1> display_irq :
   432 00000B35 50                  <1>     push eax
   433 00000B36 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
   434 00000B3A 8EE8                <1>     mov  gs,ax
   435 00000B3C 88F8                <1>     mov  al,bh              ; display irq "number"
   436 00000B3E 81E3FF000000        <1>     and  ebx,0xff
   437 00000B44 658803              <1>     mov  [gs:ebx],al
   438 00000B47 658A4301            <1>     mov  al,[gs:ebx+1]
   439 00000B4B FEC0                <1>     inc  al
   440 00000B4D 0C08                <1>     or   al,0x8             ; avoid black and dark colors
   441 00000B4F 240F                <1>     and  al,0xf
   442 00000B51 65884301            <1>     mov  [gs:ebx+1],al      ; change character color
   443 00000B55 58                  <1>     pop  eax
   444 00000B56 C3                  <1>     ret
   445                              <1> 
   446                              <1> 
   447                              <1> ipi_cpu :
   448 00000B57 50                  <1>     push eax
   449 00000B58 31C0                <1>     xor  eax,eax
   450                              <1> ;   shl  eax,24                     ; cpu (apic) number is in eax
   451 00000B5A A31003E0FE          <1>     mov  dword [0xfee00310],eax     ; via the destination register ...
   452                              <1> ;   mov  eax,0x04800 + wakeup_int   ; no shrthnd, fixed, logical, edge
   453                              <1> 
   454                              <1> ; ah, just kick everybody so each can see if there is something to do
   455 00000B5F B8FE480C00          <1>     mov  eax,0xc4800 + wakeup_int   ; all except self, fixed, logical, edge
   456 00000B64 A30003E0FE          <1>     mov  dword [0xfee00300],eax
   457 00000B69 58                  <1>     pop  eax
   458 00000B6A C3                  <1>     ret
   459                              <1> 
   460 00000B6B 90                  <1> align 4
   461                              <1> int_handler_timer :
   462 00000B6C 50                  <1>     push eax
   463 00000B6D 53                  <1>     push ebx
   464 00000B6E 51                  <1>     push ecx
   465 00000B6F 66BB3C74            <1>     mov  bx,('t' << 8) + 30*2
   466 00000B73 E8BDFFFFFF          <1>     call display_irq
   467                              <1> 
   468                              <1>     ; ---- freeze on fault: this stops all timer related activity
   469                              <1>     ; ---- (also see ozsys.asm)
   470 00000B78 833D[80080000]00    <1>     cmp  dword [fault_count],0
   471 00000B7F 7512                <1>     jnz  freeze_for_debug
   472                              <1> 
   473                              <1>     ; ---- wakeup any sleeping cpus (see syscall_sleep)
   474                              <1> 
   475                              <1>     ; resume handles this now ...
   476                              <1>     ;call ipi_cpu
   477                              <1> 
   478                              <1>     ; debug
   479 00000B81 A1[84080000]        <1>     mov eax,[ten_secs_counter]
   480 00000B86 48                  <1>     dec eax
   481 00000B87 7705                <1>     ja  dont_reset
   482 00000B89 B864000000          <1>     mov eax,100
   483                              <1> dont_reset :
   484 00000B8E A3[84080000]        <1>     mov [ten_secs_counter],eax
   485                              <1>     ; debug end
   486                              <1> 
   487                              <1> freeze_for_debug :
   488 00000B93 B020                <1>     mov  al,0x20
   489 00000B95 E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
   490 00000B97 59                  <1>     pop  ecx
   491 00000B98 5B                  <1>     pop  ebx
   492 00000B99 58                  <1>     pop  eax
   493 00000B9A CF                  <1>     iret
   494                              <1> 
   495 00000B9B 90                  <1> align 4
   496                              <1> int_handler_kbd :
   497 00000B9C 53                  <1>     push ebx
   498 00000B9D 66BB3E6B            <1>     mov  bx,('k' << 8) + 31*2
   499 00000BA1 E88FFFFFFF          <1>     call display_irq
   500 00000BA6 5B                  <1>     pop  ebx
   501                              <1> 
   502 00000BA7 50                  <1>     push eax
   503                              <1> 
   504 00000BA8 53                  <1>     push ebx
   505 00000BA9 BB36000000          <1>     mov  ebx,27*2
   506 00000BAE E460                <1>     in   al,0x60
   507 00000BB0 50                  <1>     push eax
   508 00000BB1 E86DF9FFFF          <1>     call putbx_vga
   509 00000BB6 58                  <1>     pop  eax
   510 00000BB7 5B                  <1>     pop  ebx
   511                              <1> 
   512 00000BB8 3C53                <1>     cmp  al,0x53            ; scan code for the DEL key
   513 00000BBA 0F84B4020000        <1>     jz   reboot
   514                              <1> 
   515 00000BC0 B020                <1>     mov  al,0x20
   516 00000BC2 E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
   517                              <1> 
   518 00000BC4 58                  <1>     pop  eax
   519 00000BC5 CF                  <1>     iret
   520                              <1> 
   521 00000BC6 90<rept>            <1> align 4
   522                              <1> int_handler_hw02 :          ; cascade
   523 00000BC8 53                  <1>     push ebx
   524 00000BC9 66BB4063            <1>     mov  bx,('c' << 8) + 32*2
   525 00000BCD E863FFFFFF          <1>     call display_irq
   526 00000BD2 5B                  <1>     pop  ebx
   527                              <1> 
   528 00000BD3 56                  <1>     push esi
   529 00000BD4 BE[AF070000]        <1>     mov  esi,int34msg
   530 00000BD9 E83B020000          <1>     call irq_print_msg
   531 00000BDE 5E                  <1>     pop  esi
   532 00000BDF E989020000          <1>     jmp  reboot_on_alt_key
   533                              <1> 
   534                              <1> align 4
   535                              <1> int_handler_hw03 :          ; serial port 2
   536 00000BE4 53                  <1>     push ebx
   537 00000BE5 66BB4233            <1>     mov  bx,('3' << 8) + 33*2
   538 00000BE9 E847FFFFFF          <1>     call display_irq
   539 00000BEE 5B                  <1>     pop  ebx
   540                              <1> 
   541 00000BEF 56                  <1>     push esi
   542 00000BF0 BE[B9070000]        <1>     mov  esi,int35msg
   543 00000BF5 E81F020000          <1>     call irq_print_msg
   544 00000BFA 5E                  <1>     pop  esi
   545 00000BFB E96D020000          <1>     jmp  reboot_on_alt_key
   546                              <1> 
   547                              <1> align 4
   548                              <1> int_handler_hw04 :          ; serial port 1
   549 00000C00 53                  <1>     push ebx
   550 00000C01 66BB4434            <1>     mov  bx,('4' << 8) + 34*2
   551 00000C05 E82BFFFFFF          <1>     call display_irq
   552 00000C0A 5B                  <1>     pop  ebx
   553                              <1> 
   554 00000C0B 56                  <1>     push esi
   555 00000C0C BE[C3070000]        <1>     mov  esi,int36msg
   556 00000C11 E803020000          <1>     call irq_print_msg
   557 00000C16 5E                  <1>     pop  esi
   558 00000C17 E951020000          <1>     jmp  reboot_on_alt_key
   559                              <1> 
   560                              <1> align 4
   561                              <1> int_handler_hw05 :          ; parallel port 2 or sound card
   562 00000C1C 53                  <1>     push ebx
   563 00000C1D 66BB4635            <1>     mov  bx,('5' << 8) + 35*2
   564 00000C21 E80FFFFFFF          <1>     call display_irq
   565 00000C26 5B                  <1>     pop  ebx
   566                              <1> 
   567 00000C27 56                  <1>     push esi
   568 00000C28 BE[CD070000]        <1>     mov  esi,int37msg
   569 00000C2D E8E7010000          <1>     call irq_print_msg
   570 00000C32 5E                  <1>     pop  esi
   571 00000C33 E935020000          <1>     jmp  reboot_on_alt_key
   572                              <1> 
   573                              <1> align 4
   574                              <1> int_handler_hw06 :          ; floppy disk controller
   575 00000C38 53                  <1>     push ebx
   576 00000C39 66BB4836            <1>     mov  bx,('6' << 8) + 36*2
   577 00000C3D E8F3FEFFFF          <1>     call display_irq
   578 00000C42 5B                  <1>     pop  ebx
   579                              <1> 
   580 00000C43 56                  <1>     push esi
   581 00000C44 BE[D7070000]        <1>     mov  esi,int38msg
   582 00000C49 E8CB010000          <1>     call irq_print_msg
   583 00000C4E 5E                  <1>     pop  esi
   584 00000C4F E919020000          <1>     jmp  reboot_on_alt_key
   585                              <1> 
   586                              <1> align 4
   587                              <1> int_handler_hw07 :          ; parallel port 1
   588 00000C54 53                  <1>     push ebx
   589 00000C55 66BB4A37            <1>     mov  bx,('7' << 8) + 37*2
   590 00000C59 E8D7FEFFFF          <1>     call display_irq
   591 00000C5E 5B                  <1>     pop  ebx
   592                              <1> 
   593                              <1> ;   push esi                ; 7 seems to happen a lot on some boxes
   594                              <1> ;   mov  esi,int39msg
   595                              <1> ;   call irq_print_msg
   596                              <1> ;   pop  esi
   597 00000C5F B020                <1>     mov  al,0x20
   598 00000C61 E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
   599 00000C63 CF                  <1>     iret
   600                              <1>     ;jmp  reboot_on_alt_key
   601                              <1> 
   602                              <1> align 4
   603                              <1> int_handler_hw08 :          ; RTC
   604 00000C64 53                  <1>     push ebx
   605 00000C65 66BB4C38            <1>     mov  bx,('8' << 8) + 38*2
   606 00000C69 E8C7FEFFFF          <1>     call display_irq
   607 00000C6E 5B                  <1>     pop  ebx
   608                              <1> 
   609 00000C6F 56                  <1>     push esi
   610 00000C70 BE[EB070000]        <1>     mov  esi,int40msg
   611 00000C75 E89F010000          <1>     call irq_print_msg
   612 00000C7A 5E                  <1>     pop  esi
   613 00000C7B E9ED010000          <1>     jmp  reboot_on_alt_key
   614                              <1> 
   615                              <1> align 4
   616                              <1> int_handler_hw09 :          ; acpi
   617 00000C80 53                  <1>     push ebx
   618 00000C81 66BB4E39            <1>     mov  bx,('9' << 8) + 39*2
   619 00000C85 E8ABFEFFFF          <1>     call display_irq
   620 00000C8A 5B                  <1>     pop  ebx
   621                              <1> 
   622 00000C8B 56                  <1>     push esi
   623 00000C8C BE[F5070000]        <1>     mov  esi,int41msg
   624 00000C91 E883010000          <1>     call irq_print_msg
   625 00000C96 5E                  <1>     pop  esi
   626 00000C97 E9D1010000          <1>     jmp  reboot_on_alt_key
   627                              <1> 
   628                              <1> align 4
   629                              <1> int_handler_hw10 :
   630 00000C9C 53                  <1>     push ebx
   631 00000C9D 66BB5061            <1>     mov  bx,('a' << 8) + 40*2
   632 00000CA1 E88FFEFFFF          <1>     call display_irq
   633 00000CA6 5B                  <1>     pop  ebx
   634                              <1> 
   635 00000CA7 56                  <1>     push esi
   636 00000CA8 BE[FF070000]        <1>     mov  esi,int42msg
   637 00000CAD E867010000          <1>     call irq_print_msg
   638 00000CB2 5E                  <1>     pop  esi
   639 00000CB3 E9B5010000          <1>     jmp  reboot_on_alt_key
   640                              <1> 
   641                              <1> align 4
   642                              <1> int_handler_hw11 :
   643 00000CB8 53                  <1>     push ebx
   644 00000CB9 66BB5262            <1>     mov  bx,('b' << 8) + 41*2
   645 00000CBD E873FEFFFF          <1>     call display_irq
   646 00000CC2 5B                  <1>     pop  ebx
   647                              <1> 
   648 00000CC3 56                  <1>     push esi
   649 00000CC4 BE[09080000]        <1>     mov  esi,int43msg
   650 00000CC9 E84B010000          <1>     call irq_print_msg
   651 00000CCE 5E                  <1>     pop  esi
   652 00000CCF E999010000          <1>     jmp  reboot_on_alt_key
   653                              <1> 
   654                              <1> align 4
   655                              <1> int_handler_hw12 :          ; mouse
   656 00000CD4 53                  <1>     push ebx
   657 00000CD5 66BB5463            <1>     mov  bx,('c' << 8) + 42*2
   658 00000CD9 E857FEFFFF          <1>     call display_irq
   659 00000CDE 5B                  <1>     pop  ebx
   660                              <1> 
   661 00000CDF 56                  <1>     push esi
   662 00000CE0 BE[13080000]        <1>     mov  esi,int44msg
   663 00000CE5 E82F010000          <1>     call irq_print_msg
   664 00000CEA 5E                  <1>     pop  esi
   665 00000CEB E97D010000          <1>     jmp  reboot_on_alt_key
   666                              <1> 
   667                              <1> align 4
   668                              <1> int_handler_hw13 :          ; co-processor
   669 00000CF0 53                  <1>     push ebx
   670 00000CF1 66BB5664            <1>     mov  bx,('d' << 8) + 43*2
   671 00000CF5 E83BFEFFFF          <1>     call display_irq
   672 00000CFA 5B                  <1>     pop  ebx
   673                              <1> 
   674 00000CFB 56                  <1>     push esi
   675 00000CFC BE[1D080000]        <1>     mov  esi,int45msg
   676 00000D01 E813010000          <1>     call irq_print_msg
   677 00000D06 5E                  <1>     pop  esi
   678 00000D07 E961010000          <1>     jmp  reboot_on_alt_key
   679                              <1> 
   680                              <1> align 4
   681                              <1> int_handler_hw14 :          ; ata disk controller primary
   682 00000D0C 53                  <1>     push ebx
   683 00000D0D 66BB5865            <1>     mov  bx,('e' << 8) + 44*2
   684 00000D11 E81FFEFFFF          <1>     call display_irq
   685 00000D16 5B                  <1>     pop  ebx
   686                              <1> 
   687 00000D17 56                  <1>     push esi
   688 00000D18 BE[27080000]        <1>     mov  esi,int46msg
   689 00000D1D E8F7000000          <1>     call irq_print_msg
   690 00000D22 5E                  <1>     pop  esi
   691 00000D23 E945010000          <1>     jmp  reboot_on_alt_key
   692                              <1> 
   693                              <1> align 4
   694                              <1> int_handler_hw15 :          ; ata disk controller secondary
   695 00000D28 53                  <1>     push ebx
   696 00000D29 66BB5A66            <1>     mov  bx,('f' << 8) + 45*2
   697 00000D2D E803FEFFFF          <1>     call display_irq
   698 00000D32 5B                  <1>     pop  ebx
   699                              <1> 
   700 00000D33 56                  <1>     push esi
   701 00000D34 BE[31080000]        <1>     mov  esi,int47msg
   702 00000D39 E8DB000000          <1>     call irq_print_msg
   703 00000D3E 5E                  <1>     pop  esi
   704 00000D3F E929010000          <1>     jmp  reboot_on_alt_key
   705                              <1> 
   706                              <1> ; called via the double fault task
   707                              <1> align 4
   708                              <1> int_handler_tg_dblflt :
   709 00000D44 56                  <1>     push esi
   710 00000D45 BE[C1060000]        <1>     mov  esi,int08msg
   711 00000D4A E8CA000000          <1>     call irq_print_msg
   712 00000D4F 5E                  <1>     pop  esi
   713 00000D50 83C302              <1>     add  ebx,2
   714 00000D53 0F20D0              <1>     mov  eax,cr2
   715                              <1>     ;mov  eax,[esp]           ; print the value on the stack
   716 00000D56 E8D8F7FFFF          <1>     call putx_vga
   717 00000D5B E90D010000          <1>     jmp  reboot_on_alt_key
   718                              <1> 
   719                              <1> ; called via the invalid tss task
   720                              <1> align 4
   721                              <1> int_handler_tg_invtss :
   722 00000D60 56                  <1>     push esi
   723 00000D61 BE[EC060000]        <1>     mov  esi,int10msg
   724 00000D66 E8AE000000          <1>     call irq_print_msg
   725 00000D6B 5E                  <1>     pop  esi
   726                              <1>     ; FIXME need to go back to previous tss to get ec via that stack
   727 00000D6C 83C302              <1>     add  ebx,2
   728 00000D6F 58                  <1>     pop  eax                ; ec == invalid tss selector
   729 00000D70 E8BEF7FFFF          <1>     call putx_vga
   730 00000D75 E9F3000000          <1>     jmp  reboot_on_alt_key
   731                              <1> 
   732 00000D7A 90<rept>            <1> align 4
   733                              <1> int_handler_spurious :
   734 00000D7C 56                  <1>     push esi
   735 00000D7D BE[3B080000]        <1>     mov  esi,spuriousmsg
   736 00000D82 E892000000          <1>     call irq_print_msg
   737 00000D87 5E                  <1>     pop  esi
   738 00000D88 CF                  <1>     iret
   739                              <1> 
   740 00000D89 90<rept>            <1> align 4
   741                              <1> int_handler_apicerr :
   742 00000D8C 56                  <1>     push esi
   743 00000D8D BE[49080000]        <1>     mov  esi,apicerrmsg
   744 00000D92 E882000000          <1>     call irq_print_msg
   745 00000D97 5E                  <1>     pop  esi
   746 00000D98 CF                  <1>     iret
   747                              <1> 
   748                              <1> ; serves only to eoi the fixed ipi used for sleep wakeup
   749 00000D99 90<rept>            <1> align 4
   750                              <1> wakeup :
   751 00000D9C C705B000E0FE000000- <1>     mov  dword [0xfee000b0],0   ; lapic eoi
   751 00000DA5 00                  <1>
   752 00000DA6 CF                  <1>     iret
   753                              <1> 
   754                              <1> 
   755 00000DA7 90                  <1> align 4
   756                              <1> ; %if ($ >= 0x8000) bomb
   757                              <1> sysent :
   758 00000DA8 3D00020000          <1>     cmp  eax,0x0200
   759 00000DAD 0F84F9020000        <1>     jz   syscall_klog
   760 00000DB3 3D00100000          <1>     cmp  eax,0x1000
   761 00000DB8 0F8403030000        <1>     jz   syscall_ncpus
   762 00000DBE 3D00200000          <1>     cmp  eax,0x2000
   763 00000DC3 0F8438030000        <1>     jz   syscall_sleep
   764 00000DC9 3D01200000          <1>     cmp  eax,0x2001
   765 00000DCE 0F8448030000        <1>     jz   syscall_pause
   766 00000DD4 3D02200000          <1>     cmp  eax,0x2002
   767 00000DD9 0F8440030000        <1>     jz   syscall_resume
   768 00000DDF 3D03200000          <1>     cmp  eax,0x2003
   769 00000DE4 0F843B030000        <1>     jz   syscall_ipi_all
   770 00000DEA 3D00210000          <1>     cmp  eax,0x2100
   771 00000DEF 0F84D2020000        <1>     jz   syscall_new_thread
   772 00000DF5 3D00270000          <1>     cmp  eax,0x2700
   773 00000DFA 0F842B030000        <1>     jz   syscall_request_pmem_access
   774 00000E00 3D00FE0000          <1>     cmp  eax,0xfe00
   775 00000E05 0F84B0020000        <1>     jz   syscall_sipi_vector
   776 00000E0B BE[5A080000]        <1>     mov  esi,int255msg
   777 00000E10 E804000000          <1>     call irq_print_msg
   778 00000E15 31C0                <1>     xor  eax,eax
   779 00000E17 48                  <1>     dec  eax
   780 00000E18 CF                  <1>     iret
   781                              <1> 
   782                              <1> 
   783                              <1> ; ---- IRQ support code ---- 
   784                              <1> 
   785                              <1> irq_print_msg :
   786 00000E19 B801000000          <1>     mov  eax,1
   787 00000E1E 0FC105[7C080000]    <1>     xadd [irq_err_lno],eax
   788 00000E25 50                  <1>     push eax                ; remember line number
   789 00000E26 83E003              <1>     and  eax,0x3            ; only four lines
   790 00000E29 40                  <1>     inc  eax                ; start with line 1
   791 00000E2A BBA0000000          <1>     mov  ebx,160            ; vga line length
   792 00000E2F 0FAFC3              <1>     imul eax,ebx
   793 00000E32 89C3                <1>     mov  ebx,eax
   794                              <1> 
   795 00000E34 A0[280A0000]        <1>     mov  al,[enabled_lapic]
   796 00000E39 08C0                <1>     or   al,al
   797 00000E3B 58                  <1>     pop  eax
   798 00000E3C 742A                <1>     jz   skip_cpumsg
   799                              <1> 
   800 00000E3E 56                  <1>     push esi
   801 00000E3F 50                  <1>     push eax
   802 00000E40 BE[39060000]        <1>     mov  esi,cpumsg
   803 00000E45 E8C2F6FFFF          <1>     call puts_vga
   804 00000E4A A12000E0FE          <1>     mov  eax,[0xfee00020]   ; print our apic id
   805 00000E4F C1E818              <1>     shr  eax,24
   806 00000E52 83C030              <1>     add  eax,'0'
   807 00000E55 658803              <1>     mov  [gs:ebx],al
   808 00000E58 58                  <1>     pop  eax                ; recover line number
   809 00000E59 C0E802              <1>     shr  al,2               ; provide a rolling effect for
   810 00000E5C 240F                <1>     and  al,0xf             ;     unending irq messages
   811 00000E5E 0C08                <1>     or   al,0x8
   812 00000E60 65884301            <1>     mov  [gs:ebx+1],al
   813 00000E64 83C304              <1>     add  ebx,4
   814 00000E67 5E                  <1>     pop  esi
   815                              <1> 
   816                              <1> skip_cpumsg :
   817 00000E68 E99FF6FFFF          <1>     jmp  puts_vga
   818                              <1> 
   819                              <1> 
   820                              <1> reboot_on_alt_key :
   821                              <1>     ;inc  dword [fault_count]
   822 00000E6D FA                  <1>     cli
   823                              <1> reboot_on_alt_key_loop :
   824 00000E6E E460                <1>     in   al,0x60
   825 00000E70 3C53                <1>     cmp  al,0x53            ; scan code for the DEL key
   826 00000E72 75FA                <1>     jnz  reboot_on_alt_key_loop
   827                              <1> reboot :
   828 00000E74 0F011D[A00E0000]    <1>     lidt [reboot_idt]       ; restore boot idt (helps qemu ...)
   829 00000E7B EA[820E0000]2800    <1>     jmp  rmcssel:reboot_exit_pmode      ; thankyou hpa
   830                              <1> reboot_exit_pmode :
   831                              <1> bits 16
   832 00000E82 B83000              <1>     mov  ax,rmdssel
   833 00000E85 8ED8                <1>     mov  ds,ax
   834 00000E87 8EC0                <1>     mov  es,ax
   835 00000E89 8ED0                <1>     mov  ss,ax
   836 00000E8B 8EE0                <1>     mov  fs,ax
   837 00000E8D 8EE8                <1>     mov  gs,ax
   838                              <1> 
   839 00000E8F 0F20C0              <1>     mov  eax,cr0
   840 00000E92 6625FEFFFF7F        <1>     and  eax,0x7ffffffe
   841 00000E98 0F22C0              <1>     mov  cr0,eax            ; disable pmode and paging
   842 00000E9B EA0000FFFF          <1>     jmp  0xffff:0           ; jump to the warm start vector and
   843                              <1>                             ; flush the I prefetch queue all at once
   844                              <1> 
   845                              <1> reboot_idt :
   846 00000EA0 FFFF                <1>     dw 0xffff
   847 00000EA2 00000000            <1>     dd 0
   848                              <1> 
   849                              <1> 
   850                              <1> ; ---- IDT initialization table ---- 
   851                              <1> ;
   852                              <1> ; One dw (2 bytes per vector) is used which means that all
   853                              <1> ; int_handler entry points must reside below 0x10000!
   854                              <1> ;
   855                              <1> ; And since all int_handler routines are 4 byte aligned,
   856                              <1> ; the bottom two bits are available to indicate type.
   857                              <1> ; These bits index into the irq_types table below.
   858                              <1> 
   859 00000EA6 90<rept>            <1> align 4
   860                              <1> 
   861                              <1> ; note: these are not gdt/ldt descriptors (see swdev3a 6.11 pg 228)
   862                              <1> 
   863 00000EA8 8E                  <1> irq_types   db  0x8e            ; dpl=0 32bit interrupt gate (sets IF flag)
   864 00000EA9 EE                  <1>             db  0xee            ; dpl=3 32bit app (ring3) interrupt gate
   865 00000EAA 85                  <1>             db  0x85            ; dpl=0 32bit task gate
   866 00000EAB 8F                  <1>             db  0x8f            ; dpl=0 32bit trap gate (does not set IF flag)
   867                              <1> 
   868                              <1> ; all handlers/selectors are 4 byte aligned - this gives us
   869                              <1> ; two bits to use to designate 1 of 4 types of idt descriptors ...
   870                              <1> 
   871                              <1> irqt_intr   equ 0
   872                              <1> irqt_app    equ 1
   873                              <1> irqt_task   equ 2
   874                              <1> irqt_trap   equ 3
   875                              <1> 
   876                              <1> irq_setup_table:
   877                              <1>     ; cpu defined
   878 00000EAC [1709]              <1>     dw  int_handler_div0      + irqt_trap ; 0
   879 00000EAE [2B09]              <1>     dw  int_handler_debug     + irqt_trap ; 1
   880 00000EB0 [3C09]              <1>     dw  int_handler_nmi       + irqt_intr ; 2
   881 00000EB2 [4D09]              <1>     dw  int_handler_brkp      + irqt_app  ; 3
   882 00000EB4 [6109]              <1>     dw  int_handler_ovrflw    + irqt_app  ; 4
   883 00000EB6 [7509]              <1>     dw  int_handler_bound     + irqt_app  ; 5
   884 00000EB8 [8B09]              <1>     dw  int_handler_invop     + irqt_trap ; 6
   885 00000EBA [9B09]              <1>     dw  int_handler_devna     + irqt_trap ; 7
   886 00000EBC 4A00                <1>     dw  tasksel_f08           + irqt_task ; 8   double fault
   887 00000EBE [9F09]              <1>     dw  int_handler_cpsego    + irqt_trap ; 9
   888 00000EC0 5200                <1>     dw  tasksel_f10           + irqt_task ; 10  invalid tss
   889 00000EC2 [AF09]              <1>     dw  int_handler_segnp     + irqt_trap ; 11
   890 00000EC4 [BF09]              <1>     dw  int_handler_stkflt    + irqt_trap ; 12
   891 00000EC6 [E309]              <1>     dw  int_handler_gpf       + irqt_trap ; 13
   892 00000EC8 [C40A]              <1>     dw  int_handler_pgflt     + irqt_intr ; 14
   893 00000ECA 0000                <1>     dw  0                                 ; 15  Intel reserved
   894 00000ECC [EF0A]              <1>     dw  int_handler_fpuerr    + irqt_trap ; 16
   895 00000ECE [FF0A]              <1>     dw  int_handler_algnchk   + irqt_trap ; 17
   896 00000ED0 [130B]              <1>     dw  int_handler_machchk   + irqt_trap ; 18
   897 00000ED2 [270B]              <1>     dw  int_handler_simdfpe   + irqt_trap ; 19
   898 00000ED4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0
   898 00000EDD 000000000000000000- <1>
   898 00000EE6 000000000000        <1>
   899                              <1>     ; hw defined
   900                              <1> apic0_irqbase equ ($ - irq_setup_table)/2
   901 00000EEC [6C0B]              <1>     dw  int_handler_timer     + irqt_intr ; 32  0x20
   902 00000EEE [9C0B]              <1>     dw  int_handler_kbd       + irqt_intr ; 33
   903 00000EF0 [C80B]              <1>     dw  int_handler_hw02      + irqt_intr ; 34
   904 00000EF2 [E40B]              <1>     dw  int_handler_hw03      + irqt_intr ; 35
   905 00000EF4 [000C]              <1>     dw  int_handler_hw04      + irqt_intr ; 36
   906 00000EF6 [1C0C]              <1>     dw  int_handler_hw05      + irqt_intr ; 37
   907 00000EF8 [380C]              <1>     dw  int_handler_hw06      + irqt_intr ; 38
   908 00000EFA [540C]              <1>     dw  int_handler_hw07      + irqt_intr ; 39
   909                              <1> apic1_irqbase equ ($ - irq_setup_table)/2
   910 00000EFC [640C]              <1>     dw  int_handler_hw08      + irqt_intr ; 40
   911 00000EFE [800C]              <1>     dw  int_handler_hw09      + irqt_intr ; 41
   912 00000F00 [9C0C]              <1>     dw  int_handler_hw10      + irqt_intr ; 42
   913 00000F02 [B80C]              <1>     dw  int_handler_hw11      + irqt_intr ; 43
   914 00000F04 [D40C]              <1>     dw  int_handler_hw12      + irqt_intr ; 44
   915 00000F06 [F00C]              <1>     dw  int_handler_hw13      + irqt_intr ; 45
   916 00000F08 [0C0D]              <1>     dw  int_handler_hw14      + irqt_intr ; 46
   917 00000F0A [280D]              <1>     dw  int_handler_hw15      + irqt_intr ; 47  0x2f
   918                              <1>     ; undefined - hw can expand here
   919 00000F0C 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x30
   919 00000F15 000000000000000000- <1>
   919 00000F1E 000000000000000000- <1>
   919 00000F27 0000000000          <1>
   920 00000F2C 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x40
   920 00000F35 000000000000000000- <1>
   920 00000F3E 000000000000000000- <1>
   920 00000F47 0000000000          <1>
   921 00000F4C 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x50
   921 00000F55 000000000000000000- <1>
   921 00000F5E 000000000000000000- <1>
   921 00000F67 0000000000          <1>
   922 00000F6C 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x60
   922 00000F75 000000000000000000- <1>
   922 00000F7E 000000000000000000- <1>
   922 00000F87 0000000000          <1>
   923 00000F8C 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x70
   923 00000F95 000000000000000000- <1>
   923 00000F9E 000000000000000000- <1>
   923 00000FA7 0000000000          <1>
   924 00000FAC 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x80
   924 00000FB5 000000000000000000- <1>
   924 00000FBE 000000000000000000- <1>
   924 00000FC7 0000000000          <1>
   925 00000FCC 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x90
   925 00000FD5 000000000000000000- <1>
   925 00000FDE 000000000000000000- <1>
   925 00000FE7 0000000000          <1>
   926 00000FEC 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xa0
   926 00000FF5 000000000000000000- <1>
   926 00000FFE 000000000000000000- <1>
   926 00001007 0000000000          <1>
   927 0000100C 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xb0
   927 00001015 000000000000000000- <1>
   927 0000101E 000000000000000000- <1>
   927 00001027 0000000000          <1>
   928 0000102C 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xc0
   928 00001035 000000000000000000- <1>
   928 0000103E 000000000000000000- <1>
   928 00001047 0000000000          <1>
   929 0000104C 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xd0
   929 00001055 000000000000000000- <1>
   929 0000105E 000000000000000000- <1>
   929 00001067 0000000000          <1>
   930 0000106C 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     ; 0xe0
   930 00001075 000000000000000000- <1>
   930 0000107E 000000000000000000- <1>
   930 00001087 000000              <1>
   931                              <1> spurious_int equ ($ - irq_setup_table)/2
   932 0000108A [7C0D]              <1>     dw  int_handler_spurious  + irqt_intr
   933                              <1> apicerr_int equ ($ - irq_setup_table)/2
   934 0000108C [8D0D]              <1>     dw  int_handler_apicerr   + irqt_app
   935 0000108E 000000000000000000- <1>     dw    0,0,0,0,0,0,0,0,0,0,0,0,0       ; 0xf0
   935 00001097 000000000000000000- <1>
   935 000010A0 0000000000000000    <1>
   936                              <1>     ; sw defined - expand down if needed
   937                              <1> wakeup_int equ ($ - irq_setup_table)/2
   938 000010A8 [9D0D]              <1>     dw  wakeup                + irqt_app
   939 000010AA [A90D]              <1>     dw  sysent                + irqt_app  ; 256  0xff
   940                              <1> irq_setup_table_size equ ($ - irq_setup_table)/2
   941                              <1> 
  1004                                  
  1005                                  ; -------- system calls --------
  1006                                  %include "ozsys.asm"
     1                              <1> ; OZ - A more utopian OS    x86-32 system calls
     2                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
     3                              <1> ;
     4                              <1> ; Copyright (C) 2015  Duane Voth
     5                              <1> ;
     6                              <1> ;   This program is free software: you can redistribute it and/or modify
     7                              <1> ;   it under the terms of the GNU Affero General Public License as
     8                              <1> ;   published by the Free Software Foundation, either version 3 of the
     9                              <1> ;   License, or (at your option) any later version.
    10                              <1> ;
    11                              <1> ;   This program is distributed in the hope that it will be useful,
    12                              <1> ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
    13                              <1> ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    14                              <1> ;   GNU Affero General Public License for more details.
    15                              <1> ;
    16                              <1> ;   You should have received a copy of the GNU Affero General Public License
    17                              <1> ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
    18                              <1> ;
    19                              <1> ;
    20                              <1> ; OZ System Calls  (for ozapps)
    21                              <1> 
    22                              <1> bits 32
    23                              <1> 
    24                              <1> ;------------------------------------------------------------------
    25                              <1> ;   syscall_klog : place a message on the vga line reserved for klog  :D
    26                              <1> ;
    27                              <1> ;   entry:
    28                              <1> ;       esi = message address
    29                              <1> ;   exit:
    30                              <1> 
    31                              <1> syscall_klog :
    32 000010AC 53                  <1>     push ebx
    33 000010AD BB20030000          <1>     mov  ebx,5 * 160        ; line 6
    34 000010B2 E855F4FFFF          <1>     call puts_vga
    35 000010B7 5B                  <1>     pop  ebx
    36 000010B8 31C0                <1>     xor  eax,eax
    37 000010BA CF                  <1>     iret
    38                              <1> 
    39                              <1> ;------------------------------------------------------------------
    40                              <1> ;   syscall_sipi_vector : get the entry vector for non-boot cpus
    41                              <1> ;
    42                              <1> ;   entry:
    43                              <1> ;   exit:
    44                              <1> ;       eax = N cpus
    45                              <1> 
    46                              <1> syscall_sipi_vector :
    47 000010BB B800700000          <1>     mov  eax,sipi_vector
    48 000010C0 CF                  <1>     iret
    49                              <1> 
    50                              <1> ;------------------------------------------------------------------
    51                              <1> ;   syscall_ncpus : get how many cpu threads are running
    52                              <1> ;
    53                              <1> ;   entry:
    54                              <1> ;   exit:
    55                              <1> ;       eax = N cpus
    56                              <1> 
    57                              <1> syscall_ncpus :
    58 000010C1 A1[040A0000]        <1>     mov  eax,[ncpus]
    59 000010C6 CF                  <1>     iret
    60                              <1> 
    61                              <1> ;------------------------------------------------------------------
    62                              <1> ;   syscall_new_thread : ask for another cpu to execute code in
    63                              <1> ;                        the current app
    64                              <1> ;
    65                              <1> ;   This implementation is quite a bit of a hack - apps can basically
    66                              <1> ;   commendere any specific non-boot cpu they want ...
    67                              <1> ;
    68                              <1> ;   entry:
    69                              <1> ;       edx = function start address in the app
    70                              <1> ;       ecx = address of the top of the app's new thread stack
    71                              <1> ;       ebx = app's new thread index
    72                              <1> ;   exit:
    73                              <1> ;       eax = 0 success, -1 failure
    74                              <1> 
    75                              <1> syscall_new_thread :
    76 000010C7 09DB                <1>     or   ebx,ebx
    77 000010C9 7434                <1>     jz   new_thread_fail        ; don't get to ask for cpu 0
    78                              <1> 
    79 000010CB 31C0                <1>     xor  eax,eax
    80 000010CD 81FB80000000        <1>     cmp  ebx,((gdt_end - gdt_tasks) / 8 / 2)    ; / sizeof(gdt) / 2 per task
    81 000010D3 732A                <1>     jae  new_thread_fail        ; we don't have enough gdt entries
    82                              <1> 
    83                              <1>     ; setup the tss
    84                              <1>     ; slightly squirly - get the tss address from the task selector
    85                              <1> 
    86 000010D5 89DF                <1>     mov  edi,ebx
    87 000010D7 C1E704              <1>     shl  edi,4                  ; 8 byte selectors in pairs
    88 000010DA 83C760              <1>     add  edi,tasksel_u00
    89 000010DD 8BB7[02000000]      <1>     mov  esi,[gdt+edi+2]        ; get the tss base address
    90 000010E3 81E6FFFFFF00        <1>     and  esi,0xffffff
    91 000010E9 8A87[07000000]      <1>     mov  al,[gdt+edi+7]
    92 000010EF C1E018              <1>     shl  eax,24
    93 000010F2 09C6                <1>     or   esi,eax
    94 000010F4 7409                <1>     jz   new_thread_fail        ; task is not yet initialized ...
    95                              <1> 
    96                              <1>     ; really should check the previous task link to see if this
    97                              <1>     ; cpu is busy ...
    98                              <1> 
    99 000010F6 894E38              <1>     mov  [esi+(tss_esp-tss)],ecx    ; set the app's stack
   100 000010F9 895620              <1>     mov  [esi+(tss_eip-tss)],edx    ; set the eip to the entry point
   101                              <1>     ; ********* set the eip LAST as this unleashes the associated cpu *********
   102                              <1> 
   103                              <1>     ; like to eventually ipi only the cpu we just configured for this thread,
   104                              <1>     ; but need to figure out how to ipi a single cpu beyond the 8th ...
   105                              <1>     ; for now we have to ipi them all at once: the ones in nb_idle with
   106                              <1>     ; a new tss will start
   107                              <1> 
   108                              <1>     ; and there is no fancy affinity scheduling yet, just let the app
   109                              <1>     ; ask for a specific cpu to do the work
   110                              <1> 
   111 000010FC 31C0                <1>     xor  eax,eax
   112 000010FE CF                  <1>     iret
   113                              <1> 
   114                              <1> new_thread_fail :
   115 000010FF 48                  <1>     dec  eax                    ; -1
   116 00001100 CF                  <1>     iret
   117                              <1> 
   118                              <1> ;------------------------------------------------------------------
   119                              <1> ;   syscall_sleep : wait for N timer interrupts
   120                              <1> ;
   121                              <1> ;   entry:
   122                              <1> ;       edx = N ticks
   123                              <1> ;   exit:
   124                              <1> 
   125                              <1> ;n_to_bits :
   126                              <1> ;    db  00h
   127                              <1> ;    db  01h
   128                              <1> ;    db  02h
   129                              <1> ;    db  04h
   130                              <1> ;    db  08h
   131                              <1> ;    db  10h
   132                              <1> ;    db  20h
   133                              <1> ;    db  40h
   134                              <1> ;    db  80h
   135                              <1> 
   136                              <1> syscall_sleep :
   137 00001101 A0[280A0000]        <1>     mov  al,[enabled_lapic]
   138 00001106 08C0                <1>     or   al,al
   139 00001108 7400                <1>     jz   sleep_loop
   140                              <1> 
   141                              <1> ; no need for any of this at the moment ...
   142                              <1> ;   mov  ecx,sleepers
   143                              <1> ;   xor  ebx,ebx
   144                              <1> ;   mov  eax,[0xfee00020]
   145                              <1> ;   shr  eax,24
   146                              <1> ;   or   eax,eax
   147                              <1> ;   jz   sleep_loop         ; the boot cpu services the timer int
   148                              <1> ;   mov  ebx,eax            ; so don't add it to the sleeper list
   149                              <1> ;   shr  ebx,3
   150                              <1> ;   and  eax,7h
   151                              <1> ;   mov  al,[n_to_bits+eax]
   152                              <1> 
   153                              <1> sleep_loop :
   154                              <1> ;   lock or [sleepers+ebx],al   ; announce we are sleeping
   155 0000110A FB                  <1>     sti
   156 0000110B F4                  <1>     hlt                     ; wait for an int to wake us up
   157 0000110C 4A                  <1>     dec  edx                ; decrement the tick count
   158 0000110D 75FB                <1>     jnz  sleep_loop
   159                              <1> 
   160                              <1>     ; ---- freeze on a fault: stops all timer related activity
   161                              <1>     ; ---- and hangs the boot cpu (also see ozirq.asm)
   162 0000110F 833D[80080000]00    <1>     cmp  dword [fault_count],0
   163 00001116 75F2                <1>     jnz  sleep_loop
   164                              <1> 
   165 00001118 83F0FF              <1>     xor  eax,-1
   166                              <1> ;   lock and [sleepers+ebx],al  ; renounce sleepiness
   167 0000111B CF                  <1>     iret
   168                              <1> 
   169                              <1> ;------------------------------------------------------------------
   170                              <1> ;   syscall_pause : wait for a resume
   171                              <1> 
   172                              <1> syscall_pause :
   173                              <1> 
   174                              <1> %ifdef HAVE_MWAIT
   175                              <1> 
   176                              <1>     ; two paths through pause, the first forces all cores to synchronize
   177                              <1>     ; with wait_addr (using a loop to test the contents of wait_addr),
   178                              <1>     ; the other simply uses a single instance of monitor/mwait.
   179                              <1>     ; apparently synchronizing on the first resume allows subsequent
   180                              <1>     ; mwaits to work correctly - if mwait is used alone without this "sync"
   181                              <1>     ; that mwait only rarely works (for like 1 core out of 47).
   182                              <1>     ; note that implementation wise pause/resume here only syncs once
   183                              <1>     ; the first time it is called by the first app (nothing resets wait_addr to zero),
   184                              <1>     ; but it is still unknown if more that one sync is needed.
   185                              <1> 
   186                              <1>     mov  edi,[wait_addr]
   187                              <1>     cmp  edi,edi
   188                              <1>     jnz  no_loop            ; first pause?
   189                              <1> 
   190                              <1>     ; sync all the cores together the first time through
   191                              <1>     ; after this mwait works reliably
   192                              <1> 
   193                              <1>     cli                     ; this would kill "pre-emptive multithreading"
   194                              <1>                             ; except that is is not implemented  :D
   195                              <1>                             ; only one app runs at a time here so no big deal
   196                              <1> false_alarm :
   197                              <1>     mov  eax,wait_addr
   198                              <1>     ;mfence                  ; workaround for certain Intel P6 family models
   199                              <1>     ;clflush [eax]           ; (see X86_BUG_CLFLUSH_MONITOR in linux kernel)
   200                              <1>     ;mfence
   201                              <1> 
   202                              <1>     xor  ebx,ebx
   203                              <1>     xor  ecx,ecx
   204                              <1>     xor  edx,edx
   205                              <1>     monitor
   206                              <1>     ;xor  ecx,ecx
   207                              <1>     mov  ecx,1              ; dont let interrupts break mwait (req: cpuid.5:ecx bit1)
   208                              <1>     mov  eax,(5<<4)         ; ask for C6
   209                              <1>     ;mov  eax,(1<<4)         ; ask for C2
   210                              <1>     ;xor  eax,eax            ; use for C1
   211                              <1>     mwait
   212                              <1> 
   213                              <1>     cmp  edi,[wait_addr]
   214                              <1>     jz   false_alarm
   215                              <1> 
   216                              <1>     iret
   217                              <1> 
   218                              <1> no_loop :
   219                              <1>     xor  ebx,ebx
   220                              <1>     xor  ecx,ecx
   221                              <1>     xor  edx,edx
   222                              <1>     monitor
   223                              <1>     ;xor  ecx,ecx
   224                              <1>     mov  ecx,1              ; dont let interrupts break mwait (req: cpuid.5:ecx bit1)
   225                              <1>     mov  eax,(5<<4)         ; ask for C6
   226                              <1>     ;mov  eax,(1<<4)         ; ask for C2
   227                              <1>     ;xor  eax,eax            ; use for C1
   228                              <1>     mwait
   229                              <1> 
   230                              <1>     iret
   231                              <1> 
   232                              <1> %else
   233 0000111C FB                  <1>     sti
   234 0000111D F4                  <1>     hlt                     ; wait for an int to wake us up
   235 0000111E CF                  <1>     iret
   236                              <1> 
   237                              <1> %endif
   238                              <1> 
   239                              <1> ;------------------------------------------------------------------
   240                              <1> ;   syscall_resume : unpause every core
   241                              <1> 
   242                              <1> syscall_resume :
   243                              <1> %ifdef HAVE_MWAIT
   244                              <1>     mov  eax,wait_addr
   245                              <1>     lock inc dword [eax]
   246                              <1> %else
   247 0000111F E833FAFFFF          <1>     call ipi_cpu
   248                              <1> %endif
   249 00001124 CF                  <1>     iret
   250                              <1> 
   251                              <1> ;------------------------------------------------------------------
   252                              <1> ;   syscall_ipi_all : kick every core out of hlt
   253                              <1> 
   254                              <1> syscall_ipi_all :
   255 00001125 E82DFAFFFF          <1>     call ipi_cpu
   256 0000112A CF                  <1>     iret
   257                              <1> 
   258                              <1> ;------------------------------------------------------------------
   259                              <1> ;   syscall_request_pmem_access : ask for access to a physical
   260                              <1> ;            memory address
   261                              <1> ;
   262                              <1> ;   entry:
   263                              <1> ;       edx = phys memory address
   264                              <1> ;
   265                              <1> ;   exit:
   266                              <1> ;       (need to return a logical address in eax)  For now just
   267                              <1> ;       direct maps the physical address into logical addr space.
   268                              <1> 
   269                              <1> syscall_request_pmem_access :
   270 0000112B E801000000          <1>     call map_pmem
   271 00001130 CF                  <1>     iret
   272                              <1> 
   273                              <1> ;------------------------------------------------------------------
   274                              <1> ;   map_pmem - add entries to the current page directory/table
   275                              <1> ;              to direct map the requested physical memory address
   276                              <1> ;              (logical identical to physical for now)
   277                              <1> ;
   278                              <1> ;   entry:
   279                              <1> ;       edx = phys memory address
   280                              <1> ;
   281                              <1> ;   returns:
   282                              <1> ;       (need to return a logical address in eax)  For now just
   283                              <1> ;       direct maps the physical address into logical addr space.
   284                              <1> ;       eax =  0 success
   285                              <1> ;       eax = -1 fail
   286                              <1> 
   287                              <1> map_pmem :
   288 00001131 53                  <1>     push ebx
   289 00001132 57                  <1>     push edi
   290                              <1> 
   291 00001133 0F013A              <1>     invlpg [edx]                ; necessary on real Intel hw
   292 00001136 52                  <1>     push edx
   293 00001137 0F20DB              <1>     mov  ebx,cr3
   294 0000113A 81E300F0FFFF        <1>     and  ebx,0xfffff000
   295 00001140 89D7                <1>     mov  edi,edx
   296 00001142 81E70000C0FF        <1>     and  edi,0xffc00000
   297 00001148 C1EF14              <1>     shr  edi,(22 - 2)           ; calc page directory index
   298 0000114B 81E200F03F00        <1>     and  edx,0x003ff000
   299 00001151 C1EA0A              <1>     shr  edx,(12 - 2)           ; calc page table index
   300                              <1> 
   301 00001154 8B043B              <1>     mov  eax,[ebx+edi]
   302 00001157 09C0                <1>     or   eax,eax                ; is there a page table here?
   303 00001159 7513                <1>     jnz  map_pmem_have_pgtbl
   304 0000115B E8FEF3FFFF          <1>     call mem_alloc_kernel_page
   305 00001160 09C0                <1>     or   eax,eax
   306 00001162 7427                <1>     jz   map_pmem_fail
   307 00001164 C1E00C              <1>     shl  eax,12                 ; convert pgno to pgtbl entry
   308 00001167 89043B              <1>     mov  [ebx+edi],eax          ; update page table
   309 0000116A 0F013C3B            <1>     invlpg [ebx+edi]
   310                              <1> 
   311                              <1> map_pmem_have_pgtbl :
   312                              <1>     ; for now, no security check, just direct map the address
   313                              <1>     ; and mark the pages and the page table r/w by all
   314                              <1>     ;or   dword [ebx+edi],7      ; user, r/w, present
   315                              <1>     ; assume for now that all map_pmem calls are for real devices
   316 0000116E 830C3B1F            <1>     or   dword [ebx+edi],1fh     ; cache disable, write through, user, r/w, present
   317                              <1> 
   318 00001172 8B1C3B              <1>     mov  ebx,[ebx+edi]
   319 00001175 81E300F0FFFF        <1>     and  ebx,0xfffff000
   320 0000117B 58                  <1>     pop  eax                    ; recover requested phys mem addr
   321                              <1>     ; FIXME yup, big security hole if called by ring 0! And it is ...
   322                              <1>     ;or   eax,7                  ; user, r/w, present
   323 0000117C 83C81F              <1>     or   eax,1fh                ; cache disable, write through, user, r/w, present
   324 0000117F 890413              <1>     mov  [ebx+edx],eax          ; update page directory
   325 00001182 0F013C13            <1>     invlpg [ebx+edx]
   326 00001186 31C0                <1>     xor  eax,eax                ; 0
   327                              <1> map_pmem_exit :
   328 00001188 5F                  <1>     pop  edi
   329 00001189 5B                  <1>     pop  ebx
   330 0000118A C3                  <1>     ret
   331                              <1> 
   332                              <1> map_pmem_fail :
   333 0000118B 48                  <1>     dec  eax                    ; -1
   334 0000118C EBFA                <1>     jmp  map_pmem_exit
   335                              <1> 
  1007                                  
  1008                                  
  1009 0000118E 00<rept>                align 64, db 0  ; 64 seems to allow us to guess total_size correctly
  1010                                  kernel_text_size equ ($-textstart)
  1011                                  
  1012                                  ; ---------------------------------------------------------------------------
  1013                                  section .data
  1014                                  datastart :
  1015                                  
  1016                                  ; -------- descriptors --------------
  1017                                  ; Intel SW dev manual 3a, 3.4.5, pg 103
  1018                                  ;
  1019                                  ; In my opinion, macros for descriptor entries
  1020                                  ; don't make the code any more readable.
  1021                                  
  1022                                  descriptor_size equ 8
  1023                                  
  1024                                  gdt :
  1025                                  nullsel equ $-gdt           ; nullsel = 0h
  1026 00000000 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
  1027                                  
  1028                                  codesel equ $-gdt           ; codesel = 8h  4Gb flat over all logical mem
  1029 00000008 FFFF                        dw 0xffff               ; limit 0-15
  1030 0000000A 0000                        dw 0x0000               ; base  0-15
  1031 0000000C 00                          db 0x00                 ; base 16-23
  1032 0000000D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  1033 0000000E CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  1034 0000000F 00                          db 0x00                 ; base 24-31
  1035                                  
  1036                                  datasel equ $-gdt           ; datasel = 10h  4Gb flat over all logical mem
  1037 00000010 FFFF                        dw 0xffff               ; limit 0-15
  1038 00000012 0000                        dw 0x0000               ; base  0-15
  1039 00000014 00                          db 0x00                 ; base 16-23
  1040 00000015 92                          db 0x92                 ; present, dpl=0, data r/w
  1041 00000016 CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  1042 00000017 00                          db 0x00                 ; base 24-31
  1043                                  
  1044                                  kstkbalo equ (kstack_loc & 0xffff)
  1045                                  kstkbami equ ((kstack_loc >> 16) & 0xff)
  1046                                  kstkbahi equ ((kstack_loc >> 24) & 0xff)
  1047                                  kstkszlo equ ((kstack_size-1) & 0xffff)
  1048                                  kstkszhi equ ((kstack_size-1) >> 16 & 0xf)
  1049                                  
  1050                                  stacksel equ $-gdt          ; stacksel = 18h  small limited stack
  1051 00000018 FF7F                        dw kstkszlo             ; limit 0-15
  1052 0000001A 0010                        dw kstkbalo             ; base  0-15
  1053 0000001C 01                          db kstkbami             ; base 16-23
  1054 0000001D 92                          db 0x92                 ; present, dpl=0, data, r/w
  1055 0000001E 40                          db 0x40 + kstkszhi      ; byte granular, 32bit/8bit, limit 16-19
  1056 0000001F 00                          db kstkbahi             ; base 24-31
  1057                                  
  1058                                  videosel equ $-gdt          ; videosel = 20h
  1059 00000020 9F0F                        dw 3999                 ; limit 80*25*2-1
  1060 00000022 0080                        dw 0x8000               ; base 0xb8000
  1061 00000024 0B                          db 0x0b
  1062 00000025 92                          db 0x92                 ; present, dpl=0, data, r/w
  1063 00000026 40                          db 0x40                 ; byte granular, 32bit/8bit
  1064 00000027 00                          db 0
  1065                                  
  1066                                      ; useful for BIOS calls someday?
  1067                                  
  1068                                  rmcssel equ $-gdt           ; real mode CS selector = 28h
  1069 00000028 FFFF                        dw 0xffff               ; limit 0-15
  1070 0000002A 0000                        dw 0x0000               ; base  0-15
  1071 0000002C 00                          db 0x00                 ; base 16-23
  1072 0000002D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  1073 0000002E 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  1074 0000002F 00                          db 0x00                 ; base 24-31
  1075                                  
  1076                                  rmdssel equ $-gdt           ; real mode DS selector = 30h
  1077 00000030 FFFF                        dw 0xffff               ; limit 0-15
  1078 00000032 0000                        dw 0x0000               ; base  0-15
  1079 00000034 00                          db 0x00                 ; base 16-23
  1080 00000035 92                          db 0x92                 ; present, dpl=0, data r/w
  1081 00000036 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  1082 00000037 00                          db 0x00                 ; base 24-31
  1083                                  
  1084                                      ; ring 3 selectors in the gdt - no need for an ldt
  1085                                  
  1086                                      ; FIXME the apps don't need access to all memory right?
  1087                                      ; or maybe page level protections are enough!
  1088                                  
  1089                                  codesel3 equ $-gdt          ; codesel3 = 38h
  1090 00000038 FFFF                        dw 0xffff               ; limit 0-15
  1091 0000003A 0000                        dw 0x0000               ; base  0-15
  1092 0000003C 00                          db 0x00                 ; base 16-23
  1093 0000003D FA                          db 0xfa                 ; present, dpl=3, code e/r
  1094 0000003E CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  1095 0000003F 00                          db 0x00                 ; base 24-31
  1096                                  
  1097                                  datasel3 equ $-gdt          ; datasel = 40h  4Gb flat over all logical mem
  1098 00000040 FFFF                        dw 0xffff               ; limit 0-15
  1099 00000042 0000                        dw 0x0000               ; base  0-15
  1100 00000044 00                          db 0x00                 ; base 16-23
  1101 00000045 F2                          db 0xf2                 ; present, dpl=3, data r/w
  1102 00000046 CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  1103 00000047 00                          db 0x00                 ; base 24-31
  1104                                  
  1105                                  tasksel_f08 equ $-gdt       ; the double fault task selector
  1106 00000048 6700                        dw (tss_len-1)          ; tss length
  1107 0000004A [5808]                      dw tss_f08              ; tss physical address
  1108 0000004C 00                          db 0
  1109 0000004D 89                          db 0x89                 ; present, dpl=0, tss32
  1110 0000004E 40                          db 0x40                 ; byte granular, 32bit/8bit
  1111 0000004F 00                          db 0
  1112                                  
  1113                                  tasksel_f10 equ $-gdt       ; the invalid tss task selector
  1114 00000050 6700                        dw (tss_len-1)          ; tss length
  1115 00000052 [C008]                      dw tss_f10              ; tss physical address
  1116 00000054 00                          db 0
  1117 00000055 89                          db 0x89                 ; present, dpl=0, tss32
  1118 00000056 40                          db 0x40                 ; byte granular, 32bit/8bit
  1119 00000057 00                          db 0
  1120                                  
  1121                                  ; there is one kernel thread tss (ring 0) and one user thread tss (ring 3)
  1122                                  ; per cpu.  memory for tss structs for the non-boot cpus are allocated as
  1123                                  ; each non-boot cpu comes online (see create_tss_pair).
  1124                                  ; tasksel_uXX tsses are initialized in new_thread.
  1125                                  
  1126                                  gdt_tasks :
  1127                                  tasksel_k00 equ $-gdt
  1128 00000058 6700[2809]00894000                              dw (tss_len-1), tss0, 0x8900, 0x40
  1129                                  tasksel_u00 equ $-gdt
  1130 00000060 6700[9009]00894000                              dw (tss_len-1), tss1, 0x8900, 0x40
  1131 00000068 6700000000894000-         times 2*(max_ncpus-1) dw (tss_len-1),    0, 0x8900, 0x40
  1131 00000068 <rept>             
  1132                                  
  1133                                  max_threads equ ($-gdt_tasks)/descriptor_size/2
  1134                                  
  1135                                  gdt_end :
  1136                                  
  1137                                  ; ---------------------
  1138                                  ; the tss that handles double fault exceptions
  1139                                  
  1140                                  tss_f08 :                   ; intel sw 3a 7.6  pg 287 of 756
  1141 00000858 00000000                    dw 0,0                  ; previous task link
  1142 0000085C 005F0000                    dd tss_f08_stk-0x100    ; esp0
  1143 00000860 10000000                    dw datasel,0            ; ss0
  1144 00000864 00000000                    dd 0                    ; esp1
  1145 00000868 00000000                    dw 0,0                  ; ss1
  1146 0000086C 00000000                    dd 0                    ; esp2
  1147 00000870 00000000                    dw 0,0                  ; ss2
  1148                                  tss_f08_cr3 :
  1149 00000874 00000000                    dd 0                    ; cr3
  1150 00000878 [440D0000]                  dd int_handler_tg_dblflt ; eip
  1151 0000087C 00000000                    dd 0                    ; eflags
  1152 00000880 00000000                    dd 0                    ; eax
  1153 00000884 00000000                    dd 0                    ; ecx
  1154 00000888 00000000                    dd 0                    ; edx
  1155 0000088C 00000000                    dd 0                    ; ebx
  1156 00000890 00600000                    dd tss_f08_stk          ; esp
  1157 00000894 00000000                    dd 0                    ; ebp
  1158 00000898 00000000                    dd 0                    ; esi
  1159 0000089C 00000000                    dd 0                    ; edi
  1160 000008A0 10000000                    dw datasel,0            ; es
  1161 000008A4 08000000                    dw codesel,0            ; cs
  1162 000008A8 10000000                    dw datasel,0            ; ss
  1163 000008AC 10000000                    dw datasel,0            ; ds
  1164 000008B0 00000000                    dw 0,0                  ; fs
  1165 000008B4 20000000                    dw videosel,0           ; gs
  1166 000008B8 00000000                    dw 0,0                  ; ldt
  1167 000008BC 0000                        dw 0                    ; trap
  1168 000008BE 0000                        dw 0                    ; iomap
  1169                                  
  1170                                  ; ---------------------
  1171                                  ; the tss that handles invalid tss exceptions
  1172                                  
  1173                                  tss_f10 :                   ; intel sw 3a 7.6  pg 287 of 756
  1174 000008C0 00000000                    dw 0,0                  ; previous task link
  1175 000008C4 006F0000                    dd tss_f10_stk-0x100    ; esp0
  1176 000008C8 10000000                    dw datasel,0            ; ss0
  1177 000008CC 00000000                    dd 0                    ; esp1
  1178 000008D0 00000000                    dw 0,0                  ; ss1
  1179 000008D4 00000000                    dd 0                    ; esp2
  1180 000008D8 00000000                    dw 0,0                  ; ss2
  1181                                  tss_f10_cr3 :
  1182 000008DC 00000000                    dd 0                    ; cr3
  1183 000008E0 [600D0000]                  dd int_handler_tg_invtss ; eip
  1184 000008E4 00000000                    dd 0                    ; eflags
  1185 000008E8 00000000                    dd 0                    ; eax
  1186 000008EC 00000000                    dd 0                    ; ecx
  1187 000008F0 00000000                    dd 0                    ; edx
  1188 000008F4 00000000                    dd 0                    ; ebx
  1189 000008F8 00700000                    dd tss_f10_stk          ; esp
  1190 000008FC 00000000                    dd 0                    ; ebp
  1191 00000900 00000000                    dd 0                    ; esi
  1192 00000904 00000000                    dd 0                    ; edi
  1193 00000908 10000000                    dw datasel,0            ; es
  1194 0000090C 08000000                    dw codesel,0            ; cs
  1195 00000910 10000000                    dw datasel,0            ; ss
  1196 00000914 10000000                    dw datasel,0            ; ds
  1197 00000918 00000000                    dw 0,0                  ; fs
  1198 0000091C 20000000                    dw videosel,0           ; gs
  1199 00000920 00000000                    dw 0,0                  ; ldt
  1200 00000924 0000                        dw 0                    ; trap
  1201 00000926 0000                        dw 0                    ; iomap
  1202                                  
  1203                                  ; ---------------------
  1204                                  ; tss0 and tss1 are cpu0's pair
  1205                                  
  1206                                  tss :
  1207                                  tss0 :                      ; intel swdev3a 7.6  pg 287 of 756
  1208 00000928 00000000                    dw 0,0                  ; previous task link
  1209                                  tss_esp0 :
  1210 0000092C 00000000                    dd 0                    ; esp0
  1211                                  tss_ss0 :
  1212 00000930 00000000                    dw 0,0                  ; ss0
  1213 00000934 00000000                    dd 0                    ; esp1
  1214 00000938 00000000                    dw 0,0                  ; ss1
  1215 0000093C 00000000                    dd 0                    ; esp2
  1216 00000940 00000000                    dw 0,0                  ; ss2
  1217                                  tss_cr3 :
  1218                                  tss0_cr3 :
  1219 00000944 00000000                    dd 0                    ; cr3
  1220                                  tss_eip :
  1221 00000948 00000000                    dd 0                    ; eip
  1222 0000094C 00000000                    dd 0                    ; eflags
  1223                                  tss_eax :
  1224 00000950 00000000                    dd 0                    ; eax
  1225 00000954 00000000                    dd 0                    ; ecx
  1226 00000958 00000000                    dd 0                    ; edx
  1227 0000095C 00000000                    dd 0                    ; ebx
  1228                                  tss_esp :
  1229 00000960 00000000                    dd 0                    ; esp
  1230 00000964 00000000                    dd 0                    ; ebp
  1231 00000968 00000000                    dd 0                    ; esi
  1232 0000096C 00000000                    dd 0                    ; edi
  1233                                  tss_es :
  1234 00000970 00000000                    dw 0,0                  ; es
  1235                                  tss_cs :
  1236 00000974 00000000                    dw 0,0                  ; cs
  1237                                  tss_ss :
  1238 00000978 00000000                    dw 0,0                  ; ss
  1239                                  tss_ds :
  1240 0000097C 00000000                    dw 0,0                  ; ds
  1241                                  tss_fs :
  1242 00000980 00000000                    dw 0,0                  ; fs
  1243                                  tss_gs :
  1244 00000984 20000000                    dw videosel,0           ; gs
  1245 00000988 00000000                    dw 0,0                  ; ldt
  1246 0000098C 0000                        dw 0                    ; trap
  1247 0000098E 0000                        dw 0                    ; iomap
  1248                                  tss_end :
  1249                                  
  1250                                  tss_len equ tss_end-tss
  1251                                  
  1252                                  ; user tss
  1253                                  
  1254                                  tss1 :                      ; intel sw 3a 7.6  pg 287 of 756
  1255 00000990 00000000                    dw 0,0                  ; previous task link
  1256                                  tss1_esp0 :
  1257 00000994 00000000                    dd 0                    ; esp0  (int and irq support)
  1258 00000998 18000000                    dw stacksel,0           ; ss0   (filled in when running init apps)
  1259 0000099C 00000000                    dd 0                    ; esp1
  1260 000009A0 00000000                    dw 0,0                  ; ss1
  1261 000009A4 00000000                    dd 0                    ; esp2
  1262 000009A8 00000000                    dw 0,0                  ; ss2
  1263                                  tss1_cr3 :
  1264 000009AC 00000000                    dd 0                    ; cr3
  1265                                  tss1_eip :
  1266 000009B0 00000000                    dd 0                    ; eip
  1267 000009B4 00000000                    dd 0                    ; eflags
  1268 000009B8 00000000                    dd 0                    ; eax
  1269 000009BC 00000000                    dd 0                    ; ecx
  1270 000009C0 00000000                    dd 0                    ; edx
  1271 000009C4 00000000                    dd 0                    ; ebx
  1272                                  tss1_esp :
  1273 000009C8 00000000                    dd 0                    ; esp
  1274 000009CC 00000000                    dd 0                    ; ebp
  1275 000009D0 00000000                    dd 0                    ; esi
  1276 000009D4 00000000                    dd 0                    ; edi
  1277 000009D8 43000000                    dw datasel3+3,0         ; es
  1278 000009DC 3B000000                    dw codesel3+3,0         ; cs
  1279 000009E0 43000000                    dw datasel3+3,0         ; ss
  1280 000009E4 43000000                    dw datasel3+3,0         ; ds
  1281 000009E8 43000000                    dw datasel3+3,0         ; fs
  1282 000009EC 43000000                    dw datasel3+3,0         ; gs
  1283 000009F0 00000000                    dw 0,0                  ; ldt
  1284 000009F4 0000                        dw 0                    ; trap
  1285 000009F6 0000                        dw 0                    ; iomap
  1286                                  
  1287                                  ; ---------------------
  1288                                  
  1289                                  gdtr :
  1290 000009F8 5708                        dw gdt_end - gdt - 1    ; gdt length
  1291 000009FA [00000000]                  dd gdt                  ; gdt physical address
  1292                                  
  1293                                  idtr :
  1294                                      ; irq_setup_table_size == the number of gates in the idt
  1295 000009FE FF07                        dw irq_setup_table_size * 8 - 1     ; idt limit (should be 2k)
  1296                                  idtr_addr :
  1297 00000A00 00000000                    dd 0                                ; address of the idt
  1298                                  
  1299 00000A04 00000000                ncpus           dd 0        ; number of running cpus
  1300                                  
  1301 00000A08 00000000                next_free_page  dd 0        ; initialized after page tables are setup
  1302                                  
  1303 00000A0C 00<rept>                sleepers        times max_ncpus/8 db 0  ; one bit per cpu (except cpu0)
  1304                                  
  1305 00000A1C 00000000                pgdirp          dd 0
  1306 00000A20 00000000                pgtb0p          dd 0
  1307 00000A24 00000000                pgtb1p          dd 0
  1308                                  
  1309 00000A28 00                      enabled_lapic   db 0        ; set to 1 if an lapic is present and in use
  1310                                  
  1311                                  ; isolate a cache line for monitor/mwait
  1312 00000A29 00<rept>                align 64, db 0
  1313 00000A40 00<rept>                wait_addr       times 64 db 0
  1314                                  
  1315 00000A80 AA55                    dbgwall         db 0xaa,0x55
  1316                                  
  1317 00000A82 00<rept>                align 64, db 0  ; 64 seems to allow us to guess total_size correctly
  1318                                  kernel_data_size equ ($-datastart)
  1319                                  
  1320                                  ; ---------------------
  1321                                  ; Need to align to a physical page boundary here so that appended init apps
  1322                                  ; are always page aligned.  The problem is our text section starts 1k below
  1323                                  ; a page boundary (0x7c00), and so an 'align 4096' doesn't match up with
  1324                                  ; physical memory.
  1325                                  
  1326                                  section .fill
  1327                                  
  1328                                  fill :
  1329 00000000 00<rept>                    times (4096 - ((0x7c00 + total_size) % 4096)) db 0
  1330                                  
  1331                                  kend :
  1332                                  
