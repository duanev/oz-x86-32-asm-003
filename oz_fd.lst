     1                                  ; OZ - A more utopian OS   x86-32 startup
     2                                  ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
     3                                  ;
     4                                  ; Copyright (C) 2015  Duane Voth
     5                                  ;
     6                                  ;   This program is free software: you can redistribute it and/or modify
     7                                  ;   it under the terms of the GNU Affero General Public License as
     8                                  ;   published by the Free Software Foundation, either version 3 of the
     9                                  ;   License, or (at your option) any later version.
    10                                  ;
    11                                  ;   This program is distributed in the hope that it will be useful,
    12                                  ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
    13                                  ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    14                                  ;   GNU Affero General Public License for more details.
    15                                  ;
    16                                  ;   You should have received a copy of the GNU Affero General Public License
    17                                  ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
    18                                  ;
    19                                  ;
    20                                  ;
    21                                  ; usage:
    22                                  ;	$ qemu-system-i386 -boot a -fda oz_fd -monitor stdio
    23                                  ;
    24                                  ; requires: nasm-2.07  or later from: http://www.nasm.us
    25                                  ;
    26                                  ; credits:
    27                                  ;       many thanks to the folks at wiki.osdev.org who archive great info.
    28                                  ;
    29                                  ; contributors:
    30                                  ;        djv - Duane Voth
    31                                  ;
    32                                  ; history:
    33                                  ; 2007/03/03 - 0.00.01 - djv - begin with various web examples
    34                                  ;                      http://linuxgazette.net/issue82/misc/raghu/code.asm.txt
    35                                  ;                      http://www.osdever.net/tutorials/brunmar/simple_asm.txt
    36                                  ; 2007/03/04 - 0.00.02 - djv - add timer interrupt support with stray int dbg
    37                                  ; 2007/03/05 - 0.00.03 - djv - remove stray int dbg, add mbr data struc back
    38                                  ; 2007/03/11 - 0.00.04 - djv - debug USB boot problem
    39                                  ; 2007/03/28 - 0.01.00 - djv - add a real-mode stage2 loader in the mbr to
    40                                  ;                              load the sectors past the mbr on the boot
    41                                  ;                              device into the memory behind the mbr.  so even
    42                                  ;                              tho the read from the device happens in two
    43                                  ;                              parts, memory contains a linear image of the
    44                                  ;                              first few sectors of the boot device.
    45                                  ; 2009/02/01 - 0.02.00 - djv - begin to define application and dynamic library
    46                                  ;                              binary formats with headers detailing size and
    47                                  ;                              entry points.
    48                                  ; 2009/08/01 - 0.03.00 - djv - create the OZ app execution container using
    49                                  ;                              TSSes, paging, and rings 0 and 3.  begin to
    50                                  ;                              play with system calls.
    51                                  ; 2015/10/26 - 0.03.01 - djv - cleanup, add smp usermode tss structs, sleep,
    52                                  ;                              wakeup, and ipi for user thread creation.
    53                                  
    54                                  %ifdef USB
    55                                  [map symbols oz_usb.map]
    56                                  %else
    57                                  [map symbols oz_fd.map]
    58                                  %endif
    59                                  
    60                                  ; -------- stage 1 ---------------------------------------------------------
    61                                  ; A classic x86 Master Boot Record
    62                                  
    63                                  section .text start=0x7c00  ; PC BIOS boot loader entry point
    64                                  textstart :
    65                                  
    66                                  bios_entry :
    67 00000000 FA                          cli
    68 00000001 EA[2400]0000                jmp 0:load_stage2       ; load cs, skip over mbr data struct
    69                                  
    70                                  times 6-($-$$)  db 0
    71 00000006 6F7A                    oemid db "oz"
    72                                  
    73 00000008 00<rept>                times 11-($-$$)  db 0
    74                                  
    75                                  ; compute the size of the kernel image in 512 byte sectors
    76                                  total_size equ (kernel_text_size + kernel_data_size)
    77                                  kisectors  equ (total_size)/512 + (APP_SIZE + 512)/512
    78                                  ; compute the end of the kernel image (with apps attached)
    79                                  kilast equ 0x7c00 + kisectors * 512
    80                                  
    81                                  ; MS MBR  (http://support.microsoft.com/kb/140418)
    82                                  %ifdef FLOPPY
    83 0000000B 0002                        dw 512                  ; Bytes per sector
    84 0000000D 01                          db 1                    ; Sectors per cluster
    85 0000000E 3B00                        dw kisectors            ; Number of reserved sectors
    86 00000010 02                          db 2                    ; Number of FATs
    87 00000011 E000                        dw 0x00e0               ; Number of dirs in root
    88 00000013 400B                        dw 0x0b40               ; Number of sectors in volume
    89 00000015 F0                          db 0xf0                 ; Media descriptor
    90 00000016 0900                        dw 9                    ; Number of sectors per FAT
    91 00000018 1200                        dw 18                   ; Number of sectors per track
    92 0000001A 0200                        dw 2                    ; Number of heads
    93 0000001C 00000000                    dd 0                    ; Number of hidden sectors
    94 00000020 00000000                    dd 0                    ; Large Sectors
    95                                  %endif
    96                                  
    97                                  %ifdef USB
    98                                      dw 0                    ; Bytes per sector
    99                                      db 0                    ; Sectors per cluster
   100                                      dw kisectors            ; Number of reserved sectors
   101                                      db 0                    ; Number of FATs
   102                                      dw 0                    ; Number of dirs in root
   103                                      dw 0                    ; Number of sectors in volume
   104                                      db 0                    ; Media descriptor
   105                                      dw 0                    ; Number of sectors per FAT
   106                                      dw 0                    ; Number of sectors per track
   107                                      dw 0                    ; Number of heads
   108                                      dd 0                    ; Number of hidden sectors
   109                                      dd 0                    ; Large Sectors
   110                                  %endif
   111                                  
   112                                  ; -------- stage 2 loader ------------
   113                                  bits 16
   114                                  alignb 2
   115                                  
   116                                  load_stage2 :
   117 00000024 B80030                      mov  ax,kstack_loc+kstack_size
   118 00000027 89C4                        mov  sp,ax
   119 00000029 31C0                        xor  ax,ax
   120 0000002B 8ED0                        mov  ss,ax
   121 0000002D 8EC0                        mov  es,ax
   122 0000002F 8ED8                        mov  ds,ax
   123 00000031 8EE0                        mov  fs,ax
   124 00000033 8EE8                        mov  gs,ax
   125 00000035 FC                          cld
   126                                  
   127                                      ; debug - pattern the stack so we can see what gets used
   128 00000036 66B811111111                mov  eax,0x11111111
   129 0000003C BF0010                      mov  di,kstack_loc
   130 0000003F B90008                      mov  cx,kstack_size/4
   131 00000042 F366AB                      rep stosd
   132                                  
   133 00000045 52                          push dx                 ; save BIOS drive number
   134                                  
   135 00000046 B80006                      mov  ax,0x0600          ; ah=06h : scroll window up, if al = 0 clrscr
   136 00000049 B90000                      mov  cx,0x0000          ; clear window from 0,0 
   137 0000004C BA4F17                      mov  dx,0x174f          ; to 23,79
   138 0000004F B70F                        mov  bh,0xf             ; fill with hi white
   139 00000051 CD10                        int  0x10               ; clear screen for direct writes to video memory
   140                                  
   141 00000053 BE[C600]                    mov  si,bootmsg
   142 00000056 31DB                        xor  bx,bx
   143 00000058 E85700                      call puts_vga_rm
   144                                                              ; puts_vga_rm leaves gs pointing at video mem
   145 0000005B 65C60601000E                mov  byte [gs:1],0xE    ; turn the first two chars yellow
   146 00000061 65C60603000E                mov  byte [gs:3],0xE
   147                                  
   148                                      ;F - white              
   149                                      ;E - yellow             
   150                                      ;D - magenta            
   151                                      ;C - red                
   152                                      ;B - cyan               
   153                                      ;A - green              
   154                                      ;9 - blue               
   155                                      ;8 - dark grey          
   156                                  
   157 00000067 A1[0002]                    mov  ax,[stage2]        ; check the signature byte
   158 0000006A 0306[0202]                  add  ax,[stage2+2]      ; stage2 might already have been loaded
   159 0000006E 3DA17A                      cmp  ax,0x7a6f+0x32
   160 00000071 741D                        jz   stage2_present
   161                                  
   162                                      ; -------- stage2 boot loader --------
   163                                  
   164                                      ; Assume that the kernel is smaller than whatever space
   165                                      ; is provided prior to file system data structures on the
   166                                      ; boot device, and that it can immediately follow the MBR.
   167                                  
   168 00000073 B402                        mov  ah,02h
   169 00000075 B03B                        mov  al,kisectors       ; number of sectors to load
   170 00000077 BB[0002]                    mov  bx,stage2
   171 0000007A B90200                      mov  cx,2
   172 0000007D 5A                          pop  dx                 ; recover BIOS drive number
   173 0000007E 0E                          push cs
   174 0000007F 07                          pop  es
   175 00000080 CD13                        int  13h
   176 00000082 7211                        jc   ioerr
   177                                  
   178                                      ; ---- make sure second stage actually got loaded
   179                                  
   180 00000084 A1[0002]                    mov  ax,[stage2]        ; check the signature byte
   181 00000087 0306[0202]                  add  ax,[stage2+2]
   182 0000008B 3DA17A                      cmp  ax,0x7a6f+0x32
   183 0000008E 750A                        jnz  s2err
   184                                  stage2_present :
   185 00000090 EA[0902]0000                jmp  0:start_stage2     ; use an absolute jump so stage 1
   186                                                              ; can be position independent
   187                                  
   188                                  ioerr :                     ; ah has status...
   189 00000095 BE[F600]                    mov  si,ioerrmsg
   190 00000098 EB03                        jmp  print_err
   191                                  
   192                                  s2err :
   193 0000009A BE[E000]                    mov  si,s2errmsg
   194                                  print_err :
   195 0000009D BBA000                      mov  bx,160
   196 000000A0 E80F00                      call puts_vga_rm
   197 000000A3 65C60601000C                mov  byte [gs:1],0xC    ; turn the first two vga chars red
   198 000000A9 65C60603000C                mov  byte [gs:3],0xC
   199                                  
   200                                  hang :
   201 000000AF F4                          hlt
   202 000000B0 EBFD                        jmp  hang
   203                                  
   204                                  ; ----------------------------
   205                                  ;   puts_vga_rm - write a null delimited string to the VGA controller
   206                                  ;                 in real mode
   207                                  ;
   208                                  ;    enter:
   209                                  ;            esi - address of string
   210                                  ;            ebx - screen location (2 bytes per char, 160 bytes per line)
   211                                  ;    exit:
   212                                  ;            eax - destroyed
   213                                  ;             gs - set to video memory selector
   214                                  
   215                                  puts_vga_rm :
   216 000000B2 B800B8                      mov  ax,0xb800      ; point gs at video memory
   217 000000B5 8EE8                        mov  gs,ax          
   218                                  puts_vga_rm_loop :
   219 000000B7 AC                          lodsb
   220 000000B8 3C00                        cmp  al,0
   221 000000BA 7409                        jz   puts_vga_rm_done
   222 000000BC 658807                      mov  [gs:bx],al
   223 000000BF 6683C302                    add  ebx,2
   224 000000C3 EBF2                        jmp  puts_vga_rm_loop
   225                                  puts_vga_rm_done :
   226 000000C5 C3                          ret
   227                                  
   228 000000C6 4F5A2076302E30332E-     bootmsg     db      "OZ v0.03.01 - 2015/10/26 ",0
   229 000000CF 3031202D2032303135-
   230 000000D8 2F31302F32362000   
   231 000000E0 73746167652032206C-     s2errmsg    db      "stage 2 load failure ",0
   232 000000E9 6F6164206661696C75-
   233 000000F2 72652000           
   234 000000F6 692F6F206572726F72-     ioerrmsg    db      "i/o error loading stage 2 ",0
   235 000000FF 206C6F6164696E6720-
   236 00000108 737461676520322000 
   237                                  
   238 00000111 00<rept>                times 446-($-$$) db 0       ; fill with zeros up to partition table
   239                                  
   240                                  ; If the kernel is loaded from a disk (including usb) the MBR
   241                                  ; must include a partition table based on the device geometry.
   242                                  ; This gets fed into oz.asm here via usbptbl.inc
   243                                  %ifdef USB
   244                                  %include "usbptbl.inc"
   245                                  %else
   246                                      ; If the kernel is placed in memory by some other means
   247                                      ; (PXE, pxelinux, etc.) the partition table is irrelevant
   248                                      ; but the space is still required.  Make the default ptbl
   249                                      ; match a 1.44MB floppy.
   250 000001BE 800101000601124F            db 0x80,0x01,0x01,0x00,0x06,0x01,0x12,0x4f
   251 000001C6 120000002E0B0000            db 0x12,0x00,0x00,0x00,0x2e,0x0b,0x00,0x00
   252 000001CE 000000000000000000-         db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   253 000001D7 00000000000000     
   254 000001DE 000000000000000000-         db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   255 000001E7 00000000000000     
   256 000001EE 000000000000000000-         db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   257 000001F7 00000000000000     
   258                                  %endif
   259                                  
   260                                  %ifdef NEWUSB
   261                                  new usb?  gpt correct?
   262                                  0000 01B0: 00 00 00 00 00 2C 44 63  E0 36 03 00 00 00 80 20  .....,Dc .6.....
   263                                  0000 01C0: 21 00 83 9D 11 4C 00 08  00 00 00 C0 12 00 00 9D  !....L.. ........
   264                                  0000 01D0: 12 4C 83 57 25 F2 00 C8  12 00 00 A0 28 00 00 00  .L.W%... ....(...
   265                                  0000 01E0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ........ ........
   266                                  0000 01F0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 AA  ........ ......U.
   267                                  %endif
   268                                  
   269                                  
   270                                  times 510-($-$$) db 0       ; fill with zeros up to MBR signature
   271                                  
   272 000001FE 55AA                                dw 0x0aa55      ; write aa55 in bytes 511,512 to indicate
   273                                                              ; that it is a boot sector. 
   274                                  
   275                                  ; end of MBR
   276                                  ;
   277                                  ; -------- stage 2 ---------------------------------------------------------
   278                                  ;
   279                                  ; If a boot loader only loads 512 bytes in the first pass, the following
   280                                  ; code won't appear in memory until the code above has completed.  Other
   281                                  ; loaders however can load the entire OZ kernel image into memory in one
   282                                  ; shot. (pxe)
   283                                  
   284                                  bits 16
   285                                  
   286                                  stage2 :
   287 00000200 6F7A3200                    db "oz2",0                      ; stage2 signature
   288                                  
   289                                  non_boot_cpu_ljmp_instruction :     ; place this in 16 bit code land
   290 00000204 EA00000000                  jmp word 0:0                    ; so we get the right opcode
   291                                  
   292                                  ; adjust this if you want to change the supported number of cpus
   293                                  max_ncpus_l2   equ 7        ; log2(max_ncpus) (128 => 7)
   294                                  
   295                                  ; adjust this to change the total stack size for all cpus
   296                                  kstack_size_l2 equ 13       ; log2 stack space for all cpus (13 => 8k)
   297                                  
   298                                  kstack_size    equ (1 << kstack_size_l2)
   299                                  
   300                                  ; adjust these if you want to move things around
   301                                  kstack_loc  equ 0x1000      ; base for cpu stacks
   302                                  tss_f08_stk equ 0x6000      ; stack for double fault (grows down from ...)
   303                                  tss_f10_stk equ 0x7000      ; stack for tss fault (grows down from ...)
   304                                  sipi_vector equ 0x7000      ; where the non-boot cpus will start
   305                                  
   306                                  ; ---------------------
   307                                  
   308                                  start_stage2 :
   309                                  
   310                                      ; ---- initialize the 8259's while in real mode
   311                                  
   312 00000209 E8D805                      call irq_init_hardware
   313                                  
   314                                  ; ------------ main kernel entry point ------------
   315                                  ; all cpus enter here
   316                                  main :
   317 0000020C FA                          cli                     ; appears to stabilize recent machines a bit
   318                                  
   319                                      ; -------- enter protected mode --------
   320                                  
   321 0000020D 0F0116[0803]                lgdt [gdtr]             ; initialize the gdt
   322 00000212 0F20C0                      mov  eax,cr0
   323 00000215 0C21                        or   al,0x21            ; set the protected mode bit (lsb of cr0)
   324 00000217 0F22C0                      mov  cr0,eax            ;   and enable the native FPU exceptions ...
   325 0000021A EA[1F02]0800                jmp  codesel:flush_ip1  ; flush the cpu instruction pipeline
   326                                  flush_ip1: 
   327                                  bits 32                     ; instructions after this point are 32bit
   328                                  
   329 0000021F 66B81000                    mov  ax,datasel
   330 00000223 8ED8                        mov  ds,ax              ; initialize the data segments
   331 00000225 8EC0                        mov  es,ax
   332                                  
   333 00000227 B801000000                  mov  eax,1
   334 0000022C 0FC105[14030000]            xadd [ncpus],eax        ; get our unique cpu number
   335                                                              ; could use the lapic id if available
   336 00000233 89C6                        mov  esi,eax
   337 00000235 66B81800                    mov  ax,stacksel        ; setup a restricted stack segment
   338 00000239 8ED0                        mov  ss,ax
   339 0000023B BC00200000                  mov  esp,kstack_size    ; start at the top of the reserved stack space
   340 00000240 89F0                        mov  eax,esi
   341 00000242 C1E006                      shl  eax,(kstack_size_l2 - max_ncpus_l2)    ; kstack_size/max_ncpus * cpu#
   342 00000245 29C4                        sub  esp,eax            ; divvy up the stack
   343                                  
   344 00000247 89F0                        mov  eax,esi
   345 00000249 50                          push eax                ; save cpu index
   346 0000024A 89C3                        mov  ebx,eax
   347 0000024C 80C330                      add  bl,'0'             ; boot cpu announces via ascii 0
   348 0000024F BF9E000000                  mov  edi,160-2          ; last chracter on first line of vga
   349 00000254 D1E0                        shl  eax,1
   350 00000256 29C7                        sub  edi,eax
   351 00000258 66B82000                    mov  ax,videosel        ; point gs at video memory
   352 0000025C 8EE8                        mov  gs,ax
   353 0000025E 65881F                      mov  [gs:edi],bl        ; announce cpu presence
   354 00000261 58                          pop  eax
   355                                  
   356 00000262 09C0                        or   eax,eax            ; are we the boot cpu?
   357 00000264 0F8FD4010000                jg   non_boot_init      ; if not, do non_boot_init
   358                                  
   359                                      ; ---- establish a "pool" of free pyhsical memory
   360                                  
   361 0000026A B810000000                  mov  eax,((kilast+0x1000) >> 12)    ; include a buffer zone
   362 0000026F A3[18030000]                mov  [next_free_page],eax
   363                                  
   364                                      ; ---- setup the paging tables
   365                                  
   366 00000274 E85A020000                  call mem_alloc_kernel_page  ; get a page for pgdir
   367 00000279 C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   368 0000027C 89C7                        mov  edi,eax
   369 0000027E A3[24030000]                mov  [pgdirp],eax
   370 00000283 A3[84010000]                mov  [tss_f08_cr3],eax
   371 00000288 A3[EC010000]                mov  [tss_f10_cr3],eax
   372 0000028D A3[54020000]                mov  [tss0_cr3],eax
   373 00000292 A3[BC020000]                mov  [tss1_cr3],eax
   374 00000297 E837020000                  call mem_alloc_kernel_page  ; get a page for pgtb0
   375 0000029C C1E00C                      shl  eax,12
   376 0000029F 89C2                        mov  edx,eax
   377 000002A1 A3[28030000]                mov  [pgtb0p],eax
   378 000002A6 E828020000                  call mem_alloc_kernel_page  ; get a page for pgtb1
   379 000002AB C1E00C                      shl  eax,12
   380 000002AE 89C1                        mov  ecx,eax
   381 000002B0 A3[2C030000]                mov  [pgtb1p],eax
   382                                  
   383                                              ; first the page directory
   384                                  
   385 000002B5 0F22DF                      mov  cr3,edi            ; install the page directory
   386 000002B8 89D0                        mov  eax,edx
   387 000002BA 83C007                      add  eax,7              ; page table 0: present, pl=3, r/w
   388 000002BD AB                          stosd                   ; ... pl=3 for now (simplify vga access)
   389 000002BE 89C8                        mov  eax,ecx
   390 000002C0 83C007                      add  eax,7              ; page table 1: present, pl=3, r/w
   391 000002C3 AB                          stosd                   ; ... app memory
   392 000002C4 31C0                        xor  eax,eax            ; invalidate the rest of the app laddr space
   393 000002C6 B9FE030000                  mov  ecx,0x400-2        ; (yeah, only one pgdir for kernel+apps for now)
   394 000002CB F3AB                        rep stosd
   395                                  
   396                                              ; pgtb0 is the page table for kernel memory
   397                                  
   398 000002CD 89D7                        mov  edi,edx
   399 000002CF AB                          stosd                   ; access to page 0 will always cause a fault
   400 000002D0 B803100000                  mov  eax,0x1000 + 3     ; rest are direct map: present, pl=0, r/w
   401 000002D5 B9FF030000                  mov  ecx,0x400-1
   402                                  pgtb0_fill :
   403 000002DA AB                          stosd                   ; kernel gets to touch anything it wants < 4MB
   404 000002DB 0500100000                  add  eax,0x1000
   405 000002E0 E2F8                        loop pgtb0_fill
   406                                  
   407                                              ; pgtb1 is the first page table for app code/data/stack it is
   408                                              ; already all zeros (invalid - we'll fill in what we need later)
   409                                  
   410                                              ; enable paging - if we've done it all right, we won't crash
   411                                  
   412 000002E2 0F20C0                      mov  eax,cr0
   413 000002E5 0D00000080                  or   eax,0x80000000     ; msb of cr0
   414 000002EA 0F22C0                      mov  cr0,eax
   415 000002ED EB00                        jmp  flush_ip2          ; flush the cpu instruction pipeline
   416                                  flush_ip2: 
   417                                  
   418                                      ; ---- build the interrupt descriptor table
   419                                  
   420 000002EF E8DF010000                  call mem_alloc_kernel_page  ; get a page for the idt
   421 000002F4 C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   422 000002F7 89C2                        mov  edx,eax
   423 000002F9 A3[10030000]                mov  [idtr_addr],eax
   424                                  
   425 000002FE BE[F80D0000]                mov  esi,irq_setup_table
   426 00000303 B900010000                  mov  ecx,irq_setup_table_size
   427                                  irq_init :
   428 00000308 31C0                        xor  eax,eax
   429 0000030A 8902                        mov  [edx],eax                  ; clear the idt entry
   430 0000030C 894202                      mov  [edx+2],eax
   431 0000030F 66AD                        lodsw
   432 00000311 6689C3                      mov  bx,ax
   433 00000314 6625FCFF                    and  ax,strict 0xfffc           ; separate config flags
   434 00000318 6683E303                    and  bx,3                       ; from selector/offset value
   435 0000031C 6683FB02                    cmp  bx,irqt_task               ; task gates are different
   436 00000320 7407                        jz   irq_init_task_gate
   437 00000322 668902                      mov  [edx],ax                   ; store the handler offset
   438 00000325 66B80800                    mov  ax,codesel
   439                                  irq_init_task_gate :
   440 00000329 66894202                    mov  word [edx+2],ax
   441 0000032D 678AA7[F40D]                mov  ah,byte [bx+irq_types]
   442 00000332 30C0                        xor  al,al
   443 00000334 66894204                    mov  word [edx+4],ax
   444 00000338 83C208                      add  edx,8
   445 0000033B E2CB                        loop irq_init
   446                                  
   447 0000033D 0F011D[0E030000]            lidt [idtr]                     ; install the idt
   448                                  
   449                                      ; ---- let's see what kind of interrupt hardware we've got
   450                                  
   451 00000344 C605[30030000]00            mov  byte [enabled_lapic],0x0
   452 0000034B B801000000                  mov  eax,1
   453 00000350 0FA2                        cpuid
   454 00000352 83F801                      cmp  eax,1
   455 00000355 720F                        jb   no_lapic
   456 00000357 81E200020000                and  edx,1 << 9         ; lapic feature
   457 0000035D 7407                        jz   no_lapic
   458 0000035F C605[30030000]01            mov  byte [enabled_lapic],0x1
   459                                  no_lapic :
   460                                  
   461                                              ; if enabled, create page table entry for the lapic
   462                                  
   463 00000366 A0[30030000]                mov  al,[enabled_lapic]
   464 0000036B 08C0                        or   al,al
   465 0000036D 7430                        jz   no_lapic_init
   466                                  
   467 0000036F BA0000E0FE                  mov  edx,0xfee00000     ; phys address
   468 00000374 B900100000                  mov  ecx,0x1000         ; length
   469 00000379 E82F0D0000                  call map_pmem
   470                                  
   471                                      ; do the ioapic while we're at it
   472 0000037E BA0000C0FE                  mov  edx,0xfec00000     ; phys address
   473 00000383 52                          push edx
   474 00000384 B900100000                  mov  ecx,0x1000         ; length
   475 00000389 E81F0D0000                  call map_pmem
   476 0000038E 5A                          pop  edx
   477 0000038F C70201000000                mov  dword [edx],1
   478 00000395 A11000C0FE                  mov  eax,[0xfec00010]
   479                                  
   480 0000039A E86E040000                  call irq_init_bsp_apic_hardware
   481                                  
   482                                  no_lapic_init :
   483                                  
   484                                      ; ---- setup entry point for non_boot_cpus
   485                                  
   486 0000039F A0[04020000]                mov  al,[non_boot_cpu_ljmp_instruction]     ; get the ljmp instruction
   487 000003A4 A200700000                  mov  [sipi_vector],al                       ; place it at a 4k phys mem boundary
   488 000003A9 C70501700000-               mov  dword [sipi_vector+1],main
   489 000003AF [0C020000]         
   490                                  
   491                                      ; ---- establish a current task
   492                                  
   493 000003B3 31C0                        xor  eax,eax
   494 000003B5 B050                        mov  al,tasksel_k00
   495 000003B7 0F00D8                      ltr  ax
   496                                  
   497                                      ; ---- check for init apps
   498                                  
   499 000003BA BB[B00F0000]                mov  ebx, kend
   500                                  app_loop :
   501 000003BF 8B4318                      mov  eax, [ebx+0x18]    ; load the entry address
   502 000003C2 813B6F7A6170                cmp  dword [ebx], 0x70617a6f  ; check for "ozap"
   503 000003C8 7402                        jz   have_an_app
   504 000003CA 31C0                        xor  eax, eax           ; no app
   505                                  have_an_app :
   506                                  
   507 000003CC 83F800                      cmp  eax, 0             ; is there an app to run?
   508 000003CF 0F84A8000000                jz   idle               ; if not, idle right away
   509                                  
   510                                      ; ---- setup the init task entry point
   511                                  
   512 000003D5 BF[C0020000]                mov  edi,tss1_eip
   513 000003DA AB                          stosd
   514                                  
   515                                      ; cheat: reuse the same tss, ldt, and page tables for all
   516                                      ; the init apps - this means they run serialy - each has
   517                                      ; to exit for the next one to run
   518                                  
   519 000003DB 31C0                        xor   eax,eax
   520 000003DD A3[A0020000]                mov   [tss1],eax        ; clear out previous task link
   521 000003E2 AB                          stosd                   ; and some registers (flags)
   522 000003E3 AB                          stosd                   ; (eax)
   523 000003E4 AB                          stosd                   ; (ecx)
   524 000003E5 AB                          stosd                   ; (edx)
   525 000003E6 AB                          stosd                   ; (ebx)
   526 000003E7 8B4310                      mov   eax, [ebx+0x10]   ; get the end of the app
   527                                      ;add   eax,0x8001000     ; (this tests app stack page faults)
   528 000003EA AB                          stosd                   ; (esp)
   529 000003EB 31C0                        xor   eax,eax
   530 000003ED AB                          stosd                   ; (ebp)
   531 000003EE AB                          stosd                   ; (esi)
   532 000003EF AB                          stosd                   ; (edi)
   533                                  
   534 000003F0 8B3D[2C030000]              mov  edi,[pgtb1p]       ; rewrite the app's page table
   535 000003F6 89D8                        mov  eax,ebx
   536 000003F8 83C805                      or   eax,5              ; init app code at 0x400000 (4Mb) present and r/o
   537 000003FB AB                          stosd                   ; assume all the init apps are < 4k
   538 000003FC 0502100000                  add  eax,0x1000 + 2     ; add one page for data/bss/stack
   539 00000401 AB                          stosd
   540                                  
   541                                      ; ---- debug marker
   542 00000402 65C605010000000A            mov  byte [gs:1],0xA    ; turn the first two chars green
   543 0000040A 65C605030000000A            mov  byte [gs:3],0xA
   544                                  
   545                                      ; ---- use our current stack for system interrupts during the app
   546                                  
   547 00000412 53                          push ebx
   548 00000413 BF[A4020000]                mov  edi,tss1_esp0
   549 00000418 89E0                        mov  eax,esp
   550 0000041A AB                          stosd
   551                                  
   552                                      ; ---- start the app
   553                                  
   554 0000041B FB                          sti
   555 0000041C 9A000000005800              call tasksel_u00:0
   556 00000423 5B                          pop  ebx
   557                                  
   558                                      ; ---- point to the end of this init app
   559                                  
   560 00000424 0F013D00004000              invlpg [0x400000]       ; FIXME 80386 needs to reload cr3
   561 0000042B 0F013D00104000              invlpg [0x401000]
   562                                  
   563 00000432 8B4310                      mov  eax, [ebx+0x10]    ; load the app end address
   564 00000435 2D00004000                  sub  eax,0x400000
   565 0000043A 01C3                        add  ebx,eax            ; point ebx to the next app
   566 0000043C EB81                        jmp  app_loop
   567                                  
   568                                  ; -------- non-boot cpu initialization --------
   569                                  
   570                                  non_boot_init :
   571                                  
   572 0000043E 0F011D[0E030000]            lidt [idtr]             ; install the global idt
   573                                  
   574                                      ; ---- enable paging
   575                                  
   576 00000445 8B3D[24030000]              mov  edi,[pgdirp]       ; load this cpu's paging register
   577 0000044B 0F22DF                      mov  cr3,edi
   578                                  
   579 0000044E 50                          push eax
   580 0000044F 0F20C0                      mov  eax,cr0            ; enable paging
   581 00000452 0D00000080                  or   eax,0x80000000
   582 00000457 0F22C0                      mov  cr0,eax
   583 0000045A EB00                        jmp  flush_ip3          ; flush the cpu instruction pipeline
   584                                  flush_ip3 : 
   585 0000045C 58                          pop  eax
   586                                  
   587                                      ; ---- limit the number of threads we support here
   588                                  
   589 0000045D 83F810                      cmp  eax,max_threads
   590 00000460 7317                        jae  nb_idle
   591                                  
   592                                      ; ---- init the lapic
   593                                  
   594 00000462 E8EE030000                  call irq_init_ap_apic_hardware
   595                                  
   596                                      ; setup smbase?
   597                                  
   598                                      ; ---- establish a current task
   599                                  
   600 00000467 89C3                        mov  ebx,eax            ; move cpu number to ebx
   601 00000469 E886000000                  call create_tss_pair
   602 0000046E 53                          push ebx
   603 0000046F C1E304                      shl  ebx,4              ; 16x (descriptor_size x2)
   604 00000472 83C350                      add  ebx,tasksel_k00
   605 00000475 0F00DB                      ltr  bx                 ; establish a current task
   606 00000478 5B                          pop  ebx
   607                                  
   608                                      ; test kernel page fault handler
   609                                      ;mov  [321],eax
   610                                  
   611                                  nb_idle :
   612 00000479 FB                          sti
   613 0000047A F4                          hlt                     ; wait for something to do
   614 0000047B EBFC                        jmp  nb_idle            ; (see new_thread)
   615                                  
   616                                      ; -------- boot cpu idle task --------
   617                                      ; could be combined with nb_idle but separating
   618                                      ; these can allow for easier debug
   619                                  
   620                                  idle :
   621 0000047D FB                          sti
   622 0000047E F4                          hlt                     ; wait for interrupts
   623 0000047F EBFC                        jmp  idle
   624                                  
   625                                  
   626                                  ; ----------------------------
   627                                  ;    puts_vga - write a null delimited string to the VGA controller
   628                                  ;               in protected mode
   629                                  ;    enter:
   630                                  ;         esi - address of string
   631                                  ;         ebx - screen location (2 bytes per char, 160 bytes per line)
   632                                  ;    exit:
   633                                  ;         eax - destroyed
   634                                  ;         ebx - next screen location
   635                                  ;          gs - set to video memory selector
   636                                  bits 32
   637                                  
   638                                  puts_vga :
   639 00000481 66B82000                    mov  ax,videosel        ; point gs at video memory
   640 00000485 8EE8                        mov  gs,ax
   641                                  puts_vga_loop :
   642 00000487 2E8A06                      mov  al,[cs:esi]        ; use cs so irq handlers don't
   643 0000048A 46                          inc  esi                ; have to load kernel ds
   644 0000048B 3C00                        cmp  al,0
   645 0000048D 7408                        jz   puts_vga_done
   646 0000048F 658803                      mov  [gs:ebx],al
   647 00000492 83C302                      add  ebx,2
   648 00000495 EBF0                        jmp  puts_vga_loop
   649                                  puts_vga_done :
   650 00000497 C3                          ret
   651                                  
   652                                  ; ----------------------------
   653                                  ;   putx_vga - write the contents of eax in hex to the VGA controller
   654                                  ;              (in protected mode)
   655                                  ;   putbx_vga - write the contents of al in hex to the VGA controller
   656                                  ;
   657                                  ;   enter:
   658                                  ;       eax - value to convert to hex
   659                                  ;       ebx - screen location (2 bytes per char, 160 bytes per line)
   660                                  ;   exit:
   661                                  ;       ebx - next screen location
   662                                  ;        gs - set to video memory selector
   663                                  bits 32
   664                                  
   665                                  putbx_vga :
   666 00000498 51                          push ecx
   667 00000499 B902000000                  mov  ecx,2
   668 0000049E 25FF000000                  and  eax,0xff
   669 000004A3 C1C018                      rol  eax,24
   670 000004A6 EB06                        jmp putx_vga_loop
   671                                  
   672                                  putx_vga :
   673 000004A8 51                          push ecx
   674 000004A9 B908000000                  mov  ecx,8
   675                                  putx_vga_loop :
   676 000004AE C1C004                      rol  eax,4
   677 000004B1 50                          push eax
   678 000004B2 240F                        and  al,0xf
   679 000004B4 3C09                        cmp  al,9
   680 000004B6 7704                        ja   putx_vga_hexdigit
   681 000004B8 0430                        add  al,'0'
   682 000004BA EB02                        jmp short putx_vga_putc
   683                                  putx_vga_hexdigit :
   684 000004BC 0457                        add  al,'a'-10
   685                                  putx_vga_putc :
   686 000004BE 658803                      mov  [gs:ebx],al
   687 000004C1 83C302                      add  ebx,2
   688 000004C4 58                          pop  eax
   689 000004C5 83E0F0                      and  eax,0xfffffff0
   690 000004C8 E2E4                        loop putx_vga_loop
   691 000004CA 65C60320                    mov  byte [gs:ebx],' '
   692 000004CE 83C302                      add  ebx,2
   693 000004D1 59                          pop  ecx
   694 000004D2 C3                          ret
   695                                  
   696                                  ;------------------------------------------------------------------
   697                                  ;   mem_alloc_kernel_page - return the 4k page number of 1 page of memory
   698                                  ;                           from the kernel page pool
   699                                  ;
   700                                  ;   smp safe
   701                                  ;
   702                                  ;   returns:    eax = page number, zero means no pages left
   703                                  
   704                                  mem_alloc_kernel_page :
   705 000004D3 B801000000                  mov  eax,1
   706 000004D8 0FC105[18030000]            xadd [next_free_page],eax   ; atomic, making this re-entrant
   707                                      ; FIXME probably should check for the end of something and return 0
   708 000004DF 50                          push eax
   709 000004E0 51                          push ecx
   710 000004E1 57                          push edi
   711 000004E2 C1E00C                      shl  eax,12
   712 000004E5 B900040000                  mov  ecx,0x1000/4
   713 000004EA 89C7                        mov  edi,eax
   714 000004EC 31C0                        xor  eax,eax
   715 000004EE F3AB                        rep stosd                   ; zero the page
   716 000004F0 5F                          pop  edi
   717 000004F1 59                          pop  ecx
   718 000004F2 58                          pop  eax
   719 000004F3 C3                          ret
   720                                  
   721                                  ;------------------------------------------------------------------
   722                                  ;   create a pair of tss structs for a new cpu
   723                                  ;
   724                                  ;   enter:
   725                                  ;       ebx - cpu number
   726                                  ;   exit:
   727                                  ;       ebx - cpu number
   728                                  
   729                                  create_tss_pair :
   730 000004F4 E8DAFFFFFF                  call mem_alloc_kernel_page
   731 000004F9 09C0                        or   eax,eax
   732 000004FB 0F849C000000                jz   create_tss_pair_fail
   733 00000501 C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   734 00000504 89C7                        mov  edi,eax                ; first tss is the kernel ring 0 thread
   735                                  
   736 00000506 89FE                        mov  esi,edi
   737 00000508 83C668                      add  esi,(tss0_end-tss0)    ; second tss is the user ring 3 thread
   738                                  
   739 0000050B A1[24030000]                mov  eax,[pgdirp]
   740 00000510 89471C                      mov  [edi+(tss0_cr3-tss0)],eax
   741 00000513 89461C                      mov  [esi+(tss0_cr3-tss0)],eax
   742                                  
   743                                      ; user tss gets ldt selectors
   744 00000516 B817000000                  mov  eax,datasel1+7
   745 0000051B 894648                      mov  [esi+(tss0_es-tss0)],eax
   746 0000051E 894650                      mov  [esi+(tss0_ss-tss0)],eax
   747 00000521 894654                      mov  [esi+(tss0_ds-tss0)],eax
   748 00000524 B80F000000                  mov  eax,codesel1+7
   749 00000529 89464C                      mov  [esi+(tss0_cs-tss0)],eax
   750 0000052C B83B000000                  mov  eax,ldtsel1+3
   751 00000531 894660                      mov  [esi+(tss0_ldt-tss0)],eax
   752                                  
   753                                      ; there are three stacks total
   754                                      ;   (1) kernel tss esp0 - placed at the end of this page
   755                                      ;   (2) user tss esp0 (for interrupt handling) - end minus 1k
   756                                      ;   (3) user tss esp - will be set up by new_thread
   757                                  
   758                                      ;mov  eax,stacksel
   759                                      ;mov  [edi+(tss0_ss0-tss0)],eax
   760                                      ;mov  [edi+(tss0_esp0-tss0)],esp ; (1) kernel tss esp0
   761                                  
   762 00000534 B810000000                  mov  eax,datasel
   763 00000539 894708                      mov  [edi+(tss0_ss0-tss0)],eax
   764 0000053C 89F8                        mov  eax,edi
   765 0000053E 0500080000                  add  eax,0x0800                 ; end of the tss page
   766 00000543 894704                      mov  [edi+(tss0_esp0-tss0)],eax ; (1) kernel tss esp0
   767                                  
   768                                      ; sloppy (datasel maps all of physical ram), but better than
   769                                      ; having to set up a separate gdt stacksel for each cpu
   770 00000546 B810000000                  mov  eax,datasel
   771 0000054B 894608                      mov  [esi+(tss0_ss0-tss0)],eax
   772 0000054E 89F8                        mov  eax,edi
   773 00000550 0500100000                  add  eax,0x1000                 ; end of the tss page
   774 00000555 894604                      mov  [esi+(tss0_esp0-tss0)],eax ; (2) user tss esp0
   775                                  
   776                                      ; patch the tss addresses into the reserved gdt selectors
   777                                  
   778 00000558 89DA                        mov  edx,ebx
   779 0000055A C1E204                      shl  edx,4                      ; 16x because selectors are in pairs
   780 0000055D 83C250                      add  edx,tasksel_k00
   781                                  
   782 00000560 89F8                        mov  eax,edi
   783 00000562 C1E818                      shr  eax,24
   784 00000565 8882[07000000]              mov  byte [gdt+edx+7],al        ; base 24-32
   785 0000056B 81E7FFFFFF00                and  edi,0xffffff
   786 00000571 0BBA[02000000]              or   edi,[gdt+edx+2]            ; or in flags
   787 00000577 89BA[02000000]              mov  [gdt+edx+2],edi            ; base 0-23 and flags
   788                                  
   789 0000057D 83C208                      add  edx,8                      ; move to tasksel_uxx
   790                                  
   791 00000580 89F0                        mov  eax,esi
   792 00000582 C1E818                      shr  eax,24
   793 00000585 8882[07000000]              mov  byte [gdt+edx+7],al        ; base 24-32
   794 0000058B 81E6FFFFFF00                and  esi,0xffffff
   795 00000591 0BB2[02000000]              or   esi,[gdt+edx+2]            ; or in flags
   796 00000597 89B2[02000000]              mov  [gdt+edx+2],esi            ; base 0-23 and flags
   797                                  
   798                                  create_tss_pair_fail :
   799 0000059D C3                          ret
   800                                  
   801                                  ; -------- interrupt handlers --------
   802                                  %include "ozirq.asm"
   803                              <1> ; OZ - A more utopian OS    x86-32 interrupts
   804                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
   805                              <1> ;
   806                              <1> ; Copyright (C) 2015  Duane Voth
   807                              <1> ;
   808                              <1> ;   This program is free software: you can redistribute it and/or modify
   809                              <1> ;   it under the terms of the GNU Affero General Public License as
   810                              <1> ;   published by the Free Software Foundation, either version 3 of the
   811                              <1> ;   License, or (at your option) any later version.
   812                              <1> ;
   813                              <1> ;   This program is distributed in the hope that it will be useful,
   814                              <1> ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
   815                              <1> ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   816                              <1> ;   GNU Affero General Public License for more details.
   817                              <1> ;
   818                              <1> ;   You should have received a copy of the GNU Affero General Public License
   819                              <1> ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
   820                              <1> ;
   821                              <1> ;
   822                              <1> ; IRQ handling
   823                              <1> ;
   824                              <1> ; resources:
   825                              <1> ;       http://forum.osdev.org/viewtopic.php?p=107868#107868
   826                              <1> 
   827 0000059E 63707500            <1> cpumsg      db      "cpu",0
   828                              <1> 
   829 000005A2 646976696465206279- <1> int00msg    db      "divide by zero ",0
   830 000005AB 207A65726F2000      <1>
   831 000005B2 646562756720657863- <1> int01msg    db      "debug exception ",0
   832 000005BB 657074696F6E2000    <1>
   833 000005C3 6E6D692000          <1> int02msg    db      "nmi ",0
   834 000005C8 627265616B706F696E- <1> int03msg    db      "breakpoint exception ",0
   835 000005D1 742065786365707469- <1>
   836 000005DA 6F6E2000            <1>
   837 000005DE 6F766572666C6F7720- <1> int04msg    db      "overflow exception ",0
   838 000005E7 657863657074696F6E- <1>
   839 000005F0 2000                <1>
   840 000005F2 626F756E6420657863- <1> int05msg    db      "bound exceeded ",0
   841 000005FB 65656465642000      <1>
   842 00000602 696E76616C6964206F- <1> int06msg    db      "invalid opcode ",0
   843 0000060B 70636F64652000      <1>
   844 00000612 64657669636520756E- <1> int07msg    db      "device unavailable ",0
   845 0000061B 617661696C61626C65- <1>
   846 00000624 2000                <1>
   847 00000626 646F75626C65206661- <1> int08msg    db      "double fault ",0
   848 0000062F 756C742000          <1>
   849 00000634 636F70726F63657373- <1> int09msg    db      "coprocessor segment overrun ",0
   850 0000063D 6F72207365676D656E- <1>
   851 00000646 74206F76657272756E- <1>
   852 0000064F 2000                <1>
   853 00000651 696E76616C69642074- <1> int10msg    db      "invalid tss ",0
   854 0000065A 73732000            <1>
   855 0000065E 7365676D656E74206E- <1> int11msg    db      "segment not present ",0
   856 00000667 6F742070726573656E- <1>
   857 00000670 742000              <1>
   858 00000673 737461636B20666175- <1> int12msg    db      "stack fault ",0
   859 0000067C 6C742000            <1>
   860 00000680 67656E6572616C2070- <1> int13msg    db      "general protection fault ",0
   861 00000689 726F74656374696F6E- <1>
   862 00000692 206661756C742000    <1>
   863 0000069A 6B65726E656C207061- <1> int14kmsg   db      "kernel page fault addr=",0
   864 000006A3 6765206661756C7420- <1>
   865 000006AC 616464723D00        <1>
   866 000006B2 617070207061676520- <1> int14umsg   db      "app page fault addr=",0
   867 000006BB 6661756C7420616464- <1>
   868 000006C4 723D00              <1>
   869 000006C7 666C6F6174696E6720- <1> int16msg    db      "floating point err ",0
   870 000006D0 706F696E7420657272- <1>
   871 000006D9 2000                <1>
   872 000006DB 616C69676E6D656E74- <1> int17msg    db      "alignment check ",0
   873 000006E4 20636865636B2000    <1>
   874 000006EC 6D616368696E652063- <1> int18msg    db      "machine check ",0
   875 000006F5 6865636B2000        <1>
   876 000006FB 73696D6420666C6F61- <1> int19msg    db      "simd floating point err ",0
   877 00000704 74696E6720706F696E- <1>
   878 0000070D 74206572722000      <1>
   879                              <1> 
   880 00000714 687720696E74303220- <1> int34msg    db      "hw int02 ",0
   881 0000071D 00                  <1>
   882 0000071E 687720696E74303320- <1> int35msg    db      "hw int03 ",0
   883 00000727 00                  <1>
   884 00000728 687720696E74303420- <1> int36msg    db      "hw int04 ",0
   885 00000731 00                  <1>
   886 00000732 687720696E74303520- <1> int37msg    db      "hw int05 ",0
   887 0000073B 00                  <1>
   888 0000073C 687720696E74303620- <1> int38msg    db      "hw int06 ",0
   889 00000745 00                  <1>
   890 00000746 687720696E74303720- <1> int39msg    db      "hw int07 ",0
   891 0000074F 00                  <1>
   892 00000750 687720696E74303820- <1> int40msg    db      "hw int08 ",0
   893 00000759 00                  <1>
   894 0000075A 687720696E74303920- <1> int41msg    db      "hw int09 ",0
   895 00000763 00                  <1>
   896 00000764 687720696E74313020- <1> int42msg    db      "hw int10 ",0
   897 0000076D 00                  <1>
   898 0000076E 687720696E74313120- <1> int43msg    db      "hw int11 ",0
   899 00000777 00                  <1>
   900 00000778 687720696E74313220- <1> int44msg    db      "hw int12 ",0
   901 00000781 00                  <1>
   902 00000782 687720696E74313320- <1> int45msg    db      "hw int13 ",0
   903 0000078B 00                  <1>
   904 0000078C 687720696E74313420- <1> int46msg    db      "hw int14 ",0
   905 00000795 00                  <1>
   906 00000796 687720696E74313520- <1> int47msg    db      "hw int15 ",0
   907 0000079F 00                  <1>
   908                              <1> 
   909 000007A0 73707572696F757320- <1> spuriousmsg db      "spurious int ",0
   910 000007A9 696E742000          <1>
   911 000007AE 617069636572722069- <1> apicerrmsg  db      "apicerr int ",0
   912 000007B7 6E742000            <1>
   913 000007BB 68692000            <1> himsg       db      "hi ",0
   914 000007BF 756E6B6E6F776E2073- <1> int255msg           db  "unknown system call ",0
   915 000007C8 797374656D2063616C- <1>
   916 000007D1 6C2000              <1>
   917                              <1> 
   918 000007D4 766D206661756C743A- <1> intvmmsg            db  "vm fault: ",0
   919 000007DD 2000                <1>
   920                              <1> 
   921 000007DF 90                  <1>   align 4
   922 000007E0 00000000            <1> irq_err_lno dd 0
   923                              <1> 
   924                              <1> ; ---- IRQ hardware initialization ----
   925                              <1> 
   926                              <1> bits 16
   927                              <1> 
   928                              <1> irq_init_hardware :
   929                              <1> 
   930                              <1>     ; re-program the 8259's to move the hardware vectors out of the
   931                              <1>     ; soft int range ... C'mon, Intel was pretty clear about this!
   932                              <1> 
   933 000007E4 B011                <1>     mov  al,0x11
   934 000007E6 E620                <1>     out  0x20,al            ; init the 1st 8259
   935 000007E8 B011                <1>     mov  al,0x11
   936 000007EA E6A0                <1>     out  0xA0,al            ; init the 2nd 8259
   937 000007EC B020                <1>     mov  al,apic0_irqbase
   938 000007EE E621                <1>     out  0x21,al            ; base for the 1st 8259
   939 000007F0 B028                <1>     mov  al,apic1_irqbase
   940 000007F2 E6A1                <1>     out  0xA1,al            ; base for the 2nd 8259
   941 000007F4 B004                <1>     mov  al,0x04
   942 000007F6 E621                <1>     out  0x21,al            ; set 1st 8259 as master
   943 000007F8 B002                <1>     mov  al,0x02
   944 000007FA E6A1                <1>     out  0xA1,al            ; set 2nd 8259 as slave
   945 000007FC B001                <1>     mov  al,0x01
   946 000007FE E621                <1>     out  0x21,al
   947 00000800 B001                <1>     mov  al,0x01
   948 00000802 E6A1                <1>     out  0xA1,al
   949 00000804 B0FC                <1>     mov  al,0xfc            ; PIC1 disable all but the timer and kbd
   950 00000806 E621                <1>     out  0x21,al
   951 00000808 B0FF                <1>     mov  al,0xff            ; PIC2 disable everything
   952 0000080A E6A1                <1>     out  0xA1,al
   953 0000080C C3                  <1>     ret
   954                              <1> 
   955                              <1> bits 32
   956                              <1> 
   957                              <1> ; ----------
   958                              <1> 
   959                              <1> irq_init_bsp_apic_hardware :
   960                              <1>     ;jmp  no_apic
   961                              <1> 
   962                              <1>     ; ---- test for an apic
   963                              <1> 
   964 0000080D A17003E0FE          <1>     mov  eax,[0xfee00370]
   965 00000812 2500FFFFFF          <1>     and  eax,0xffffff00
   966 00000817 0DF0000000          <1>     or   eax,apicerr_int
   967 0000081C A37003E0FE          <1>     mov  [0xfee00370],eax   ; setup LVT3 error vector
   968                              <1> 
   969 00000821 B8EF010000          <1>     mov  eax,0x00000100 + spurious_int    ; enable + spurious int
   970 00000826 A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
   971 0000082B B800000001          <1>     mov  eax,0x01000000
   972 00000830 A3D000E0FE          <1>     mov  [0xfee000d0],eax   ; set our LDR
   973 00000835 B8FFFFFFFF          <1>     mov  eax,0xffffffff
   974 0000083A A3E000E0FE          <1>     mov  [0xfee000e0],eax   ; set our DFR
   975 0000083F 31C0                <1>     xor  eax,eax
   976 00000841 A3B000E0FE          <1>     mov  [0xfee000b0],eax   ; eoi anything outstanding
   977                              <1> 
   978                              <1> ;    ; ---- enable the local apic via msr
   979                              <1> ; but apparently not needed ...
   980                              <1> ;    mov  ecx,0x1b
   981                              <1> ;    xor  edx,edx
   982                              <1> ; ;  mov  eax,0xfffff800
   983                              <1> ;    mov  eax,0x00000800
   984                              <1> ;    wrmsr
   985                              <1> ;    mov  eax,[0xfffff030]
   986                              <1> 
   987                              <1>     ; ---- visual indicator: lapic active
   988                              <1> 
   989 00000846 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
   990 0000084A 8EE8                <1>     mov  gs,ax          
   991 0000084C 65C605320000002B    <1>     mov  byte [gs:25*2],'+'
   992                              <1> 
   993 00000854 C3                  <1>     ret
   994                              <1> 
   995                              <1> ; ----------
   996                              <1> 
   997                              <1> irq_init_ap_apic_hardware :
   998                              <1>     ; eax = cpu number
   999                              <1> 
  1000                              <1>     ; ---- mtrr for 0xfee00000 -> strong uncachable (UC) ?
  1001                              <1> 
  1002 00000855 50                  <1>     push eax                ; save cpu number
  1003 00000856 89C1                <1>     mov  ecx,eax
  1004 00000858 A0[30030000]        <1>     mov  al,[enabled_lapic]
  1005 0000085D 08C0                <1>     or   al,al
  1006 0000085F 7432                <1>     jz  no_lapic_init2
  1007                              <1> 
  1008 00000861 BB00000001          <1>     mov  ebx,0x01000000
  1009 00000866 D3E3                <1>     shl  ebx,cl             ; bit mask based on cpu number
  1010 00000868 891DD000E0FE        <1>     mov  [0xfee000d0],ebx   ; set our LDR
  1011                              <1> 
  1012 0000086E A17003E0FE          <1>     mov  eax,[0xfee00370]
  1013 00000873 2500FFFFFF          <1>     and  eax,0xffffff00
  1014 00000878 0DF0000000          <1>     or   eax,apicerr_int
  1015 0000087D A37003E0FE          <1>     mov  [0xfee00370],eax   ; setup LVT3 error vector
  1016                              <1> 
  1017 00000882 B8EF010000          <1>     mov  eax,0x00000100 + spurious_int  ; enable + spurious int
  1018 00000887 A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
  1019 0000088C 31C0                <1>     xor  eax,eax
  1020 0000088E A3B000E0FE          <1>     mov  [0xfee000b0],eax   ; eoi anything outstanding
  1021                              <1> no_lapic_init2 :
  1022 00000893 58                  <1>     pop  eax
  1023 00000894 C3                  <1>     ret
  1024                              <1> 
  1025                              <1> ; ---- IRQ handlers ----
  1026                              <1> 
  1027 00000895 90<rept>            <1> align 4
  1028                              <1> int_handler_div0 :
  1029 00000898 56                  <1>     push esi
  1030 00000899 BE[A2050000]        <1>     mov  esi,int00msg
  1031 0000089E E8C5040000          <1>     call irq_print_msg
  1032 000008A3 5E                  <1>     pop  esi
  1033 000008A4 E9EC000000          <1>     jmp  int_handler_show_eip
  1034                              <1> 
  1035 000008A9 90<rept>            <1> align 4
  1036                              <1> int_handler_debug :
  1037 000008AC 56                  <1>     push esi
  1038 000008AD BE[B2050000]        <1>     mov  esi,int01msg
  1039 000008B2 E8B1040000          <1>     call irq_print_msg
  1040 000008B7 5E                  <1>     pop  esi
  1041 000008B8 E9D8000000          <1>     jmp  int_handler_show_eip
  1042                              <1> 
  1043 000008BD 90<rept>            <1> align 4
  1044                              <1> int_handler_nmi :
  1045 000008C0 56                  <1>     push esi
  1046 000008C1 BE[C3050000]        <1>     mov  esi,int02msg
  1047 000008C6 E89D040000          <1>     call irq_print_msg
  1048 000008CB 5E                  <1>     pop  esi
  1049 000008CC CF                  <1>     iret
  1050                              <1>     ;jmp  reboot_on_alt_key
  1051                              <1> 
  1052 000008CD 90<rept>            <1> align 4
  1053                              <1> int_handler_brkp :
  1054 000008D0 56                  <1>     push esi
  1055 000008D1 BE[C8050000]        <1>     mov  esi,int03msg
  1056 000008D6 E88D040000          <1>     call irq_print_msg
  1057 000008DB 5E                  <1>     pop  esi
  1058 000008DC E9B4000000          <1>     jmp  int_handler_show_eip
  1059                              <1> 
  1060 000008E1 90<rept>            <1> align 4
  1061                              <1> int_handler_ovrflw :
  1062 000008E4 56                  <1>     push esi
  1063 000008E5 BE[DE050000]        <1>     mov  esi,int04msg
  1064 000008EA E879040000          <1>     call irq_print_msg
  1065 000008EF 5E                  <1>     pop  esi
  1066 000008F0 E9A0000000          <1>     jmp  int_handler_show_eip
  1067                              <1> 
  1068 000008F5 90<rept>            <1> align 4
  1069                              <1> int_handler_bound :
  1070 000008F8 56                  <1>     push esi
  1071 000008F9 BE[F2050000]        <1>     mov  esi,int05msg
  1072 000008FE E865040000          <1>     call irq_print_msg
  1073 00000903 5E                  <1>     pop  esi
  1074 00000904 E98C000000          <1>     jmp  int_handler_show_eip
  1075                              <1> 
  1076 00000909 90<rept>            <1> align 4
  1077                              <1> int_handler_invop :
  1078 0000090C 56                  <1>     push esi
  1079 0000090D BE[02060000]        <1>     mov  esi,int06msg
  1080 00000912 E851040000          <1>     call irq_print_msg
  1081 00000917 5E                  <1>     pop  esi
  1082 00000918 EB7B                <1>     jmp  int_handler_show_eip
  1083                              <1> 
  1084 0000091A 90<rept>            <1> align 4
  1085                              <1> int_handler_devna :
  1086                              <1>     ;push esi
  1087                              <1>     ;mov  esi,int07msg
  1088                              <1>     ;call irq_print_msg
  1089                              <1>     ;pop  esi
  1090                              <1>     ; FIXME fxsave/fxrestore the fpu/sse/mmx regs
  1091 0000091C 0F06                <1>     clts                ; sure! you can use the fpu
  1092 0000091E CF                  <1>     iret
  1093                              <1> 
  1094 0000091F 90                  <1> align 4
  1095                              <1> int_handler_cpsego :
  1096 00000920 56                  <1>     push esi
  1097 00000921 BE[34060000]        <1>     mov  esi,int09msg
  1098 00000926 E83D040000          <1>     call irq_print_msg
  1099 0000092B 5E                  <1>     pop  esi
  1100 0000092C EB67                <1>     jmp  int_handler_show_eip
  1101                              <1> 
  1102 0000092E 90<rept>            <1> align 4
  1103                              <1> int_handler_segnp :
  1104                              <1>     ; ec = seg selector
  1105 00000930 56                  <1>     push esi
  1106 00000931 BE[5E060000]        <1>     mov  esi,int11msg
  1107 00000936 E82D040000          <1>     call irq_print_msg
  1108 0000093B 5E                  <1>     pop  esi
  1109 0000093C EB32                <1>     jmp  int_handler_show_ec_eip
  1110                              <1> 
  1111 0000093E 90<rept>            <1> align 4
  1112                              <1> int_handler_stkflt :
  1113                              <1>     ; ec = seg selector
  1114 00000940 56                  <1>     push esi
  1115 00000941 BE[73060000]        <1>     mov  esi,int12msg
  1116 00000946 E81D040000          <1>     call irq_print_msg
  1117 0000094B 5E                  <1>     pop  esi
  1118 0000094C B904000000          <1>     mov  ecx,4
  1119 00000951 83C302              <1>     add  ebx,2
  1120                              <1> int_handler_show_stack_loop :
  1121 00000954 58                  <1>     pop  eax
  1122 00000955 E84EFBFFFF          <1>     call putx_vga
  1123 0000095A E2F8                <1>     loop int_handler_show_stack_loop
  1124 0000095C E95B040000          <1>     jmp  reboot_on_alt_key
  1125                              <1> 
  1126 00000961 90<rept>            <1> align 4
  1127                              <1> int_handler_gpf :
  1128                              <1>     ; ec = various ...
  1129                              <1>     ;test dword [esp+0xc],1 << 17    ; check the eflags vm bit
  1130                              <1>     ;jnz  int_handler_vm_gpf
  1131                              <1> 
  1132 00000964 56                  <1>     push esi
  1133 00000965 BE[80060000]        <1>     mov  esi,int13msg
  1134 0000096A E8F9030000          <1>     call irq_print_msg
  1135 0000096F 5E                  <1>     pop  esi
  1136                              <1> int_handler_show_ec_eip :
  1137 00000970 65C60365            <1>     mov  byte [gs:ebx],'e'
  1138 00000974 83C302              <1>     add  ebx,2
  1139 00000977 65C60363            <1>     mov  byte [gs:ebx],'c'
  1140 0000097B 83C302              <1>     add  ebx,2
  1141 0000097E 65C6033D            <1>     mov  byte [gs:ebx],'='
  1142 00000982 83C302              <1>     add  ebx,2
  1143 00000985 58                  <1>     pop  eax                ; ec
  1144 00000986 E80DFBFFFF          <1>     call putbx_vga
  1145 0000098B 83EB02              <1>     sub  ebx,2
  1146 0000098E 65C60320            <1>     mov  byte [gs:ebx],' '
  1147 00000992 83C302              <1>     add  ebx,2
  1148                              <1> int_handler_show_eip :
  1149 00000995 65C60363            <1>     mov  byte [gs:ebx],'c'
  1150 00000999 83C302              <1>     add  ebx,2
  1151 0000099C 65C60373            <1>     mov  byte [gs:ebx],'s'
  1152 000009A0 83C302              <1>     add  ebx,2
  1153 000009A3 65C6033A            <1>     mov  byte [gs:ebx],':'
  1154 000009A7 83C302              <1>     add  ebx,2
  1155 000009AA 65C60365            <1>     mov  byte [gs:ebx],'e'
  1156 000009AE 83C302              <1>     add  ebx,2
  1157 000009B1 65C60369            <1>     mov  byte [gs:ebx],'i'
  1158 000009B5 83C302              <1>     add  ebx,2
  1159 000009B8 65C60370            <1>     mov  byte [gs:ebx],'p'
  1160 000009BC 83C302              <1>     add  ebx,2
  1161 000009BF 65C6033D            <1>     mov  byte [gs:ebx],'='
  1162 000009C3 83C302              <1>     add  ebx,2
  1163 000009C6 5A                  <1>     pop  edx                ; eip
  1164 000009C7 58                  <1>     pop  eax                ; cs
  1165 000009C8 E8DBFAFFFF          <1>     call putx_vga
  1166 000009CD 83EB02              <1>     sub  ebx,2
  1167 000009D0 65C6033A            <1>     mov  byte [gs:ebx],':'
  1168 000009D4 83C302              <1>     add  ebx,2
  1169 000009D7 89D0                <1>     mov  eax,edx
  1170 000009D9 E8CAFAFFFF          <1>     call putx_vga
  1171 000009DE E9D9030000          <1>     jmp  reboot_on_alt_key
  1172                              <1> 
  1173                              <1> int_handler_vm_gpf :
  1174 000009E3 53                  <1>     push ebx
  1175                              <1>     ;mov  ebx,[esp+8]        ; faulter's eip
  1176 000009E4 2E8A1B              <1>     mov  bl,[cs:ebx]        ; get the opcode that caused the fault
  1177 000009E7 80FBF4              <1>     cmp  bl,0xf4            ; 'hlt' is ok
  1178 000009EA 7452                <1>     jz   int_handler_vm_normal_return
  1179                              <1> 
  1180 000009EC 56                  <1>     push esi
  1181 000009ED 50                  <1>     push eax
  1182 000009EE 53                  <1>     push ebx
  1183 000009EF BE[D4070000]        <1>     mov  esi,intvmmsg
  1184 000009F4 E86F030000          <1>     call irq_print_msg
  1185 000009F9 65C6036F            <1>     mov  byte [gs:ebx],'o'
  1186 000009FD 83C302              <1>     add  ebx,2
  1187 00000A00 65C60370            <1>     mov  byte [gs:ebx],'p'
  1188 00000A04 83C302              <1>     add  ebx,2
  1189 00000A07 65C60363            <1>     mov  byte [gs:ebx],'c'
  1190 00000A0B 83C302              <1>     add  ebx,2
  1191 00000A0E 65C6036F            <1>     mov  byte [gs:ebx],'o'
  1192 00000A12 83C302              <1>     add  ebx,2
  1193 00000A15 65C60364            <1>     mov  byte [gs:ebx],'d'
  1194 00000A19 83C302              <1>     add  ebx,2
  1195 00000A1C 65C60365            <1>     mov  byte [gs:ebx],'e'
  1196 00000A20 83C302              <1>     add  ebx,2
  1197 00000A23 65C60328            <1>     mov  byte [gs:ebx],'('
  1198 00000A27 83C302              <1>     add  ebx,2
  1199 00000A2A 58                  <1>     pop  eax
  1200 00000A2B 25FF000000          <1>     and  eax,0xff
  1201 00000A30 E863FAFFFF          <1>     call putbx_vga
  1202 00000A35 83C302              <1>     add  ebx,2
  1203 00000A38 65C60329            <1>     mov  byte [gs:ebx],')'
  1204 00000A3C 58                  <1>     pop  eax
  1205 00000A3D 5E                  <1>     pop  esi
  1206                              <1> int_handler_vm_normal_return :
  1207 00000A3E 5B                  <1>     pop  ebx
  1208                              <1> 
  1209 00000A3F FF74240C            <1>     push dword [esp+0xc]    ; eflags
  1210 00000A43 9D                  <1>     popf                    ; restore the VM and NT flags
  1211 00000A44 CF                  <1>     iret                    ; chain back via nested task
  1212                              <1>                             ; from v86 tss to original caller
  1213                              <1> 
  1214 00000A45 90<rept>            <1> align 4
  1215                              <1> int_handler_pgflt :
  1216 00000A48 58                  <1>     pop  eax
  1217 00000A49 50                  <1>     push eax
  1218 00000A4A A904000000          <1>     test eax,0x4                        ; user mode or supervisor?
  1219 00000A4F 7407                <1>     jz   int_handler_pgflt_bad_kaddr    ; if not, kernel failed
  1220                              <1> 
  1221                              <1> int_handler_pgflt_bad_uaddr :
  1222 00000A51 BE[B2060000]        <1>     mov  esi,int14umsg
  1223 00000A56 EB05                <1>     jmp  int_handler_pgflt_msg
  1224                              <1> 
  1225                              <1> int_handler_pgflt_bad_kaddr :
  1226 00000A58 BE[9A060000]        <1>     mov  esi,int14kmsg
  1227                              <1> 
  1228                              <1> int_handler_pgflt_msg :
  1229 00000A5D E806030000          <1>     call irq_print_msg
  1230 00000A62 0F20D0              <1>     mov  eax,cr2
  1231 00000A65 E83EFAFFFF          <1>     call putx_vga                       ; print the addres of the fault
  1232 00000A6A E901FFFFFF          <1>     jmp  int_handler_show_ec_eip
  1233                              <1> 
  1234 00000A6F 90                  <1> align 4
  1235                              <1> int_handler_fpuerr :
  1236 00000A70 56                  <1>     push esi
  1237 00000A71 BE[C7060000]        <1>     mov  esi,int16msg
  1238 00000A76 E8ED020000          <1>     call irq_print_msg
  1239                              <1>     ; FIXME flags identify error
  1240                              <1>     ;   IS - FPU stack overflow
  1241                              <1>     ;   IA - Invalid arithmetic operation
  1242                              <1>     ;   Z  - Divide by zero
  1243                              <1>     ;   D  - Source operand is a denormal number
  1244                              <1>     ;   O  - Overflow in result
  1245                              <1>     ;   U  - Underflow in result
  1246                              <1>     ;   P  - Inexact result
  1247 00000A7B E915FFFFFF          <1>     jmp  int_handler_show_eip
  1248                              <1> 
  1249                              <1> align 4
  1250                              <1> int_handler_algnchk :
  1251                              <1>     ; ec = zero
  1252 00000A80 56                  <1>     push esi
  1253 00000A81 BE[DB060000]        <1>     mov  esi,int17msg
  1254 00000A86 E8DD020000          <1>     call irq_print_msg
  1255 00000A8B 5E                  <1>     pop  esi
  1256 00000A8C 58                  <1>     pop  eax                    ; toss the ec
  1257 00000A8D E903FFFFFF          <1>     jmp  int_handler_show_eip
  1258                              <1> 
  1259 00000A92 90<rept>            <1> align 4
  1260                              <1> int_handler_machchk :
  1261 00000A94 56                  <1>     push esi
  1262 00000A95 BE[EC060000]        <1>     mov  esi,int18msg
  1263 00000A9A E8C9020000          <1>     call irq_print_msg
  1264 00000A9F 5E                  <1>     pop  esi
  1265 00000AA0 E9F0FEFFFF          <1>     jmp  int_handler_show_eip
  1266                              <1> 
  1267 00000AA5 90<rept>            <1> align 4
  1268                              <1> int_handler_simdfpe :
  1269 00000AA8 56                  <1>     push esi
  1270 00000AA9 BE[FB060000]        <1>     mov  esi,int19msg
  1271 00000AAE E8B5020000          <1>     call irq_print_msg
  1272 00000AB3 5E                  <1>     pop  esi
  1273 00000AB4 E9DCFEFFFF          <1>     jmp  int_handler_show_eip
  1274                              <1> 
  1275                              <1> ; indicate that an irq has been serviced
  1276                              <1> display_irq :
  1277 00000AB9 50                  <1>     push eax
  1278 00000ABA 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
  1279 00000ABE 8EE8                <1>     mov  gs,ax          
  1280 00000AC0 88F8                <1>     mov  al,bh              ; display irq "number"
  1281 00000AC2 81E3FF000000        <1>     and  ebx,0xff
  1282 00000AC8 658803              <1>     mov  [gs:ebx],al
  1283 00000ACB 658A4301            <1>     mov  al,[gs:ebx+1]
  1284 00000ACF FEC0                <1>     inc  al
  1285 00000AD1 0C08                <1>     or   al,0x8             ; avoid black and dark colors
  1286 00000AD3 240F                <1>     and  al,0xf
  1287 00000AD5 65884301            <1>     mov  [gs:ebx+1],al      ; change character color
  1288 00000AD9 58                  <1>     pop  eax
  1289 00000ADA C3                  <1>     ret
  1290                              <1> 
  1291 00000ADB 90                  <1> align 4
  1292                              <1> int_handler_timer :     
  1293 00000ADC 53                  <1>     push ebx
  1294 00000ADD 66BB3C74            <1>     mov  bx,('t' << 8) + 30*2
  1295 00000AE1 E8D3FFFFFF          <1>     call display_irq
  1296 00000AE6 5B                  <1>     pop  ebx
  1297                              <1> 
  1298 00000AE7 50                  <1>     push eax
  1299                              <1> 
  1300                              <1>     ; ---- wakeup any sleeping cpus (see syscall_sleep)
  1301                              <1> 
  1302 00000AE8 A0[30030000]        <1>     mov  al,[enabled_lapic]
  1303 00000AED 08C0                <1>     or   al,al
  1304 00000AEF 741B                <1>     jz   no_sleepers
  1305                              <1> 
  1306                              <1>     ; the race here is not important, we'll catch them on the next tick
  1307                              <1> 
  1308 00000AF1 A1[1C030000]        <1>     mov  eax,[sleepers]
  1309 00000AF6 09C0                <1>     or   eax,eax
  1310 00000AF8 7412                <1>     jz   no_sleepers
  1311 00000AFA C1E018              <1>     shl  eax,24                     ; FIXME can only handle 8 cpus
  1312 00000AFD A31003E0FE          <1>     mov  dword [0xfee00310],eax     ; via the destination register ...
  1313 00000B02 B8FE480000          <1>     mov  eax,0x04800 + wakeup_int   ; no shrthnd, fixed, logical, edge
  1314 00000B07 A30003E0FE          <1>     mov  dword [0xfee00300],eax
  1315                              <1> 
  1316                              <1> no_sleepers :
  1317 00000B0C B020                <1>     mov  al,0x20        
  1318 00000B0E E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1319 00000B10 58                  <1>     pop  eax
  1320 00000B11 CF                  <1>     iret                
  1321                              <1> 
  1322 00000B12 90<rept>            <1> align 4
  1323                              <1> int_handler_kbd :
  1324 00000B14 53                  <1>     push ebx
  1325 00000B15 66BB3E6B            <1>     mov  bx,('k' << 8) + 31*2
  1326 00000B19 E89BFFFFFF          <1>     call display_irq
  1327 00000B1E 5B                  <1>     pop  ebx
  1328                              <1> 
  1329 00000B1F 50                  <1>     push eax
  1330                              <1> 
  1331 00000B20 53                  <1>     push ebx
  1332 00000B21 BB36000000          <1>     mov  ebx,27*2
  1333 00000B26 E460                <1>     in   al,0x60
  1334 00000B28 50                  <1>     push eax
  1335 00000B29 E86AF9FFFF          <1>     call putbx_vga
  1336 00000B2E 58                  <1>     pop  eax
  1337 00000B2F 5B                  <1>     pop  ebx
  1338                              <1> 
  1339 00000B30 3C53                <1>     cmp  al,0x53            ; scan code for the DEL key
  1340 00000B32 0F848A020000        <1>     jz   reboot
  1341                              <1> 
  1342 00000B38 B020                <1>     mov  al,0x20
  1343 00000B3A E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1344                              <1> 
  1345 00000B3C 58                  <1>     pop  eax
  1346 00000B3D CF                  <1>     iret
  1347                              <1> 
  1348 00000B3E 90<rept>            <1> align 4
  1349                              <1> int_handler_hw02 :          ; cascade
  1350 00000B40 53                  <1>     push ebx
  1351 00000B41 66BB4063            <1>     mov  bx,('c' << 8) + 32*2
  1352 00000B45 E86FFFFFFF          <1>     call display_irq
  1353 00000B4A 5B                  <1>     pop  ebx
  1354                              <1> 
  1355 00000B4B 56                  <1>     push esi
  1356 00000B4C BE[14070000]        <1>     mov  esi,int34msg
  1357 00000B51 E812020000          <1>     call irq_print_msg
  1358 00000B56 5E                  <1>     pop  esi
  1359 00000B57 E960020000          <1>     jmp  reboot_on_alt_key
  1360                              <1> 
  1361                              <1> align 4
  1362                              <1> int_handler_hw03 :          ; serial port 2
  1363 00000B5C 53                  <1>     push ebx
  1364 00000B5D 66BB4233            <1>     mov  bx,('3' << 8) + 33*2
  1365 00000B61 E853FFFFFF          <1>     call display_irq
  1366 00000B66 5B                  <1>     pop  ebx
  1367                              <1> 
  1368 00000B67 56                  <1>     push esi
  1369 00000B68 BE[1E070000]        <1>     mov  esi,int35msg
  1370 00000B6D E8F6010000          <1>     call irq_print_msg
  1371 00000B72 5E                  <1>     pop  esi
  1372 00000B73 E944020000          <1>     jmp  reboot_on_alt_key
  1373                              <1> 
  1374                              <1> align 4
  1375                              <1> int_handler_hw04 :          ; serial port 1
  1376 00000B78 53                  <1>     push ebx
  1377 00000B79 66BB4434            <1>     mov  bx,('4' << 8) + 34*2
  1378 00000B7D E837FFFFFF          <1>     call display_irq
  1379 00000B82 5B                  <1>     pop  ebx
  1380                              <1> 
  1381 00000B83 56                  <1>     push esi
  1382 00000B84 BE[28070000]        <1>     mov  esi,int36msg
  1383 00000B89 E8DA010000          <1>     call irq_print_msg
  1384 00000B8E 5E                  <1>     pop  esi
  1385 00000B8F E928020000          <1>     jmp  reboot_on_alt_key
  1386                              <1> 
  1387                              <1> align 4
  1388                              <1> int_handler_hw05 :          ; parallel port 2 or sound card
  1389 00000B94 53                  <1>     push ebx
  1390 00000B95 66BB4635            <1>     mov  bx,('5' << 8) + 35*2
  1391 00000B99 E81BFFFFFF          <1>     call display_irq
  1392 00000B9E 5B                  <1>     pop  ebx
  1393                              <1> 
  1394 00000B9F 56                  <1>     push esi
  1395 00000BA0 BE[32070000]        <1>     mov  esi,int37msg
  1396 00000BA5 E8BE010000          <1>     call irq_print_msg
  1397 00000BAA 5E                  <1>     pop  esi
  1398 00000BAB E90C020000          <1>     jmp  reboot_on_alt_key
  1399                              <1> 
  1400                              <1> align 4
  1401                              <1> int_handler_hw06 :          ; floppy disk controller
  1402 00000BB0 53                  <1>     push ebx
  1403 00000BB1 66BB4836            <1>     mov  bx,('6' << 8) + 36*2
  1404 00000BB5 E8FFFEFFFF          <1>     call display_irq
  1405 00000BBA 5B                  <1>     pop  ebx
  1406                              <1> 
  1407 00000BBB 56                  <1>     push esi
  1408 00000BBC BE[3C070000]        <1>     mov  esi,int38msg
  1409 00000BC1 E8A2010000          <1>     call irq_print_msg
  1410 00000BC6 5E                  <1>     pop  esi
  1411 00000BC7 E9F0010000          <1>     jmp  reboot_on_alt_key
  1412                              <1> 
  1413                              <1> align 4
  1414                              <1> int_handler_hw07 :          ; parallel port 1
  1415 00000BCC 53                  <1>     push ebx
  1416 00000BCD 66BB4A37            <1>     mov  bx,('7' << 8) + 37*2
  1417 00000BD1 E8E3FEFFFF          <1>     call display_irq
  1418 00000BD6 5B                  <1>     pop  ebx
  1419                              <1> 
  1420                              <1> ;   push esi                ; 7 seems to happen a lot on some boxes
  1421                              <1> ;   mov  esi,int39msg
  1422                              <1> ;   call irq_print_msg
  1423                              <1> ;   pop  esi
  1424 00000BD7 B020                <1>     mov  al,0x20
  1425 00000BD9 E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1426 00000BDB CF                  <1>     iret
  1427                              <1>     ;jmp  reboot_on_alt_key
  1428                              <1> 
  1429                              <1> align 4
  1430                              <1> int_handler_hw08 :          ; RTC
  1431 00000BDC 53                  <1>     push ebx
  1432 00000BDD 66BB4C38            <1>     mov  bx,('8' << 8) + 38*2
  1433 00000BE1 E8D3FEFFFF          <1>     call display_irq
  1434 00000BE6 5B                  <1>     pop  ebx
  1435                              <1> 
  1436 00000BE7 56                  <1>     push esi
  1437 00000BE8 BE[50070000]        <1>     mov  esi,int40msg
  1438 00000BED E876010000          <1>     call irq_print_msg
  1439 00000BF2 5E                  <1>     pop  esi
  1440 00000BF3 E9C4010000          <1>     jmp  reboot_on_alt_key
  1441                              <1> 
  1442                              <1> align 4
  1443                              <1> int_handler_hw09 :          ; acpi
  1444 00000BF8 53                  <1>     push ebx
  1445 00000BF9 66BB4E39            <1>     mov  bx,('9' << 8) + 39*2
  1446 00000BFD E8B7FEFFFF          <1>     call display_irq
  1447 00000C02 5B                  <1>     pop  ebx
  1448                              <1> 
  1449 00000C03 56                  <1>     push esi
  1450 00000C04 BE[5A070000]        <1>     mov  esi,int41msg
  1451 00000C09 E85A010000          <1>     call irq_print_msg
  1452 00000C0E 5E                  <1>     pop  esi
  1453 00000C0F E9A8010000          <1>     jmp  reboot_on_alt_key
  1454                              <1> 
  1455                              <1> align 4
  1456                              <1> int_handler_hw10 :
  1457 00000C14 53                  <1>     push ebx
  1458 00000C15 66BB5061            <1>     mov  bx,('a' << 8) + 40*2
  1459 00000C19 E89BFEFFFF          <1>     call display_irq
  1460 00000C1E 5B                  <1>     pop  ebx
  1461                              <1> 
  1462 00000C1F 56                  <1>     push esi
  1463 00000C20 BE[64070000]        <1>     mov  esi,int42msg
  1464 00000C25 E83E010000          <1>     call irq_print_msg
  1465 00000C2A 5E                  <1>     pop  esi
  1466 00000C2B E98C010000          <1>     jmp  reboot_on_alt_key
  1467                              <1> 
  1468                              <1> align 4
  1469                              <1> int_handler_hw11 :
  1470 00000C30 53                  <1>     push ebx
  1471 00000C31 66BB5262            <1>     mov  bx,('b' << 8) + 41*2
  1472 00000C35 E87FFEFFFF          <1>     call display_irq
  1473 00000C3A 5B                  <1>     pop  ebx
  1474                              <1> 
  1475 00000C3B 56                  <1>     push esi
  1476 00000C3C BE[6E070000]        <1>     mov  esi,int43msg
  1477 00000C41 E822010000          <1>     call irq_print_msg
  1478 00000C46 5E                  <1>     pop  esi
  1479 00000C47 E970010000          <1>     jmp  reboot_on_alt_key
  1480                              <1> 
  1481                              <1> align 4
  1482                              <1> int_handler_hw12 :          ; mouse
  1483 00000C4C 53                  <1>     push ebx
  1484 00000C4D 66BB5463            <1>     mov  bx,('c' << 8) + 42*2
  1485 00000C51 E863FEFFFF          <1>     call display_irq
  1486 00000C56 5B                  <1>     pop  ebx
  1487                              <1> 
  1488 00000C57 56                  <1>     push esi
  1489 00000C58 BE[78070000]        <1>     mov  esi,int44msg
  1490 00000C5D E806010000          <1>     call irq_print_msg
  1491 00000C62 5E                  <1>     pop  esi
  1492 00000C63 E954010000          <1>     jmp  reboot_on_alt_key
  1493                              <1> 
  1494                              <1> align 4
  1495                              <1> int_handler_hw13 :          ; co-processor
  1496 00000C68 53                  <1>     push ebx
  1497 00000C69 66BB5664            <1>     mov  bx,('d' << 8) + 43*2
  1498 00000C6D E847FEFFFF          <1>     call display_irq
  1499 00000C72 5B                  <1>     pop  ebx
  1500                              <1> 
  1501 00000C73 56                  <1>     push esi
  1502 00000C74 BE[82070000]        <1>     mov  esi,int45msg
  1503 00000C79 E8EA000000          <1>     call irq_print_msg
  1504 00000C7E 5E                  <1>     pop  esi
  1505 00000C7F E938010000          <1>     jmp  reboot_on_alt_key
  1506                              <1> 
  1507                              <1> align 4
  1508                              <1> int_handler_hw14 :          ; ata disk controller primary
  1509 00000C84 53                  <1>     push ebx
  1510 00000C85 66BB5865            <1>     mov  bx,('e' << 8) + 44*2
  1511 00000C89 E82BFEFFFF          <1>     call display_irq
  1512 00000C8E 5B                  <1>     pop  ebx
  1513                              <1> 
  1514 00000C8F 56                  <1>     push esi
  1515 00000C90 BE[8C070000]        <1>     mov  esi,int46msg
  1516 00000C95 E8CE000000          <1>     call irq_print_msg
  1517 00000C9A 5E                  <1>     pop  esi
  1518 00000C9B E91C010000          <1>     jmp  reboot_on_alt_key
  1519                              <1> 
  1520                              <1> align 4
  1521                              <1> int_handler_hw15 :          ; ata disk controller secondary
  1522 00000CA0 53                  <1>     push ebx
  1523 00000CA1 66BB5A66            <1>     mov  bx,('f' << 8) + 45*2
  1524 00000CA5 E80FFEFFFF          <1>     call display_irq
  1525 00000CAA 5B                  <1>     pop  ebx
  1526                              <1> 
  1527 00000CAB 56                  <1>     push esi
  1528 00000CAC BE[96070000]        <1>     mov  esi,int47msg
  1529 00000CB1 E8B2000000          <1>     call irq_print_msg
  1530 00000CB6 5E                  <1>     pop  esi
  1531 00000CB7 E900010000          <1>     jmp  reboot_on_alt_key
  1532                              <1> 
  1533                              <1> ; called via the double fault task
  1534                              <1> align 4
  1535                              <1> int_handler_tg_dblflt :
  1536 00000CBC 56                  <1>     push esi
  1537 00000CBD BE[26060000]        <1>     mov  esi,int08msg
  1538 00000CC2 E8A1000000          <1>     call irq_print_msg
  1539 00000CC7 5E                  <1>     pop  esi
  1540 00000CC8 E9EF000000          <1>     jmp  reboot_on_alt_key
  1541                              <1> 
  1542                              <1> ; called via the invalid tss task
  1543 00000CCD 90<rept>            <1> align 4
  1544                              <1> int_handler_tg_invtss :
  1545 00000CD0 56                  <1>     push esi
  1546 00000CD1 BE[51060000]        <1>     mov  esi,int10msg
  1547 00000CD6 E88D000000          <1>     call irq_print_msg
  1548 00000CDB 5E                  <1>     pop  esi
  1549                              <1>     ; FIXME need to go back to previous tss to get ec via that stack
  1550 00000CDC 83C302              <1>     add  ebx,2
  1551 00000CDF 58                  <1>     pop  eax                ; ec == invalid tss selector
  1552 00000CE0 E8C3F7FFFF          <1>     call putx_vga
  1553 00000CE5 E9D2000000          <1>     jmp  reboot_on_alt_key
  1554                              <1> 
  1555 00000CEA 90<rept>            <1> align 4
  1556                              <1> int_handler_spurious :
  1557 00000CEC 56                  <1>     push esi
  1558 00000CED BE[A0070000]        <1>     mov  esi,spuriousmsg
  1559 00000CF2 E871000000          <1>     call irq_print_msg
  1560 00000CF7 5E                  <1>     pop  esi
  1561 00000CF8 CF                  <1>     iret
  1562                              <1> 
  1563 00000CF9 90<rept>            <1> align 4
  1564                              <1> int_handler_apicerr :
  1565 00000CFC 56                  <1>     push esi
  1566 00000CFD BE[AE070000]        <1>     mov  esi,apicerrmsg
  1567 00000D02 E861000000          <1>     call irq_print_msg
  1568 00000D07 5E                  <1>     pop  esi
  1569 00000D08 CF                  <1>     iret
  1570                              <1> 
  1571                              <1> ; serves only to eoi the fixed ipi used for sleep wakeup
  1572 00000D09 90<rept>            <1> align 4
  1573                              <1> wakeup :
  1574 00000D0C 50                  <1>     push eax
  1575 00000D0D 31C0                <1>     xor  eax,eax
  1576 00000D0F A3B000E0FE          <1>     mov  [0xfee000b0],eax    ; lapic eoi
  1577 00000D14 58                  <1>     pop  eax
  1578 00000D15 CF                  <1>     iret
  1579                              <1> 
  1580                              <1> 
  1581 00000D16 90<rept>            <1> align 4
  1582                              <1> ; %if ($ >= 0x8000) bomb
  1583                              <1> sysent :
  1584 00000D18 3D00020000          <1>     cmp  eax,0x0200
  1585 00000D1D 0F84D5020000        <1>     jz   syscall_klog
  1586 00000D23 3D00100000          <1>     cmp  eax,0x1000
  1587 00000D28 0F84DF020000        <1>     jz   syscall_ncpus
  1588 00000D2E 3D00200000          <1>     cmp  eax,0x2000
  1589 00000D33 0F8439030000        <1>     jz   syscall_sleep
  1590 00000D39 3D00210000          <1>     cmp  eax,0x2100
  1591 00000D3E 0F84CF020000        <1>     jz   syscall_new_thread
  1592 00000D44 3D00270000          <1>     cmp  eax,0x2700
  1593 00000D49 0F8458030000        <1>     jz   syscall_request_pmem_access
  1594 00000D4F 3D00FE0000          <1>     cmp  eax,0xfe00
  1595 00000D54 0F84AD020000        <1>     jz   syscall_sipi_vector
  1596 00000D5A BE[BF070000]        <1>     mov  esi,int255msg
  1597 00000D5F E804000000          <1>     call irq_print_msg
  1598 00000D64 31C0                <1>     xor  eax,eax
  1599 00000D66 48                  <1>     dec  eax
  1600 00000D67 CF                  <1>     iret
  1601                              <1> 
  1602                              <1> 
  1603                              <1> ; ---- IRQ support code ---- 
  1604                              <1> 
  1605                              <1> irq_print_msg :
  1606 00000D68 B801000000          <1>     mov  eax,1
  1607 00000D6D 0FC105[E0070000]    <1>     xadd [irq_err_lno],eax
  1608 00000D74 50                  <1>     push eax                ; remember line number
  1609 00000D75 83E003              <1>     and  eax,0x3            ; only four lines
  1610 00000D78 40                  <1>     inc  eax                ; start with line 1
  1611 00000D79 BBA0000000          <1>     mov  ebx,160            ; vga line length
  1612 00000D7E 0FAFC3              <1>     imul eax,ebx
  1613 00000D81 89C3                <1>     mov  ebx,eax
  1614                              <1> 
  1615 00000D83 A0[30030000]        <1>     mov  al,[enabled_lapic]
  1616 00000D88 08C0                <1>     or   al,al
  1617 00000D8A 58                  <1>     pop  eax
  1618 00000D8B 742A                <1>     jz   skip_cpumsg
  1619                              <1> 
  1620 00000D8D 56                  <1>     push esi
  1621 00000D8E 50                  <1>     push eax
  1622 00000D8F BE[9E050000]        <1>     mov  esi,cpumsg
  1623 00000D94 E8E8F6FFFF          <1>     call puts_vga
  1624 00000D99 A12000E0FE          <1>     mov  eax,[0xfee00020]   ; print our apic id
  1625 00000D9E C1E818              <1>     shr  eax,24
  1626 00000DA1 83C030              <1>     add  eax,'0'
  1627 00000DA4 658803              <1>     mov  [gs:ebx],al
  1628 00000DA7 58                  <1>     pop  eax                ; recover line number
  1629 00000DA8 C0E802              <1>     shr  al,2               ; provide a rolling effect for
  1630 00000DAB 240F                <1>     and  al,0xf             ;     unending irq messages
  1631 00000DAD 0C08                <1>     or   al,0x8
  1632 00000DAF 65884301            <1>     mov  [gs:ebx+1],al
  1633 00000DB3 83C304              <1>     add  ebx,4
  1634 00000DB6 5E                  <1>     pop  esi
  1635                              <1> 
  1636                              <1> skip_cpumsg :
  1637 00000DB7 E9C5F6FFFF          <1>     jmp  puts_vga
  1638                              <1> 
  1639                              <1> 
  1640                              <1> reboot_on_alt_key :
  1641                              <1> reboot_on_alt_key_loop :
  1642 00000DBC E460                <1>     in   al,0x60
  1643 00000DBE 3C53                <1>     cmp  al,0x53            ; scan code for the DEL key
  1644 00000DC0 75FA                <1>     jnz  reboot_on_alt_key_loop
  1645                              <1> reboot :
  1646 00000DC2 0F011D[EE0D0000]    <1>     lidt [reboot_idt]       ; restore boot idt (helps qemu ...)
  1647 00000DC9 EA[D00D0000]2800    <1>     jmp  rmcssel:reboot_exit_pmode      ; thankyou hpa
  1648                              <1> reboot_exit_pmode :
  1649                              <1> bits 16
  1650 00000DD0 B83000              <1>     mov  ax,rmdssel
  1651 00000DD3 8ED8                <1>     mov  ds,ax
  1652 00000DD5 8EC0                <1>     mov  es,ax
  1653 00000DD7 8ED0                <1>     mov  ss,ax
  1654 00000DD9 8EE0                <1>     mov  fs,ax
  1655 00000DDB 8EE8                <1>     mov  gs,ax
  1656                              <1> 
  1657 00000DDD 0F20C0              <1>     mov  eax,cr0
  1658 00000DE0 6625FEFFFF7F        <1>     and  eax,0x7ffffffe
  1659 00000DE6 0F22C0              <1>     mov  cr0,eax            ; disable pmode and paging
  1660 00000DE9 EA0000FFFF          <1>     jmp  0xffff:0           ; jump to the warm start vector and
  1661                              <1>                             ; flush the I prefetch queue all at once
  1662                              <1> 
  1663                              <1> reboot_idt :
  1664 00000DEE FFFF                <1>     dw 0xffff
  1665 00000DF0 00000000            <1>     dd 0
  1666                              <1> 
  1667                              <1> 
  1668                              <1> ; ---- IDT initialization table ---- 
  1669                              <1> ;
  1670                              <1> ; One dw (2 bytes per vector) is used which means that all
  1671                              <1> ; int_handler entry points must reside below 0x10000!
  1672                              <1> ;
  1673                              <1> ; And since all int_handler routines are 4 byte aligned,
  1674                              <1> ; the bottom two bits are available to indicate type.
  1675                              <1> ; These bits index into the irq_types table below.
  1676                              <1> 
  1677                              <1> align 4
  1678                              <1> 
  1679                              <1> ; note: these are not gdt/ldt descriptors (see swdev3a 6.11 pg 228)
  1680                              <1> 
  1681 00000DF4 8E                  <1> irq_types   db  0x8e            ; dpl=0 32bit interrupt gate (sets IF flag)
  1682 00000DF5 EE                  <1>             db  0xee            ; dpl=3 32bit app (ring3) interrupt gate
  1683 00000DF6 85                  <1>             db  0x85            ; dpl=0 32bit task gate
  1684 00000DF7 8F                  <1>             db  0x8f            ; dpl=0 32bit trap gate (does not set IF flag)
  1685                              <1> 
  1686                              <1> ; all handlers/selectors are 4 byte aligned - this gives us
  1687                              <1> ; two bits to use to designate 1 of 4 types of idt descriptors ...
  1688                              <1> 
  1689                              <1> irqt_intr   equ 0
  1690                              <1> irqt_app    equ 1
  1691                              <1> irqt_task   equ 2
  1692                              <1> irqt_trap   equ 3
  1693                              <1> 
  1694                              <1> irq_setup_table:
  1695                              <1>     ; cpu defined
  1696 00000DF8 [9B08]              <1>     dw  int_handler_div0      + irqt_trap ; 0
  1697 00000DFA [AF08]              <1>     dw  int_handler_debug     + irqt_trap ; 1
  1698 00000DFC [C008]              <1>     dw  int_handler_nmi       + irqt_intr ; 2
  1699 00000DFE [D108]              <1>     dw  int_handler_brkp      + irqt_app  ; 3
  1700 00000E00 [E508]              <1>     dw  int_handler_ovrflw    + irqt_app  ; 4
  1701 00000E02 [F908]              <1>     dw  int_handler_bound     + irqt_app  ; 5
  1702 00000E04 [0F09]              <1>     dw  int_handler_invop     + irqt_trap ; 6
  1703 00000E06 [1F09]              <1>     dw  int_handler_devna     + irqt_trap ; 7
  1704 00000E08 4200                <1>     dw  tasksel_f08           + irqt_task ; 8   double fault
  1705 00000E0A [2309]              <1>     dw  int_handler_cpsego    + irqt_trap ; 9
  1706 00000E0C 4A00                <1>     dw  tasksel_f10           + irqt_task ; 10  invalid tss
  1707 00000E0E [3309]              <1>     dw  int_handler_segnp     + irqt_trap ; 11
  1708 00000E10 [4309]              <1>     dw  int_handler_stkflt    + irqt_trap ; 12
  1709 00000E12 [6709]              <1>     dw  int_handler_gpf       + irqt_trap ; 13
  1710 00000E14 [480A]              <1>     dw  int_handler_pgflt     + irqt_intr ; 14
  1711 00000E16 0000                <1>     dw  0                                 ; 15  Intel reserved
  1712 00000E18 [730A]              <1>     dw  int_handler_fpuerr    + irqt_trap ; 16
  1713 00000E1A [830A]              <1>     dw  int_handler_algnchk   + irqt_trap ; 17
  1714 00000E1C [970A]              <1>     dw  int_handler_machchk   + irqt_trap ; 18
  1715 00000E1E [AB0A]              <1>     dw  int_handler_simdfpe   + irqt_trap ; 19
  1716 00000E20 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0
  1717 00000E29 000000000000000000- <1>
  1718 00000E32 000000000000        <1>
  1719                              <1>     ; hw defined
  1720                              <1> apic0_irqbase equ ($ - irq_setup_table)/2
  1721 00000E38 [DC0A]              <1>     dw  int_handler_timer     + irqt_intr ; 32  0x20
  1722 00000E3A [140B]              <1>     dw  int_handler_kbd       + irqt_intr ; 33
  1723 00000E3C [400B]              <1>     dw  int_handler_hw02      + irqt_intr ; 34
  1724 00000E3E [5C0B]              <1>     dw  int_handler_hw03      + irqt_intr ; 35
  1725 00000E40 [780B]              <1>     dw  int_handler_hw04      + irqt_intr ; 36
  1726 00000E42 [940B]              <1>     dw  int_handler_hw05      + irqt_intr ; 37
  1727 00000E44 [B00B]              <1>     dw  int_handler_hw06      + irqt_intr ; 38
  1728 00000E46 [CC0B]              <1>     dw  int_handler_hw07      + irqt_intr ; 39
  1729                              <1> apic1_irqbase equ ($ - irq_setup_table)/2
  1730 00000E48 [DC0B]              <1>     dw  int_handler_hw08      + irqt_intr ; 40
  1731 00000E4A [F80B]              <1>     dw  int_handler_hw09      + irqt_intr ; 41
  1732 00000E4C [140C]              <1>     dw  int_handler_hw10      + irqt_intr ; 42
  1733 00000E4E [300C]              <1>     dw  int_handler_hw11      + irqt_intr ; 43
  1734 00000E50 [4C0C]              <1>     dw  int_handler_hw12      + irqt_intr ; 44
  1735 00000E52 [680C]              <1>     dw  int_handler_hw13      + irqt_intr ; 45
  1736 00000E54 [840C]              <1>     dw  int_handler_hw14      + irqt_intr ; 46
  1737 00000E56 [A00C]              <1>     dw  int_handler_hw15      + irqt_intr ; 47  0x2f
  1738                              <1>     ; undefined - hw can expand here
  1739 00000E58 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x30
  1740 00000E61 000000000000000000- <1>
  1741 00000E6A 000000000000000000- <1>
  1742 00000E73 0000000000          <1>
  1743 00000E78 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x40
  1744 00000E81 000000000000000000- <1>
  1745 00000E8A 000000000000000000- <1>
  1746 00000E93 0000000000          <1>
  1747 00000E98 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x50
  1748 00000EA1 000000000000000000- <1>
  1749 00000EAA 000000000000000000- <1>
  1750 00000EB3 0000000000          <1>
  1751 00000EB8 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x60
  1752 00000EC1 000000000000000000- <1>
  1753 00000ECA 000000000000000000- <1>
  1754 00000ED3 0000000000          <1>
  1755 00000ED8 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x70
  1756 00000EE1 000000000000000000- <1>
  1757 00000EEA 000000000000000000- <1>
  1758 00000EF3 0000000000          <1>
  1759 00000EF8 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x80
  1760 00000F01 000000000000000000- <1>
  1761 00000F0A 000000000000000000- <1>
  1762 00000F13 0000000000          <1>
  1763 00000F18 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x90
  1764 00000F21 000000000000000000- <1>
  1765 00000F2A 000000000000000000- <1>
  1766 00000F33 0000000000          <1>
  1767 00000F38 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xa0
  1768 00000F41 000000000000000000- <1>
  1769 00000F4A 000000000000000000- <1>
  1770 00000F53 0000000000          <1>
  1771                              <1>     ; set up cpu thread management tss gates
  1772                              <1>     ; these map 1-to-1 to cpus
  1773                              <1> first_thread_tss_gate equ ($ - irq_setup_table)/2
  1774 00000F58 5A00                <1>     dw  tasksel_u00           + irqt_task
  1775 00000F5A 6A00                <1>     dw  tasksel_u01           + irqt_task
  1776 00000F5C 7A00                <1>     dw  tasksel_u02           + irqt_task
  1777 00000F5E 8A00                <1>     dw  tasksel_u03           + irqt_task
  1778 00000F60 9A00                <1>     dw  tasksel_u04           + irqt_task
  1779 00000F62 AA00                <1>     dw  tasksel_u05           + irqt_task
  1780 00000F64 BA00                <1>     dw  tasksel_u06           + irqt_task
  1781 00000F66 CA00                <1>     dw  tasksel_u07           + irqt_task
  1782                              <1> %ifdef FOO
  1783                              <1>     dw  tasksel_u08           + irqt_task
  1784                              <1>     dw  tasksel_u09           + irqt_task
  1785                              <1>     dw  tasksel_u10           + irqt_task
  1786                              <1>     dw  tasksel_u11           + irqt_task
  1787                              <1>     dw  tasksel_u12           + irqt_task
  1788                              <1>     dw  tasksel_u13           + irqt_task
  1789                              <1>     dw  tasksel_u14           + irqt_task
  1790                              <1>     dw  tasksel_u15           + irqt_task
  1791                              <1> %endif
  1792 00000F68 000000000000000000- <1>     dw                  0,0,0,0,0,0,0,0   ; 0xb0
  1793 00000F71 00000000000000      <1>
  1794 00000F78 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xc0
  1795 00000F81 000000000000000000- <1>
  1796 00000F8A 000000000000000000- <1>
  1797 00000F93 0000000000          <1>
  1798 00000F98 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xd0
  1799 00000FA1 000000000000000000- <1>
  1800 00000FAA 000000000000000000- <1>
  1801 00000FB3 0000000000          <1>
  1802 00000FB8 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     ; 0xe0
  1803 00000FC1 000000000000000000- <1>
  1804 00000FCA 000000000000000000- <1>
  1805 00000FD3 000000              <1>
  1806                              <1> spurious_int equ ($ - irq_setup_table)/2
  1807 00000FD6 [EC0C]              <1>     dw  int_handler_spurious  + irqt_intr
  1808                              <1> apicerr_int equ ($ - irq_setup_table)/2
  1809 00000FD8 [FD0C]              <1>     dw  int_handler_apicerr   + irqt_app
  1810 00000FDA 000000000000000000- <1>     dw    0,0,0,0,0,0,0,0,0,0,0,0,0       ; 0xf0
  1811 00000FE3 000000000000000000- <1>
  1812 00000FEC 0000000000000000    <1>
  1813                              <1>     ; sw defined - expand down if needed
  1814                              <1> wakeup_int equ ($ - irq_setup_table)/2
  1815 00000FF4 [0D0D]              <1>     dw  wakeup                + irqt_app
  1816 00000FF6 [190D]              <1>     dw  sysent                + irqt_app  ; 256  0xff
  1817                              <1> irq_setup_table_size equ ($ - irq_setup_table)/2
  1818                              <1> 
  1819                                  
  1820                                  ; -------- system calls --------
  1821                                  %include "ozsys.asm"
  1822                              <1> ; OZ - A more utopian OS    x86-32 system calls
  1823                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
  1824                              <1> ;
  1825                              <1> ; Copyright (C) 2015  Duane Voth
  1826                              <1> ;
  1827                              <1> ;   This program is free software: you can redistribute it and/or modify
  1828                              <1> ;   it under the terms of the GNU Affero General Public License as
  1829                              <1> ;   published by the Free Software Foundation, either version 3 of the
  1830                              <1> ;   License, or (at your option) any later version.
  1831                              <1> ;
  1832                              <1> ;   This program is distributed in the hope that it will be useful,
  1833                              <1> ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
  1834                              <1> ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1835                              <1> ;   GNU Affero General Public License for more details.
  1836                              <1> ;
  1837                              <1> ;   You should have received a copy of the GNU Affero General Public License
  1838                              <1> ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
  1839                              <1> ;
  1840                              <1> ;
  1841                              <1> ; OZ System Calls  (for ozapps)
  1842                              <1> 
  1843                              <1> bits 32
  1844                              <1> 
  1845                              <1> ;------------------------------------------------------------------
  1846                              <1> ;   syscall_klog : place a message on the vga line reserved for klog  :D
  1847                              <1> ;
  1848                              <1> ;   entry:
  1849                              <1> ;       esi = message address
  1850                              <1> ;   exit:
  1851                              <1> 
  1852                              <1> syscall_klog :
  1853 00000FF8 53                  <1>     push ebx
  1854 00000FF9 BB20030000          <1>     mov  ebx,5 * 160        ; line 6
  1855 00000FFE E87EF4FFFF          <1>     call puts_vga
  1856 00001003 5B                  <1>     pop  ebx
  1857 00001004 31C0                <1>     xor  eax,eax
  1858 00001006 CF                  <1>     iret
  1859                              <1> 
  1860                              <1> ;------------------------------------------------------------------
  1861                              <1> ;   syscall_sipi_vector : get the entry vector for non-boot cpus
  1862                              <1> ;
  1863                              <1> ;   entry:
  1864                              <1> ;   exit:
  1865                              <1> ;       eax = N cpus
  1866                              <1> 
  1867                              <1> syscall_sipi_vector :
  1868 00001007 B800700000          <1>     mov  eax,sipi_vector
  1869 0000100C CF                  <1>     iret
  1870                              <1> 
  1871                              <1> ;------------------------------------------------------------------
  1872                              <1> ;   syscall_ncpus : get how many cpu threads are running
  1873                              <1> ;
  1874                              <1> ;   entry:
  1875                              <1> ;   exit:
  1876                              <1> ;       eax = N cpus
  1877                              <1> 
  1878                              <1> syscall_ncpus :
  1879 0000100D A1[14030000]        <1>     mov  eax,[ncpus]
  1880 00001012 CF                  <1>     iret
  1881                              <1> 
  1882                              <1> ;------------------------------------------------------------------
  1883                              <1> ;   syscall_new_thread : ask for another cpu to execute code in
  1884                              <1> ;                        the current app
  1885                              <1> ;
  1886                              <1> ;   This implementation is quite a bit of a hack - apps can basically
  1887                              <1> ;   commendere any specific non-boot cpu they want ...
  1888                              <1> ;
  1889                              <1> ;   entry:
  1890                              <1> ;       edx = function start address in the app
  1891                              <1> ;       ecx = address of the top of the app's new thread stack
  1892                              <1> ;       ebx = app's new thread index
  1893                              <1> ;   exit:
  1894                              <1> ;       eax = 0 success, -1 failure
  1895                              <1> 
  1896                              <1> syscall_new_thread :
  1897 00001013 09DB                <1>     or   ebx,ebx
  1898 00001015 7459                <1>     jz   new_thread_fail        ; don't get to ask for cpu 0
  1899                              <1> 
  1900 00001017 31C0                <1>     xor  eax,eax
  1901 00001019 A0[30030000]        <1>     mov  al,[enabled_lapic]     ; if the lapics are not enabled,
  1902 0000101E 08C0                <1>     or   al,al                  ; none of this is useful
  1903 00001020 744E                <1>     jz   new_thread_fail
  1904                              <1> 
  1905                              <1>     ; setup the tss
  1906                              <1>     ; slightly squirly - get the tss address from the task selector
  1907                              <1>     ; but there could be a race here: ncpus is updated before
  1908                              <1>     ; create_tss_pair is called, so the task selector could be zero!
  1909                              <1> 
  1910 00001022 89DF                <1>     mov  edi,ebx
  1911 00001024 C1E704              <1>     shl  edi,4                  ; 8 byte selectors in pairs
  1912 00001027 83C758              <1>     add  edi,tasksel_u00
  1913 0000102A 8BB7[02000000]      <1>     mov  esi,[gdt+edi+2]
  1914 00001030 81E6FFFFFF00        <1>     and  esi,0xffffff
  1915 00001036 31C0                <1>     xor  eax,eax
  1916 00001038 8A87[07000000]      <1>     mov  al,[gdt+edi+7]
  1917 0000103E C1E018              <1>     shl  eax,24
  1918 00001041 09C6                <1>     or   esi,eax
  1919 00001043 742B                <1>     jz   new_thread_fail        ; cpu isn't yet ready ...
  1920                              <1> 
  1921                              <1>     ; really should check the previous task link to see if this
  1922                              <1>     ; cpu is busy ...
  1923                              <1> 
  1924 00001045 894E38              <1>     mov  [esi+(tss0_esp-tss0)],ecx  ; set the app's stack
  1925 00001048 895620              <1>     mov  [esi+(tss0_eip-tss0)],edx  ; set the ip to the entry point
  1926                              <1> 
  1927                              <1>     ; lookup the requested cpu's int/taskgate gdt selector
  1928                              <1> 
  1929 0000104B 89DF                <1>     mov  edi,ebx
  1930 0000104D 81C7B0000000        <1>     add  edi,first_thread_tss_gate  ; convert ebx to int/taskgate number
  1931                              <1> 
  1932                              <1>     ; ipi a cpu.  no fancy affinity scheduling yet,
  1933                              <1>     ; just let the app ask for a specific cpu to do the work
  1934                              <1> 
  1935 00001053 B800000001          <1>     mov  eax,0x01000000
  1936 00001058 89D9                <1>     mov  ecx,ebx                    ; recover requested cpu number
  1937 0000105A D3E0                <1>     shl  eax,cl                     ; form the icr destination field
  1938                              <1> 
  1939                              <1>     ; poke the cpu that matches our thread index - we only get 8 :/
  1940                              <1> 
  1941 0000105C A31003E0FE          <1>     mov  dword [0xfee00310],eax
  1942 00001061 B800480000          <1>     mov  eax,0x4800                 ; no shorthand, fixed, logical, edge
  1943 00001066 09F8                <1>     or   eax,edi                    ; make int/taskgate number the vector
  1944 00001068 A30003E0FE          <1>     mov  dword [0xfee00300],eax
  1945                              <1> 
  1946 0000106D 31C0                <1>     xor  eax,eax
  1947 0000106F CF                  <1>     iret
  1948                              <1> 
  1949                              <1> new_thread_fail :
  1950 00001070 48                  <1>     dec  eax                    ; -1
  1951 00001071 C3                  <1>     ret
  1952                              <1> 
  1953                              <1> ;------------------------------------------------------------------
  1954                              <1> ;   syscall_sleep : wait for N timer interrupts
  1955                              <1> ;
  1956                              <1> ;   entry:
  1957                              <1> ;       edx = N ticks
  1958                              <1> ;   exit:
  1959                              <1> 
  1960                              <1> syscall_sleep :
  1961 00001072 A0[30030000]        <1>     mov  al,[enabled_lapic]
  1962 00001077 08C0                <1>     or   al,al
  1963 00001079 7415                <1>     jz   sleep_loop
  1964                              <1> 
  1965 0000107B A12000E0FE          <1>     mov  eax,[0xfee00020]
  1966 00001080 C1E818              <1>     shr  eax,24
  1967 00001083 09C0                <1>     or   eax,eax
  1968 00001085 7409                <1>     jz   sleep_loop         ; the boot cpu services the timer int
  1969 00001087 88C1                <1>     mov  cl,al              ; so don't add it to the sleeper list
  1970 00001089 B801000000          <1>     mov  eax,1
  1971 0000108E D3E0                <1>     shl  eax,cl
  1972                              <1> 
  1973                              <1> sleep_loop :
  1974 00001090 F00905[1C030000]    <1>     lock or [sleepers],eax  ; announce we are sleeping
  1975 00001097 FB                  <1>     sti
  1976 00001098 F4                  <1>     hlt                     ; wait for an int to wake us up
  1977 00001099 4A                  <1>     dec  edx                ; decrement the tick count
  1978 0000109A 75F4                <1>     jnz  sleep_loop
  1979                              <1> 
  1980 0000109C 83F0FF              <1>     xor  eax,-1
  1981 0000109F F02105[1C030000]    <1>     lock and [sleepers],eax ; renounce sleepiness
  1982 000010A6 CF                  <1>     iret
  1983                              <1> 
  1984                              <1> ;------------------------------------------------------------------
  1985                              <1> ;   syscall_request_pmem_access : ask for access to a physical
  1986                              <1> ;            memory address
  1987                              <1> ;
  1988                              <1> ;   entry:
  1989                              <1> ;       edx = phys memory address
  1990                              <1> ;
  1991                              <1> ;   exit:
  1992                              <1> ;       (need to return a logical address in eax)  For now just
  1993                              <1> ;       direct maps the physical address into logical addr space.
  1994                              <1> 
  1995                              <1> syscall_request_pmem_access :
  1996 000010A7 E801000000          <1>     call map_pmem
  1997 000010AC CF                  <1>     iret
  1998                              <1> 
  1999                              <1> ;------------------------------------------------------------------
  2000                              <1> ;   map_pmem - add entries to the current page directory/table
  2001                              <1> ;              to direct map the requested physical memory address
  2002                              <1> ;              (logical identical to physical for now)
  2003                              <1> ;
  2004                              <1> ;   entry:
  2005                              <1> ;       edx = phys memory address
  2006                              <1> ;
  2007                              <1> ;   returns:
  2008                              <1> ;       (need to return a logical address in eax)  For now just
  2009                              <1> ;       direct maps the physical address into logical addr space.
  2010                              <1> ;       eax =  0 success
  2011                              <1> ;       eax = -1 fail
  2012                              <1> 
  2013                              <1> map_pmem :
  2014 000010AD 53                  <1>     push ebx
  2015 000010AE 57                  <1>     push edi
  2016                              <1> 
  2017 000010AF 0F013A              <1>     invlpg [edx]
  2018 000010B2 52                  <1>     push edx
  2019 000010B3 0F20DB              <1>     mov  ebx,cr3
  2020 000010B6 81E300F0FFFF        <1>     and  ebx,0xfffff000
  2021 000010BC 89D7                <1>     mov  edi,edx
  2022 000010BE 81E70000C0FF        <1>     and  edi,0xffc00000
  2023 000010C4 C1EF14              <1>     shr  edi,(22 - 2)           ; calc page directory index
  2024 000010C7 81E200F03F00        <1>     and  edx,0x003ff000
  2025 000010CD C1EA0A              <1>     shr  edx,(12 - 2)           ; calc page table index
  2026                              <1> 
  2027 000010D0 8B043B              <1>     mov  eax,[ebx+edi]
  2028 000010D3 09C0                <1>     or   eax,eax                ; is there a page table here?
  2029 000010D5 750F                <1>     jnz  map_pmem_have_pgtbl
  2030 000010D7 E8F7F3FFFF          <1>     call mem_alloc_kernel_page
  2031 000010DC 09C0                <1>     or   eax,eax
  2032 000010DE 741F                <1>     jz   map_pmem_fail
  2033 000010E0 C1E00C              <1>     shl  eax,12                 ; convert pgno to pgtbl entry
  2034 000010E3 89043B              <1>     mov  [ebx+edi],eax          ; update page table
  2035                              <1> 
  2036                              <1> map_pmem_have_pgtbl :
  2037                              <1>     ; for now, no security check, just direct map the address
  2038                              <1>     ; and mark the pages and the page table r/w by all
  2039 000010E6 830C3B07            <1>     or   dword [ebx+edi],7      ; user, r/w, present
  2040                              <1> 
  2041 000010EA 8B1C3B              <1>     mov  ebx,[ebx+edi]
  2042 000010ED 81E300F0FFFF        <1>     and  ebx,0xfffff000
  2043 000010F3 58                  <1>     pop  eax                    ; recover requested phys mem addr
  2044                              <1>     ; FIXME yup, big security hole if called by ring 0! And it is ...
  2045 000010F4 83C807              <1>     or   eax,7                  ; user, r/w, present
  2046 000010F7 890413              <1>     mov  [ebx+edx],eax          ; update page directory
  2047 000010FA 31C0                <1>     xor  eax,eax                ; 0
  2048                              <1> map_pmem_exit :
  2049 000010FC 5F                  <1>     pop  edi
  2050 000010FD 5B                  <1>     pop  ebx
  2051 000010FE C3                  <1>     ret
  2052                              <1> 
  2053                              <1> map_pmem_fail :
  2054 000010FF 48                  <1>     dec  eax                    ; -1
  2055 00001100 EBFA                <1>     jmp  map_pmem_exit
  2056                              <1> 
  2057                                  
  2058 00001102 00<rept>                align 16, db 0
  2059                                  kernel_text_size equ ($-textstart)
  2060                                  
  2061                                  ; ---------------------------------------------------------------------------
  2062                                  section .data
  2063                                  datastart :
  2064                                  
  2065                                  ; -------- descriptors --------------
  2066                                  ; Intel SW dev manual 3a, 3.4.5, pg 103
  2067                                  ;
  2068                                  ; In my opinion, macros for descriptor entries
  2069                                  ; don't make the code that much more readable.
  2070                                  
  2071                                  descriptor_size equ 8
  2072                                  
  2073                                  gdt :
  2074                                  nullsel equ $-gdt           ; nullsel = 0h
  2075 00000000 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
  2076                                  
  2077                                  codesel equ $-gdt           ; codesel = 8h  4Gb flat over all logical mem
  2078 00000008 FFFF                        dw 0xffff               ; limit 0-15
  2079 0000000A 0000                        dw 0x0000               ; base  0-15
  2080 0000000C 00                          db 0x00                 ; base 16-23
  2081 0000000D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  2082 0000000E CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  2083 0000000F 00                          db 0x00                 ; base 24-31
  2084                                  
  2085                                  datasel equ $-gdt           ; datasel = 10h  4Gb flat over all logical mem
  2086 00000010 FFFF                        dw 0xffff               ; limit 0-15
  2087 00000012 0000                        dw 0x0000               ; base  0-15
  2088 00000014 00                          db 0x00                 ; base 16-23
  2089 00000015 92                          db 0x92                 ; present, dpl=0, data r/w
  2090 00000016 CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  2091 00000017 00                          db 0x00                 ; base 24-31
  2092                                  
  2093                                  stacksel equ $-gdt          ; stacksel = 18h  small limited stack
  2094 00000018 FF1F                        dw kstack_size-1        ; limit
  2095 0000001A 0010                        dw kstack_loc           ; base
  2096 0000001C 00                          db 0
  2097 0000001D 92                          db 0x92                 ; present, dpl=0, data, r/w
  2098 0000001E 40                          db 0x40                 ; byte granular, 32bit/8bit
  2099 0000001F 00                          db 0
  2100                                  
  2101                                  videosel equ $-gdt          ; videosel = 20h
  2102 00000020 9F0F                        dw 3999                 ; limit 80*25*2-1
  2103 00000022 0080                        dw 0x8000               ; base 0xb8000
  2104 00000024 0B                          db 0x0b
  2105 00000025 92                          db 0x92                 ; present, dpl=0, data, r/w
  2106 00000026 40                          db 0x40                 ; byte granular, 32bit/8bit
  2107 00000027 00                          db 0
  2108                                  
  2109                                  rmcssel equ $-gdt           ; real mode CS selector = 28h
  2110 00000028 FFFF                        dw 0xffff               ; limit 0-15
  2111 0000002A 0000                        dw 0x0000               ; base  0-15
  2112 0000002C 00                          db 0x00                 ; base 16-23
  2113 0000002D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  2114 0000002E 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  2115 0000002F 00                          db 0x00                 ; base 24-31
  2116                                  
  2117                                  rmdssel equ $-gdt           ; real mode DS selector = 30h
  2118 00000030 FFFF                        dw 0xffff               ; limit 0-15
  2119 00000032 0000                        dw 0x0000               ; base  0-15
  2120 00000034 00                          db 0x00                 ; base 16-23
  2121 00000035 92                          db 0x92                 ; present, dpl=0, data r/w
  2122 00000036 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  2123 00000037 00                          db 0x00                 ; base 24-31
  2124                                  
  2125                                  ldtsel1 equ $-gdt
  2126 00000038 1800                        dw ldt1_len             ; length of the ldt
  2127 0000003A [5001]                      dw ldt1                 ; address of the ldt
  2128 0000003C 00                          db 0
  2129 0000003D 82                          db 0x82                 ; present, dpl=0, ldt
  2130 0000003E 40                          db 0x40                 ; byte granular, 32bit/8bit
  2131 0000003F 00                          db 0
  2132                                  
  2133                                  tasksel_f08 equ $-gdt       ; the double fault task selector
  2134 00000040 6800                        dw tss_len              ; tss length
  2135 00000042 [6801]                      dw tss_f08              ; tss physical address
  2136 00000044 00                          db 0
  2137 00000045 89                          db 0x89                 ; present, dpl=0, tss32
  2138 00000046 40                          db 0x40                 ; byte granular, 32bit/8bit
  2139 00000047 00                          db 0
  2140                                  
  2141                                  tasksel_f10 equ $-gdt       ; the invalid tss task selector
  2142 00000048 6800                        dw tss_len              ; tss length
  2143 0000004A [D001]                      dw tss_f10              ; tss physical address
  2144 0000004C 00                          db 0
  2145 0000004D 89                          db 0x89                 ; present, dpl=0, tss32
  2146 0000004E 40                          db 0x40                 ; byte granular, 32bit/8bit
  2147 0000004F 00                          db 0
  2148                                  
  2149                                  ; there is one kernel thread tss (ring 0) and one user thread tss (ring 1)
  2150                                  ; per cpu.  memory for tss structs for the non-boot cpus are allocated as
  2151                                  ; each non-boot cpu comes online (see create_tss_pair).  tasksel_uXX tss
  2152                                  ; gates are installed in the idt (starting at first_thread_tss_gate),
  2153                                  ; they also map 1-to-1 with cpus.  (the thread is launched via an lapic
  2154                                  ; vectored interrupt that jumps immediately into user space - and to call a
  2155                                  ; task gate from an interrupt requires an existing ring 0 tss to be active)
  2156                                  ; tasksel_uXX tsses are initialized in new_thread.
  2157                                  
  2158                                  tasksel_k00 equ $-gdt
  2159 00000050 6800[3802]00894000                              dw tss_len, tss0, 0x8900, 0x40
  2160                                  tasksel_u00 equ $-gdt
  2161 00000058 6800[A002]00894000                              dw tss_len, tss1, 0x8900, 0x40
  2162                                  tasksel_k01 equ $-gdt
  2163 00000060 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2164                                  tasksel_u01 equ $-gdt
  2165 00000068 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2166                                  tasksel_k02 equ $-gdt
  2167 00000070 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2168                                  tasksel_u02 equ $-gdt
  2169 00000078 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2170                                  tasksel_k03 equ $-gdt
  2171 00000080 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2172                                  tasksel_u03 equ $-gdt
  2173 00000088 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2174                                  tasksel_k04 equ $-gdt
  2175 00000090 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2176                                  tasksel_u04 equ $-gdt
  2177 00000098 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2178                                  tasksel_k05 equ $-gdt
  2179 000000A0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2180                                  tasksel_u05 equ $-gdt
  2181 000000A8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2182                                  tasksel_k06 equ $-gdt
  2183 000000B0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2184                                  tasksel_u06 equ $-gdt
  2185 000000B8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2186                                  tasksel_k07 equ $-gdt
  2187 000000C0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2188                                  tasksel_u07 equ $-gdt
  2189 000000C8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2190                                  tasksel_k08 equ $-gdt
  2191 000000D0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2192                                  tasksel_u08 equ $-gdt
  2193 000000D8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2194                                  tasksel_k09 equ $-gdt
  2195 000000E0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2196                                  tasksel_u09 equ $-gdt
  2197 000000E8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2198                                  tasksel_k10 equ $-gdt
  2199 000000F0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2200                                  tasksel_u10 equ $-gdt
  2201 000000F8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2202                                  tasksel_k11 equ $-gdt
  2203 00000100 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2204                                  tasksel_u11 equ $-gdt
  2205 00000108 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2206                                  tasksel_k12 equ $-gdt
  2207 00000110 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2208                                  tasksel_u12 equ $-gdt
  2209 00000118 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2210                                  tasksel_k13 equ $-gdt
  2211 00000120 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2212                                  tasksel_u13 equ $-gdt
  2213 00000128 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2214                                  tasksel_k14 equ $-gdt
  2215 00000130 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2216                                  tasksel_u14 equ $-gdt
  2217 00000138 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2218                                  tasksel_k15 equ $-gdt
  2219 00000140 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2220                                  tasksel_u15 equ $-gdt
  2221 00000148 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2222                                  
  2223                                  max_threads equ ($-gdt-tasksel_k00)/descriptor_size/2
  2224                                  
  2225                                  gdt_end :
  2226                                  
  2227                                  ; ---------------------
  2228                                  
  2229                                  ldt1 :
  2230                                  nullsel1 equ $-ldt1         ; nullsel1 = 07h
  2231 00000150 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
  2232                                  
  2233                                  codesel1 equ $-ldt1         ; codesel1 = 0fh  4Gb flat over all logical mem
  2234 00000158 FFFF                        dw 0xffff               ; limit 0-15
  2235 0000015A 0000                        dw 0x0000               ; base  0-15
  2236 0000015C 00                          db 0x00                 ; base 16-23
  2237 0000015D FA                          db 0xfa                 ; present, dpl=3, code e/r
  2238 0000015E CF                          db 0xcf                 ; 4k granular, 32bit, limit 16-19
  2239 0000015F 00                          db 0x00                 ; base 24-31
  2240                                  
  2241                                  datasel1 equ $-ldt1         ; datasel1 = 17h  4Gb flat over all logical mem
  2242 00000160 FFFF                        dw 0xffff               ; limit 0-15
  2243 00000162 0000                        dw 0x0000               ; base  0-15
  2244 00000164 00                          db 0x00                 ; base 16-23
  2245 00000165 F2                          db 0xf2                 ; present, dpl=3, data r/w
  2246 00000166 CF                          db 0xcf                 ; 4k granular, 32bit, limit 16-19
  2247 00000167 00                          db 0x00                 ; base 24-31
  2248                                  
  2249                                  ; gcc wants the ds, es, and ss segment registers to match
  2250                                  ;stacksel1 equ $-ldt1        ; stacksel = 1ch  small limited stack
  2251                                  ;    dw 0xffff               ; limit
  2252                                  ;    dw 0x0000               ; base  0-15
  2253                                  ;    db 0x00
  2254                                  ;    db 0xf2                 ; present, dpl=3, data, r/w
  2255                                  ;    db 0                    ; byte granular, 16 bit
  2256                                  ;    db 0
  2257                                  
  2258                                  ldt1_end :
  2259                                  
  2260                                  ldt1_len equ ldt1_end-ldt1
  2261                                  
  2262                                  ; ---------------------
  2263                                  ; the tss that handles double fault exceptions
  2264                                  
  2265                                  tss_f08 :                   ; intel sw 3a 7.6  pg 287 of 756
  2266 00000168 00000000                    dw 0,0                  ; previous task link
  2267 0000016C 005F0000                    dd tss_f08_stk-0x100    ; esp0
  2268 00000170 10000000                    dw datasel,0            ; ss0
  2269 00000174 00000000                    dd 0                    ; esp1
  2270 00000178 00000000                    dw 0,0                  ; ss1
  2271 0000017C 00000000                    dd 0                    ; esp2
  2272 00000180 00000000                    dw 0,0                  ; ss2
  2273                                  tss_f08_cr3 :
  2274 00000184 00000000                    dd 0                    ; cr3
  2275 00000188 [BC0C0000]                  dd int_handler_tg_dblflt ; eip
  2276 0000018C 00000000                    dd 0                    ; eflags
  2277 00000190 00000000                    dd 0                    ; eax
  2278 00000194 00000000                    dd 0                    ; ecx
  2279 00000198 00000000                    dd 0                    ; edx
  2280 0000019C 00000000                    dd 0                    ; ebx
  2281 000001A0 00600000                    dd tss_f08_stk          ; esp
  2282 000001A4 00000000                    dd 0                    ; ebp
  2283 000001A8 00000000                    dd 0                    ; esi
  2284 000001AC 00000000                    dd 0                    ; edi
  2285 000001B0 10000000                    dw datasel,0            ; es
  2286 000001B4 08000000                    dw codesel,0            ; cs
  2287 000001B8 10000000                    dw datasel,0            ; ss
  2288 000001BC 10000000                    dw datasel,0            ; ds
  2289 000001C0 00000000                    dw 0,0                  ; fs
  2290 000001C4 20000000                    dw videosel,0           ; gs
  2291 000001C8 00000000                    dw 0,0                  ; ldt
  2292 000001CC 0000                        dw 0                    ; trap
  2293 000001CE 0000                        dw 0                    ; iomap
  2294                                  
  2295                                  ; ---------------------
  2296                                  ; the tss that handles invalid tss exceptions
  2297                                  
  2298                                  tss_f10 :                   ; intel sw 3a 7.6  pg 287 of 756
  2299 000001D0 00000000                    dw 0,0                  ; previous task link
  2300 000001D4 006F0000                    dd tss_f10_stk-0x100    ; esp0
  2301 000001D8 10000000                    dw datasel,0            ; ss0
  2302 000001DC 00000000                    dd 0                    ; esp1
  2303 000001E0 00000000                    dw 0,0                  ; ss1
  2304 000001E4 00000000                    dd 0                    ; esp2
  2305 000001E8 00000000                    dw 0,0                  ; ss2
  2306                                  tss_f10_cr3 :
  2307 000001EC 00000000                    dd 0                    ; cr3
  2308 000001F0 [D00C0000]                  dd int_handler_tg_invtss ; eip
  2309 000001F4 00000000                    dd 0                    ; eflags
  2310 000001F8 00000000                    dd 0                    ; eax
  2311 000001FC 00000000                    dd 0                    ; ecx
  2312 00000200 00000000                    dd 0                    ; edx
  2313 00000204 00000000                    dd 0                    ; ebx
  2314 00000208 00700000                    dd tss_f10_stk          ; esp
  2315 0000020C 00000000                    dd 0                    ; ebp
  2316 00000210 00000000                    dd 0                    ; esi
  2317 00000214 00000000                    dd 0                    ; edi
  2318 00000218 10000000                    dw datasel,0            ; es
  2319 0000021C 08000000                    dw codesel,0            ; cs
  2320 00000220 10000000                    dw datasel,0            ; ss
  2321 00000224 10000000                    dw datasel,0            ; ds
  2322 00000228 00000000                    dw 0,0                  ; fs
  2323 0000022C 20000000                    dw videosel,0           ; gs
  2324 00000230 00000000                    dw 0,0                  ; ldt
  2325 00000234 0000                        dw 0                    ; trap
  2326 00000236 0000                        dw 0                    ; iomap
  2327                                  
  2328                                  ; ---------------------
  2329                                  ; tss0 and tss1 are cpu0's pair
  2330                                  
  2331                                  tss0 :                      ; intel swdev3a 7.6  pg 287 of 756
  2332 00000238 00000000                    dw 0,0                  ; previous task link
  2333                                  tss0_esp0 :
  2334 0000023C 00000000                    dd 0                    ; esp0
  2335                                  tss0_ss0 :
  2336 00000240 00000000                    dw 0,0                  ; ss0
  2337 00000244 00000000                    dd 0                    ; esp1
  2338 00000248 00000000                    dw 0,0                  ; ss1
  2339 0000024C 00000000                    dd 0                    ; esp2
  2340 00000250 00000000                    dw 0,0                  ; ss2
  2341                                  tss0_cr3 :
  2342 00000254 00000000                    dd 0                    ; cr3
  2343                                  tss0_eip :
  2344 00000258 00000000                    dd 0                    ; eip
  2345 0000025C 00000000                    dd 0                    ; eflags
  2346                                  tss0_eax :
  2347 00000260 00000000                    dd 0                    ; eax
  2348 00000264 00000000                    dd 0                    ; ecx
  2349 00000268 00000000                    dd 0                    ; edx
  2350 0000026C 00000000                    dd 0                    ; ebx
  2351                                  tss0_esp :
  2352 00000270 00000000                    dd 0                    ; esp
  2353 00000274 00000000                    dd 0                    ; ebp
  2354 00000278 00000000                    dd 0                    ; esi
  2355 0000027C 00000000                    dd 0                    ; edi
  2356                                  tss0_es :
  2357 00000280 00000000                    dw 0,0                  ; es
  2358                                  tss0_cs :
  2359 00000284 00000000                    dw 0,0                  ; cs
  2360                                  tss0_ss :
  2361 00000288 00000000                    dw 0,0                  ; ss
  2362                                  tss0_ds :
  2363 0000028C 00000000                    dw 0,0                  ; ds
  2364 00000290 00000000                    dw 0,0                  ; fs
  2365 00000294 20000000                    dw videosel,0           ; gs
  2366                                  tss0_ldt :
  2367 00000298 00000000                    dw 0,0                  ; ldt
  2368 0000029C 0000                        dw 0                    ; trap
  2369 0000029E 0000                        dw 0                    ; iomap
  2370                                  tss0_end :
  2371                                  
  2372                                  tss_len equ tss0_end-tss0
  2373                                  
  2374                                  ; user tss
  2375                                  
  2376                                  tss1 :                      ; intel sw 3a 7.6  pg 287 of 756
  2377 000002A0 00000000                    dw 0,0                  ; previous task link
  2378                                  tss1_esp0 :
  2379 000002A4 00000000                    dd 0                    ; esp0  (int and irq support)
  2380 000002A8 18000000                    dw stacksel,0           ; ss0   (filled in when running init apps)
  2381 000002AC 00000000                    dd 0                    ; esp1
  2382 000002B0 00000000                    dw 0,0                  ; ss1
  2383 000002B4 00000000                    dd 0                    ; esp2
  2384 000002B8 00000000                    dw 0,0                  ; ss2
  2385                                  tss1_cr3 :
  2386 000002BC 00000000                    dd 0                    ; cr3
  2387                                  tss1_eip :
  2388 000002C0 00000000                    dd 0                    ; eip
  2389 000002C4 00000000                    dd 0                    ; eflags
  2390 000002C8 00000000                    dd 0                    ; eax
  2391 000002CC 00000000                    dd 0                    ; ecx
  2392 000002D0 00000000                    dd 0                    ; edx
  2393 000002D4 00000000                    dd 0                    ; ebx
  2394 000002D8 00000000                    dd 0                    ; esp
  2395 000002DC 00000000                    dd 0                    ; ebp
  2396 000002E0 00000000                    dd 0                    ; esi
  2397 000002E4 00000000                    dd 0                    ; edi
  2398 000002E8 17000000                    dw datasel1+7,0         ; es
  2399 000002EC 0F000000                    dw codesel1+7,0         ; cs
  2400 000002F0 17000000                    dw datasel1+7,0         ; ss
  2401 000002F4 17000000                    dw datasel1+7,0         ; ds
  2402 000002F8 00000000                    dw 0,0                  ; fs
  2403 000002FC 00000000                    dw 0,0                  ; gs
  2404 00000300 3B000000                    dw ldtsel1+3,0          ; ldt
  2405 00000304 0000                        dw 0                    ; trap
  2406 00000306 0000                        dw 0                    ; iomap
  2407                                  
  2408                                  ; ---------------------
  2409                                  
  2410                                  gdtr :
  2411 00000308 4F01                        dw gdt_end - gdt - 1    ; gdt length
  2412 0000030A [00000000]                  dd gdt                  ; gdt physical address
  2413                                  
  2414                                  idtr :
  2415                                      ; irq_setup_table_size == the number of gates in the idt
  2416 0000030E FF07                        dw irq_setup_table_size * 8 - 1     ; idt limit (should be 2k)
  2417                                  idtr_addr :
  2418 00000310 00000000                    dd 0                                ; address of the idt
  2419                                  
  2420 00000314 00000000                ncpus           dd 0        ; number of running cpus
  2421                                  
  2422 00000318 00000000                next_free_page  dd 0        ; initialized after page tables are setup
  2423                                  
  2424 0000031C 0000000000000000        sleepers        dq 0        ; one bit per cpu
  2425                                  
  2426 00000324 00000000                pgdirp          dd 0
  2427 00000328 00000000                pgtb0p          dd 0
  2428 0000032C 00000000                pgtb1p          dd 0
  2429                                  
  2430 00000330 00                      enabled_lapic   db 0        ; set to 1 if an lapic is present and in use
  2431                                  
  2432 00000331 AA55                    dbgwall         db 0xaa,0x55
  2433                                  
  2434 00000333 00<rept>                align 16, db 0
  2435                                  kernel_data_size equ ($-datastart)
  2436                                  
  2437                                  
  2438                                  ; ---------------------
  2439                                  ; Need to align to a physical page boundary here so that appended init apps
  2440                                  ; are always page aligned.  The problem is our text section starts 1k below
  2441                                  ; a page boundary, and so an 'align 4096' doesn't match up with physical
  2442                                  ; memory.
  2443                                  
  2444                                  ; Add larger tests here if the times expression turns up negative, to make
  2445                                  ; the kernel image size right, but your next problem will be that the boot
  2446                                  ; loader will likely refuse to load all these sectors during stage2.
  2447                                  
  2448                                  section .fill
  2449                                  
  2450                                  fill :
  2451                                  
  2452                                  %if total_size > 4096+1024
  2453 00000000 00<rept>                    times (4096+4096+1024-total_size) db 0
  2454                                  %elif total_size > 1024
  2455                                      times (4096+1024-total_size) db 0
  2456                                  %endif
  2457                                  
  2458                                  kend :
  2459                                  
