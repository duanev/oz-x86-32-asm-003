     1                                  ; OZ - A more utopian OS   x86-32 startup
     2                                  ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
     3                                  ;
     4                                  ; Copyright (C) 2015  Duane Voth
     5                                  ;
     6                                  ;   This program is free software: you can redistribute it and/or modify
     7                                  ;   it under the terms of the GNU Affero General Public License as
     8                                  ;   published by the Free Software Foundation, either version 3 of the
     9                                  ;   License, or (at your option) any later version.
    10                                  ;
    11                                  ;   This program is distributed in the hope that it will be useful,
    12                                  ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
    13                                  ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    14                                  ;   GNU Affero General Public License for more details.
    15                                  ;
    16                                  ;   You should have received a copy of the GNU Affero General Public License
    17                                  ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
    18                                  ;
    19                                  ;
    20                                  ;
    21                                  ; usage:
    22                                  ;	$ qemu-system-i386 -boot a -fda oz_fd -monitor stdio
    23                                  ;
    24                                  ; requires: nasm-2.07  or later from: http://www.nasm.us
    25                                  ;
    26                                  ; credits:
    27                                  ;       many thanks to the folks at wiki.osdev.org who archive great info.
    28                                  ;
    29                                  ; contributors:
    30                                  ;        djv - Duane Voth
    31                                  ;
    32                                  ; history:
    33                                  ; 2007/03/03 - 0.00.01 - djv - begin with various web examples
    34                                  ;                      http://linuxgazette.net/issue82/misc/raghu/code.asm.txt
    35                                  ;                      http://www.osdever.net/tutorials/brunmar/simple_asm.txt
    36                                  ; 2007/03/04 - 0.00.02 - djv - add timer interrupt support with stray int dbg
    37                                  ; 2007/03/05 - 0.00.03 - djv - remove stray int dbg, add mbr data struc back
    38                                  ; 2007/03/11 - 0.00.04 - djv - debug USB boot problem
    39                                  ; 2007/03/28 - 0.01.00 - djv - add a real-mode stage2 loader in the mbr to
    40                                  ;                              load the sectors past the mbr on the boot
    41                                  ;                              device into the memory behind the mbr.  so even
    42                                  ;                              tho the read from the device happens in two
    43                                  ;                              parts, memory contains a linear image of the
    44                                  ;                              first few sectors of the boot device.
    45                                  ; 2009/02/01 - 0.02.00 - djv - begin to define application and dynamic library
    46                                  ;                              binary formats with headers detailing size and
    47                                  ;                              entry points.
    48                                  ; 2009/08/01 - 0.03.00 - djv - create the OZ app execution container using
    49                                  ;                              TSSes, paging, and rings 0 and 3.  begin to
    50                                  ;                              play with system calls.
    51                                  ; 2015/10/26 - 0.03.01 - djv - cleanup, add smp usermode tss structs, sleep,
    52                                  ;                              wakeup, and ipi for user thread creation.
    53                                  
    54                                  %ifdef USB
    55                                  [map symbols oz_usb.map]
    56                                  %else
    57                                  [map symbols oz_fd.map]
    58                                  %endif
    59                                  
    60                                  ; -------- stage 1 ---------------------------------------------------------
    61                                  ; A classic x86 Master Boot Record
    62                                  
    63                                  section .text start=0x7c00  ; PC BIOS boot loader entry point
    64                                  textstart :
    65                                  
    66                                  bios_entry :
    67 00000000 FA                          cli
    68 00000001 EA[2400]0000                jmp 0:load_stage2       ; load cs, skip over mbr data struct
    69                                  
    70                                  times 6-($-$$)  db 0
    71 00000006 6F7A                    oemid db "oz"
    72                                  
    73 00000008 00<rept>                times 11-($-$$)  db 0
    74                                  
    75                                  ; compute the size of the kernel image in 512 byte sectors
    76                                  total_size equ (kernel_text_size + kernel_data_size)
    77                                  kisectors  equ (total_size)/512 + (APP_SIZE + 512)/512
    78                                  ; compute the end of the kernel image (with apps attached)
    79                                  kilast equ 0x7c00 + kisectors * 512
    80                                  
    81                                  ; MS MBR  (http://support.microsoft.com/kb/140418)
    82                                  %ifdef FLOPPY
    83 0000000B 0002                        dw 512                  ; Bytes per sector
    84 0000000D 01                          db 1                    ; Sectors per cluster
    85 0000000E 3A00                        dw kisectors            ; Number of reserved sectors
    86 00000010 02                          db 2                    ; Number of FATs
    87 00000011 E000                        dw 0x00e0               ; Number of dirs in root
    88 00000013 400B                        dw 0x0b40               ; Number of sectors in volume
    89 00000015 F0                          db 0xf0                 ; Media descriptor
    90 00000016 0900                        dw 9                    ; Number of sectors per FAT
    91 00000018 1200                        dw 18                   ; Number of sectors per track
    92 0000001A 0200                        dw 2                    ; Number of heads
    93 0000001C 00000000                    dd 0                    ; Number of hidden sectors
    94 00000020 00000000                    dd 0                    ; Large Sectors
    95                                  %endif
    96                                  
    97                                  %ifdef USB
    98                                      dw 0                    ; Bytes per sector
    99                                      db 0                    ; Sectors per cluster
   100                                      dw kisectors            ; Number of reserved sectors
   101                                      db 0                    ; Number of FATs
   102                                      dw 0                    ; Number of dirs in root
   103                                      dw 0                    ; Number of sectors in volume
   104                                      db 0                    ; Media descriptor
   105                                      dw 0                    ; Number of sectors per FAT
   106                                      dw 0                    ; Number of sectors per track
   107                                      dw 0                    ; Number of heads
   108                                      dd 0                    ; Number of hidden sectors
   109                                      dd 0                    ; Large Sectors
   110                                  %endif
   111                                  
   112                                  ; -------- stage 2 loader ------------
   113                                  bits 16
   114                                  alignb 2
   115                                  
   116                                  load_stage2 :
   117 00000024 B80030                      mov  ax,kstack_loc+kstack_size
   118 00000027 89C4                        mov  sp,ax
   119 00000029 31C0                        xor  ax,ax
   120 0000002B 8ED0                        mov  ss,ax
   121 0000002D 8EC0                        mov  es,ax
   122 0000002F 8ED8                        mov  ds,ax
   123 00000031 8EE0                        mov  fs,ax
   124 00000033 8EE8                        mov  gs,ax
   125 00000035 FC                          cld
   126                                  
   127                                      ; debug - pattern the stack so we can see what gets used
   128 00000036 66B811111111                mov  eax,0x11111111
   129 0000003C BF0010                      mov  di,kstack_loc
   130 0000003F B90008                      mov  cx,kstack_size/4
   131 00000042 F366AB                      rep stosd
   132                                  
   133 00000045 52                          push dx                 ; save BIOS drive number
   134                                  
   135 00000046 B80006                      mov  ax,0x0600          ; ah=06h : scroll window up, if al = 0 clrscr
   136 00000049 B90000                      mov  cx,0x0000          ; clear window from 0,0 
   137 0000004C BA4F17                      mov  dx,0x174f          ; to 23,79
   138 0000004F B70F                        mov  bh,0xf             ; fill with hi white
   139 00000051 CD10                        int  0x10               ; clear screen for direct writes to video memory
   140                                  
   141 00000053 BE[C600]                    mov  si,bootmsg
   142 00000056 31DB                        xor  bx,bx
   143 00000058 E85700                      call puts_vga_rm
   144                                                              ; puts_vga_rm leaves gs pointing at video mem
   145 0000005B 65C60601000E                mov  byte [gs:1],0xE    ; turn the first two chars yellow
   146 00000061 65C60603000E                mov  byte [gs:3],0xE
   147                                  
   148                                      ;F - white              
   149                                      ;E - yellow             
   150                                      ;D - magenta            
   151                                      ;C - red                
   152                                      ;B - cyan               
   153                                      ;A - green              
   154                                      ;9 - blue               
   155                                      ;8 - dark grey          
   156                                  
   157 00000067 A1[0002]                    mov  ax,[stage2]        ; check the signature byte
   158 0000006A 0306[0202]                  add  ax,[stage2+2]      ; stage2 might already have been loaded
   159 0000006E 3DA17A                      cmp  ax,0x7a6f+0x32
   160 00000071 741D                        jz   stage2_present
   161                                  
   162                                      ; -------- stage2 boot loader --------
   163                                  
   164                                      ; Assume that the kernel is smaller than whatever space
   165                                      ; is provided prior to file system data structures on the
   166                                      ; boot device, and that it can immediately follow the MBR.
   167                                  
   168 00000073 B402                        mov  ah,02h
   169 00000075 B03A                        mov  al,kisectors       ; number of sectors to load
   170 00000077 BB[0002]                    mov  bx,stage2
   171 0000007A B90200                      mov  cx,2
   172 0000007D 5A                          pop  dx                 ; recover BIOS drive number
   173 0000007E 0E                          push cs
   174 0000007F 07                          pop  es
   175 00000080 CD13                        int  13h
   176 00000082 7211                        jc   ioerr
   177                                  
   178                                      ; ---- make sure second stage actually got loaded
   179                                  
   180 00000084 A1[0002]                    mov  ax,[stage2]        ; check the signature byte
   181 00000087 0306[0202]                  add  ax,[stage2+2]
   182 0000008B 3DA17A                      cmp  ax,0x7a6f+0x32
   183 0000008E 750A                        jnz  s2err
   184                                  stage2_present :
   185 00000090 EA[0902]0000                jmp  0:start_stage2     ; use an absolute jump so stage 1
   186                                                              ; can be position independent
   187                                  
   188                                  ioerr :                     ; ah has status...
   189 00000095 BE[F600]                    mov  si,ioerrmsg
   190 00000098 EB03                        jmp  print_err
   191                                  
   192                                  s2err :
   193 0000009A BE[E000]                    mov  si,s2errmsg
   194                                  print_err :
   195 0000009D BBA000                      mov  bx,160
   196 000000A0 E80F00                      call puts_vga_rm
   197 000000A3 65C60601000C                mov  byte [gs:1],0xC    ; turn the first two vga chars red
   198 000000A9 65C60603000C                mov  byte [gs:3],0xC
   199                                  
   200                                  hang :
   201 000000AF F4                          hlt
   202 000000B0 EBFD                        jmp  hang
   203                                  
   204                                  ; ----------------------------
   205                                  ;   puts_vga_rm - write a null delimited string to the VGA controller
   206                                  ;                 in real mode
   207                                  ;
   208                                  ;    enter:
   209                                  ;            esi - address of string
   210                                  ;            ebx - screen location (2 bytes per char, 160 bytes per line)
   211                                  ;    exit:
   212                                  ;            eax - destroyed
   213                                  ;             gs - set to video memory selector
   214                                  
   215                                  puts_vga_rm :
   216 000000B2 B800B8                      mov  ax,0xb800      ; point gs at video memory
   217 000000B5 8EE8                        mov  gs,ax          
   218                                  puts_vga_rm_loop :
   219 000000B7 AC                          lodsb
   220 000000B8 3C00                        cmp  al,0
   221 000000BA 7409                        jz   puts_vga_rm_done
   222 000000BC 658807                      mov  [gs:bx],al
   223 000000BF 6683C302                    add  ebx,2
   224 000000C3 EBF2                        jmp  puts_vga_rm_loop
   225                                  puts_vga_rm_done :
   226 000000C5 C3                          ret
   227                                  
   228 000000C6 4F5A2076302E30332E-     bootmsg     db      "OZ v0.03.01 - 2015/10/26 ",0
   229 000000CF 3031202D2032303135-
   230 000000D8 2F31302F32362000   
   231 000000E0 73746167652032206C-     s2errmsg    db      "stage 2 load failure ",0
   232 000000E9 6F6164206661696C75-
   233 000000F2 72652000           
   234 000000F6 692F6F206572726F72-     ioerrmsg    db      "i/o error loading stage 2 ",0
   235 000000FF 206C6F6164696E6720-
   236 00000108 737461676520322000 
   237                                  
   238 00000111 00<rept>                times 446-($-$$) db 0       ; fill with zeros up to partition table
   239                                  
   240                                  ; If the kernel is loaded from a disk (including usb) the MBR
   241                                  ; must include a partition table based on the device geometry.
   242                                  ; This gets fed into oz.asm here via usbptbl.inc
   243                                  %ifdef USB
   244                                  %include "usbptbl.inc"
   245                                  %else
   246                                      ; If the kernel is placed in memory by some other means
   247                                      ; (PXE, pxelinux, etc.) the partition table is irrelevant
   248                                      ; but the space is still required.  Make the default ptbl
   249                                      ; match a 1.44MB floppy.
   250 000001BE 800101000601124F            db 0x80,0x01,0x01,0x00,0x06,0x01,0x12,0x4f
   251 000001C6 120000002E0B0000            db 0x12,0x00,0x00,0x00,0x2e,0x0b,0x00,0x00
   252 000001CE 000000000000000000-         db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   253 000001D7 00000000000000     
   254 000001DE 000000000000000000-         db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   255 000001E7 00000000000000     
   256 000001EE 000000000000000000-         db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   257 000001F7 00000000000000     
   258                                  %endif
   259                                  
   260                                  %ifdef NEWUSB
   261                                  new usb?  gpt correct?
   262                                  0000 01B0: 00 00 00 00 00 2C 44 63  E0 36 03 00 00 00 80 20  .....,Dc .6.....
   263                                  0000 01C0: 21 00 83 9D 11 4C 00 08  00 00 00 C0 12 00 00 9D  !....L.. ........
   264                                  0000 01D0: 12 4C 83 57 25 F2 00 C8  12 00 00 A0 28 00 00 00  .L.W%... ....(...
   265                                  0000 01E0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ........ ........
   266                                  0000 01F0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 AA  ........ ......U.
   267                                  %endif
   268                                  
   269                                  
   270                                  times 510-($-$$) db 0       ; fill with zeros up to MBR signature
   271                                  
   272 000001FE 55AA                                dw 0x0aa55      ; write aa55 in bytes 511,512 to indicate
   273                                                              ; that it is a boot sector. 
   274                                  
   275                                  ; end of MBR
   276                                  ;
   277                                  ; -------- stage 2 ---------------------------------------------------------
   278                                  ;
   279                                  ; If a boot loader only loads 512 bytes in the first pass, the following
   280                                  ; code won't appear in memory until the code above has completed.  Other
   281                                  ; loaders however can load the entire OZ kernel image into memory in one
   282                                  ; shot. (pxe)
   283                                  
   284                                  bits 16
   285                                  
   286                                  stage2 :
   287 00000200 6F7A3200                    db "oz2",0                      ; stage2 signature
   288                                  
   289                                  non_boot_cpu_ljmp_instruction :     ; place this in 16 bit code land
   290 00000204 EA00000000                  jmp word 0:0                    ; so we get the right opcode
   291                                  
   292                                  ; adjust this if you want to change the supported number of cpus
   293                                  max_ncpus_l2   equ 7        ; log2(max_ncpus) (128 => 7)
   294                                  
   295                                  ; adjust this to change the total stack size for all cpus
   296                                  kstack_size_l2 equ 13       ; log2 stack space for all cpus (13 => 8k)
   297                                  
   298                                  kstack_size    equ (1 << kstack_size_l2)
   299                                  
   300                                  ; adjust these if you want to move things around
   301                                  kstack_loc  equ 0x1000      ; base for cpu stacks
   302                                  tss_f08_stk equ 0x6000      ; stack for double fault (grows down from ...)
   303                                  tss_f10_stk equ 0x7000      ; stack for tss fault (grows down from ...)
   304                                  sipi_vector equ 0x7000      ; where the non-boot cpus will start
   305                                  
   306                                  ; ---------------------
   307                                  
   308                                  start_stage2 :
   309                                  
   310                                      ; ---- initialize the 8259's while in real mode
   311                                  
   312 00000209 E8D805                      call irq_init_hardware
   313                                  
   314                                  ; ------------ main kernel entry point ------------
   315                                  ; all cpus enter here
   316                                  main :
   317 0000020C FA                          cli                     ; appears to stabilize recent machines a bit
   318                                  
   319                                      ; -------- enter protected mode --------
   320                                  
   321 0000020D 0F0116[0803]                lgdt [gdtr]             ; initialize the gdt
   322 00000212 0F20C0                      mov  eax,cr0
   323 00000215 0C21                        or   al,0x21            ; set the protected mode bit (lsb of cr0)
   324 00000217 0F22C0                      mov  cr0,eax            ;   and enable the native FPU exceptions ...
   325 0000021A EA[1F02]0800                jmp  codesel:flush_ip1  ; flush the cpu instruction pipeline
   326                                  flush_ip1: 
   327                                  bits 32                     ; instructions after this point are 32bit
   328                                  
   329 0000021F 66B81000                    mov  ax,datasel
   330 00000223 8ED8                        mov  ds,ax              ; initialize the data segments
   331 00000225 8EC0                        mov  es,ax
   332                                  
   333 00000227 B801000000                  mov  eax,1
   334 0000022C 0FC105[14030000]            xadd [ncpus],eax        ; get our unique cpu number
   335                                                              ; could use the lapic id if available
   336 00000233 89C6                        mov  esi,eax
   337 00000235 66B81800                    mov  ax,stacksel        ; setup a restricted stack segment
   338 00000239 8ED0                        mov  ss,ax
   339 0000023B BC00200000                  mov  esp,kstack_size    ; start at the top of the reserved stack space
   340 00000240 89F0                        mov  eax,esi
   341 00000242 C1E006                      shl  eax,(kstack_size_l2 - max_ncpus_l2)    ; kstack_size/max_ncpus * cpu#
   342 00000245 29C4                        sub  esp,eax            ; divvy up the stack
   343                                  
   344 00000247 89F0                        mov  eax,esi
   345 00000249 50                          push eax                ; save cpu index
   346 0000024A 89C3                        mov  ebx,eax
   347 0000024C 80C330                      add  bl,'0'             ; boot cpu announces via ascii 0
   348 0000024F BF9E000000                  mov  edi,160-2          ; last chracter on first line of vga
   349 00000254 D1E0                        shl  eax,1
   350 00000256 29C7                        sub  edi,eax
   351 00000258 66B82000                    mov  ax,videosel        ; point gs at video memory
   352 0000025C 8EE8                        mov  gs,ax
   353 0000025E 65881F                      mov  [gs:edi],bl        ; announce cpu presence
   354 00000261 58                          pop  eax
   355                                  
   356 00000262 09C0                        or   eax,eax            ; are we the boot cpu?
   357 00000264 0F8FD4010000                jg   non_boot_init      ; if not, do non_boot_init
   358                                  
   359                                      ; ---- establish a "pool" of free pyhsical memory
   360                                  
   361 0000026A B810000000                  mov  eax,((kilast+0x1000) >> 12)    ; include a buffer zone
   362 0000026F A3[18030000]                mov  [next_free_page],eax
   363                                  
   364                                      ; ---- setup the paging tables
   365                                  
   366 00000274 E85A020000                  call mem_alloc_kernel_page  ; get a page for pgdir
   367 00000279 C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   368 0000027C 89C7                        mov  edi,eax
   369 0000027E A3[24030000]                mov  [pgdirp],eax
   370 00000283 A3[84010000]                mov  [tss_f08_cr3],eax
   371 00000288 A3[EC010000]                mov  [tss_f10_cr3],eax
   372 0000028D A3[54020000]                mov  [tss0_cr3],eax
   373 00000292 A3[BC020000]                mov  [tss1_cr3],eax
   374 00000297 E837020000                  call mem_alloc_kernel_page  ; get a page for pgtb0
   375 0000029C C1E00C                      shl  eax,12
   376 0000029F 89C2                        mov  edx,eax
   377 000002A1 A3[28030000]                mov  [pgtb0p],eax
   378 000002A6 E828020000                  call mem_alloc_kernel_page  ; get a page for pgtb1
   379 000002AB C1E00C                      shl  eax,12
   380 000002AE 89C1                        mov  ecx,eax
   381 000002B0 A3[2C030000]                mov  [pgtb1p],eax
   382                                  
   383                                              ; first the page directory
   384                                  
   385 000002B5 0F22DF                      mov  cr3,edi            ; install the page directory
   386 000002B8 89D0                        mov  eax,edx
   387 000002BA 83C007                      add  eax,7              ; page table 0: present, pl=3, r/w
   388 000002BD AB                          stosd                   ; ... pl=3 for now (simplify vga access)
   389 000002BE 89C8                        mov  eax,ecx
   390 000002C0 83C007                      add  eax,7              ; page table 1: present, pl=3, r/w
   391 000002C3 AB                          stosd                   ; ... app memory
   392 000002C4 31C0                        xor  eax,eax            ; invalidate the rest of the app laddr space
   393 000002C6 B9FE030000                  mov  ecx,0x400-2        ; (yeah, only one pgdir for kernel+apps for now)
   394 000002CB F3AB                        rep stosd
   395                                  
   396                                              ; pgtb0 is the page table for kernel memory
   397                                  
   398 000002CD 89D7                        mov  edi,edx
   399 000002CF AB                          stosd                   ; access to page 0 will always cause a fault
   400 000002D0 B803100000                  mov  eax,0x1000 + 3     ; rest are direct map: present, pl=0, r/w
   401 000002D5 B9FF030000                  mov  ecx,0x400-1
   402                                  pgtb0_fill :
   403 000002DA AB                          stosd                   ; kernel gets to touch anything it wants < 4MB
   404 000002DB 0500100000                  add  eax,0x1000
   405 000002E0 E2F8                        loop pgtb0_fill
   406                                  
   407                                              ; pgtb1 is the first page table for app code/data/stack it is
   408                                              ; already all zeros (invalid - we'll fill in what we need later)
   409                                  
   410                                              ; enable paging - if we've done it all right, we won't crash
   411                                  
   412 000002E2 0F20C0                      mov  eax,cr0
   413 000002E5 0D00000080                  or   eax,0x80000000     ; msb of cr0
   414 000002EA 0F22C0                      mov  cr0,eax
   415 000002ED EB00                        jmp  flush_ip2          ; flush the cpu instruction pipeline
   416                                  flush_ip2: 
   417                                  
   418                                      ; ---- build the interrupt descriptor table
   419                                  
   420 000002EF E8DF010000                  call mem_alloc_kernel_page  ; get a page for the idt
   421 000002F4 C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   422 000002F7 89C2                        mov  edx,eax
   423 000002F9 A3[10030000]                mov  [idtr_addr],eax
   424                                  
   425 000002FE BE[940D0000]                mov  esi,irq_setup_table
   426 00000303 B900010000                  mov  ecx,irq_setup_table_size
   427                                  irq_init :
   428 00000308 31C0                        xor  eax,eax
   429 0000030A 8902                        mov  [edx],eax                  ; clear the idt entry
   430 0000030C 894202                      mov  [edx+2],eax
   431 0000030F 66AD                        lodsw
   432 00000311 6689C3                      mov  bx,ax
   433 00000314 6625FCFF                    and  ax,strict 0xfffc           ; separate config flags
   434 00000318 6683E303                    and  bx,3                       ; from selector/offset value
   435 0000031C 6683FB02                    cmp  bx,irqt_task               ; task gates are different
   436 00000320 7407                        jz   irq_init_task_gate
   437 00000322 668902                      mov  [edx],ax                   ; store the handler offset
   438 00000325 66B80800                    mov  ax,codesel
   439                                  irq_init_task_gate :
   440 00000329 66894202                    mov  word [edx+2],ax
   441 0000032D 678AA7[900D]                mov  ah,byte [bx+irq_types]
   442 00000332 30C0                        xor  al,al
   443 00000334 66894204                    mov  word [edx+4],ax
   444 00000338 83C208                      add  edx,8
   445 0000033B E2CB                        loop irq_init
   446                                  
   447 0000033D 0F011D[0E030000]            lidt [idtr]                     ; install the idt
   448                                  
   449                                      ; ---- let's see what kind of interrupt hardware we've got
   450                                  
   451 00000344 C605[30030000]00            mov  byte [enabled_lapic],0x0
   452 0000034B B801000000                  mov  eax,1
   453 00000350 0FA2                        cpuid
   454 00000352 83F801                      cmp  eax,1
   455 00000355 720F                        jb   no_lapic
   456 00000357 81E200020000                and  edx,1 << 9         ; lapic feature
   457 0000035D 7407                        jz   no_lapic
   458 0000035F C605[30030000]01            mov  byte [enabled_lapic],0x1
   459                                  no_lapic :
   460                                  
   461                                              ; if enabled, create page table entry for the lapic
   462                                  
   463 00000366 A0[30030000]                mov  al,[enabled_lapic]
   464 0000036B 08C0                        or   al,al
   465 0000036D 7430                        jz   no_lapic_init
   466                                  
   467 0000036F BA0000E0FE                  mov  edx,0xfee00000     ; phys address
   468 00000374 B900100000                  mov  ecx,0x1000         ; length
   469 00000379 E8CB0C0000                  call map_pmem
   470                                  
   471                                      ; do the ioapic while we're at it
   472 0000037E BA0000C0FE                  mov  edx,0xfec00000     ; phys address
   473 00000383 52                          push edx
   474 00000384 B900100000                  mov  ecx,0x1000         ; length
   475 00000389 E8BB0C0000                  call map_pmem
   476 0000038E 5A                          pop  edx
   477 0000038F C70201000000                mov  dword [edx],1
   478 00000395 A11000C0FE                  mov  eax,[0xfec00010]
   479                                  
   480 0000039A E86E040000                  call irq_init_bsp_apic_hardware
   481                                  
   482                                  no_lapic_init :
   483                                  
   484                                      ; ---- setup entry point for non_boot_cpus
   485                                  
   486 0000039F A0[04020000]                mov  al,[non_boot_cpu_ljmp_instruction]     ; get the ljmp instruction
   487 000003A4 A200700000                  mov  [sipi_vector],al                       ; place it at a 4k phys mem boundary
   488 000003A9 C70501700000-               mov  dword [sipi_vector+1],main
   489 000003AF [0C020000]         
   490                                  
   491                                      ; ---- establish a current task
   492                                  
   493 000003B3 31C0                        xor  eax,eax
   494 000003B5 B050                        mov  al,tasksel_k00
   495 000003B7 0F00D8                      ltr  ax
   496                                  
   497                                      ; ---- check for init apps
   498                                  
   499 000003BA BB[20000000]                mov  ebx, kend
   500                                  app_loop :
   501 000003BF 8B4318                      mov  eax, [ebx+0x18]    ; load the entry address
   502 000003C2 813B6F7A6170                cmp  dword [ebx], 0x70617a6f  ; check for "ozap"
   503 000003C8 7402                        jz   have_an_app
   504 000003CA 31C0                        xor  eax, eax           ; no app
   505                                  have_an_app :
   506                                  
   507 000003CC 83F800                      cmp  eax, 0             ; is there an app to run?
   508 000003CF 0F84A8000000                jz   idle               ; if not, idle right away
   509                                  
   510                                      ; ---- setup the init task entry point
   511                                  
   512 000003D5 BF[C0020000]                mov  edi,tss1_eip
   513 000003DA AB                          stosd
   514                                  
   515                                      ; cheat: reuse the same tss, ldt, and page tables for all
   516                                      ; the init apps - this means they run serialy - each has
   517                                      ; to exit for the next one to run
   518                                  
   519 000003DB 31C0                        xor   eax,eax
   520 000003DD A3[A0020000]                mov   [tss1],eax        ; clear out previous task link
   521 000003E2 AB                          stosd                   ; and some registers (flags)
   522 000003E3 AB                          stosd                   ; (eax)
   523 000003E4 AB                          stosd                   ; (ecx)
   524 000003E5 AB                          stosd                   ; (edx)
   525 000003E6 AB                          stosd                   ; (ebx)
   526 000003E7 8B4310                      mov   eax, [ebx+0x10]   ; get the end of the app
   527                                      ;add   eax,0x8001000     ; (this tests app stack page faults)
   528 000003EA AB                          stosd                   ; (esp)
   529 000003EB 31C0                        xor   eax,eax
   530 000003ED AB                          stosd                   ; (ebp)
   531 000003EE AB                          stosd                   ; (esi)
   532 000003EF AB                          stosd                   ; (edi)
   533                                  
   534 000003F0 8B3D[2C030000]              mov  edi,[pgtb1p]       ; rewrite the app's page table
   535 000003F6 89D8                        mov  eax,ebx
   536 000003F8 83C805                      or   eax,5              ; init app code at 0x400000 (4Mb) present and r/o
   537 000003FB AB                          stosd                   ; assume all the init apps are < 4k
   538 000003FC 0502100000                  add  eax,0x1000 + 2     ; add one page for data/bss/stack
   539 00000401 AB                          stosd
   540                                  
   541                                      ; ---- debug marker
   542 00000402 65C605010000000A            mov  byte [gs:1],0xA    ; turn the first two chars green
   543 0000040A 65C605030000000A            mov  byte [gs:3],0xA
   544                                  
   545                                      ; ---- use our current stack for system interrupts during the app
   546                                  
   547 00000412 53                          push ebx
   548 00000413 BF[A4020000]                mov  edi,tss1_esp0
   549 00000418 89E0                        mov  eax,esp
   550 0000041A AB                          stosd
   551                                  
   552                                      ; ---- start the app
   553                                  
   554 0000041B FB                          sti
   555 0000041C 9A000000005800              call tasksel_u00:0
   556 00000423 5B                          pop  ebx
   557                                  
   558                                      ; ---- point to the end of this init app
   559                                  
   560 00000424 0F013D00004000              invlpg [0x400000]       ; FIXME 80386 needs to reload cr3
   561 0000042B 0F013D00104000              invlpg [0x401000]
   562                                  
   563 00000432 8B4310                      mov  eax, [ebx+0x10]    ; load the app end address
   564 00000435 2D00004000                  sub  eax,0x400000
   565 0000043A 01C3                        add  ebx,eax            ; point ebx to the next app
   566 0000043C EB81                        jmp  app_loop
   567                                  
   568                                  ; -------- non-boot cpu initialization --------
   569                                  
   570                                  non_boot_init :
   571                                  
   572 0000043E 0F011D[0E030000]            lidt [idtr]             ; install the global idt
   573                                  
   574                                      ; ---- enable paging
   575                                  
   576 00000445 8B3D[24030000]              mov  edi,[pgdirp]       ; load this cpu's paging register
   577 0000044B 0F22DF                      mov  cr3,edi
   578                                  
   579 0000044E 50                          push eax
   580 0000044F 0F20C0                      mov  eax,cr0            ; enable paging
   581 00000452 0D00000080                  or   eax,0x80000000
   582 00000457 0F22C0                      mov  cr0,eax
   583 0000045A EB00                        jmp  flush_ip3          ; flush the cpu instruction pipeline
   584                                  flush_ip3 : 
   585 0000045C 58                          pop  eax
   586                                  
   587                                      ; ---- limit the number of threads we support here
   588                                  
   589 0000045D 83F810                      cmp  eax,max_threads
   590 00000460 7317                        jae  nb_idle
   591                                  
   592                                      ; ---- init the lapic
   593                                  
   594 00000462 E8EE030000                  call irq_init_ap_apic_hardware
   595                                  
   596                                      ; setup smbase?
   597                                  
   598                                      ; ---- establish a current task
   599                                  
   600 00000467 89C3                        mov  ebx,eax            ; move cpu number to ebx
   601 00000469 E886000000                  call create_tss_pair
   602 0000046E 53                          push ebx
   603 0000046F C1E304                      shl  ebx,4              ; 16x (descriptor_size x2)
   604 00000472 83C350                      add  ebx,tasksel_k00
   605 00000475 0F00DB                      ltr  bx                 ; establish a current task
   606 00000478 5B                          pop  ebx
   607                                  
   608                                      ; test kernel page fault handler
   609                                      ;mov  [321],eax
   610                                  
   611                                  nb_idle :
   612 00000479 FB                          sti
   613 0000047A F4                          hlt                     ; wait for something to do
   614 0000047B EBFC                        jmp  nb_idle            ; (see new_thread)
   615                                  
   616                                      ; -------- boot cpu idle task --------
   617                                      ; could be combined with nb_idle but separating
   618                                      ; these can allow for easier debug
   619                                  
   620                                  idle :
   621 0000047D FB                          sti
   622 0000047E F4                          hlt                     ; wait for interrupts
   623 0000047F EBFC                        jmp  idle
   624                                  
   625                                  
   626                                  ; ----------------------------
   627                                  ;    puts_vga - write a null delimited string to the VGA controller
   628                                  ;               in protected mode
   629                                  ;    enter:
   630                                  ;         esi - address of string
   631                                  ;         ebx - screen location (2 bytes per char, 160 bytes per line)
   632                                  ;    exit:
   633                                  ;         eax - destroyed
   634                                  ;         ebx - next screen location
   635                                  ;          gs - set to video memory selector
   636                                  bits 32
   637                                  
   638                                  puts_vga :
   639 00000481 66B82000                    mov  ax,videosel        ; point gs at video memory
   640 00000485 8EE8                        mov  gs,ax
   641                                  puts_vga_loop :
   642 00000487 2E8A06                      mov  al,[cs:esi]        ; use cs so irq handlers don't
   643 0000048A 46                          inc  esi                ; have to load kernel ds
   644 0000048B 3C00                        cmp  al,0
   645 0000048D 7408                        jz   puts_vga_done
   646 0000048F 658803                      mov  [gs:ebx],al
   647 00000492 83C302                      add  ebx,2
   648 00000495 EBF0                        jmp  puts_vga_loop
   649                                  puts_vga_done :
   650 00000497 C3                          ret
   651                                  
   652                                  ; ----------------------------
   653                                  ;   putx_vga - write the contents of eax in hex to the VGA controller
   654                                  ;              (in protected mode)
   655                                  ;   putbx_vga - write the contents of al in hex to the VGA controller
   656                                  ;
   657                                  ;   enter:
   658                                  ;       eax - value to convert to hex
   659                                  ;       ebx - screen location (2 bytes per char, 160 bytes per line)
   660                                  ;   exit:
   661                                  ;       ebx - next screen location
   662                                  ;        gs - set to video memory selector
   663                                  bits 32
   664                                  
   665                                  putbx_vga :
   666 00000498 51                          push ecx
   667 00000499 B902000000                  mov  ecx,2
   668 0000049E 25FF000000                  and  eax,0xff
   669 000004A3 C1C018                      rol  eax,24
   670 000004A6 EB06                        jmp putx_vga_loop
   671                                  
   672                                  putx_vga :
   673 000004A8 51                          push ecx
   674 000004A9 B908000000                  mov  ecx,8
   675                                  putx_vga_loop :
   676 000004AE C1C004                      rol  eax,4
   677 000004B1 50                          push eax
   678 000004B2 240F                        and  al,0xf
   679 000004B4 3C09                        cmp  al,9
   680 000004B6 7704                        ja   putx_vga_hexdigit
   681 000004B8 0430                        add  al,'0'
   682 000004BA EB02                        jmp short putx_vga_putc
   683                                  putx_vga_hexdigit :
   684 000004BC 0457                        add  al,'a'-10
   685                                  putx_vga_putc :
   686 000004BE 658803                      mov  [gs:ebx],al
   687 000004C1 83C302                      add  ebx,2
   688 000004C4 58                          pop  eax
   689 000004C5 83E0F0                      and  eax,0xfffffff0
   690 000004C8 E2E4                        loop putx_vga_loop
   691 000004CA 65C60320                    mov  byte [gs:ebx],' '
   692 000004CE 83C302                      add  ebx,2
   693 000004D1 59                          pop  ecx
   694 000004D2 C3                          ret
   695                                  
   696                                  ;------------------------------------------------------------------
   697                                  ;   mem_alloc_kernel_page - return the 4k page number of 1 page of memory
   698                                  ;                           from the kernel page pool
   699                                  ;
   700                                  ;   smp safe
   701                                  ;
   702                                  ;   returns:    eax = page number, zero means no pages left
   703                                  
   704                                  mem_alloc_kernel_page :
   705 000004D3 B801000000                  mov  eax,1
   706 000004D8 0FC105[18030000]            xadd [next_free_page],eax   ; atomic, making this re-entrant
   707                                      ; FIXME probably should check for the end of something and return 0
   708 000004DF 50                          push eax
   709 000004E0 51                          push ecx
   710 000004E1 57                          push edi
   711 000004E2 C1E00C                      shl  eax,12
   712 000004E5 B900040000                  mov  ecx,0x1000/4
   713 000004EA 89C7                        mov  edi,eax
   714 000004EC 31C0                        xor  eax,eax
   715 000004EE F3AB                        rep stosd                   ; zero the page
   716 000004F0 5F                          pop  edi
   717 000004F1 59                          pop  ecx
   718 000004F2 58                          pop  eax
   719 000004F3 C3                          ret
   720                                  
   721                                  ;------------------------------------------------------------------
   722                                  ;   create a pair of tss structs for a new cpu
   723                                  ;
   724                                  ;   enter:
   725                                  ;       ebx - cpu number
   726                                  ;   exit:
   727                                  ;       ebx - cpu number
   728                                  
   729                                  create_tss_pair :
   730 000004F4 E8DAFFFFFF                  call mem_alloc_kernel_page
   731 000004F9 09C0                        or   eax,eax
   732 000004FB 0F849C000000                jz   create_tss_pair_fail
   733 00000501 C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   734 00000504 89C7                        mov  edi,eax                ; first tss is the kernel ring 0 thread
   735                                  
   736 00000506 89FE                        mov  esi,edi
   737 00000508 83C668                      add  esi,(tss0_end-tss0)    ; second tss is the user ring 3 thread
   738                                  
   739 0000050B A1[24030000]                mov  eax,[pgdirp]
   740 00000510 89471C                      mov  [edi+(tss0_cr3-tss0)],eax
   741 00000513 89461C                      mov  [esi+(tss0_cr3-tss0)],eax
   742                                  
   743                                      ; user tss gets ldt selectors
   744 00000516 B817000000                  mov  eax,datasel1+7
   745 0000051B 894648                      mov  [esi+(tss0_es-tss0)],eax
   746 0000051E 894650                      mov  [esi+(tss0_ss-tss0)],eax
   747 00000521 894654                      mov  [esi+(tss0_ds-tss0)],eax
   748 00000524 B80F000000                  mov  eax,codesel1+7
   749 00000529 89464C                      mov  [esi+(tss0_cs-tss0)],eax
   750 0000052C B83B000000                  mov  eax,ldtsel1+3
   751 00000531 894660                      mov  [esi+(tss0_ldt-tss0)],eax
   752                                  
   753                                      ; there are three stacks total
   754                                      ;   (1) kernel tss esp0 - placed at the end of this page
   755                                      ;   (2) user tss esp0 (for interrupt handling) - end minus 1k
   756                                      ;   (3) user tss esp - will be set up by new_thread
   757                                  
   758                                      ;mov  eax,stacksel
   759                                      ;mov  [edi+(tss0_ss0-tss0)],eax
   760                                      ;mov  [edi+(tss0_esp0-tss0)],esp ; (1) kernel tss esp0
   761                                  
   762 00000534 B810000000                  mov  eax,datasel
   763 00000539 894708                      mov  [edi+(tss0_ss0-tss0)],eax
   764 0000053C 89F8                        mov  eax,edi
   765 0000053E 0500080000                  add  eax,0x0800                 ; end of the tss page
   766 00000543 894704                      mov  [edi+(tss0_esp0-tss0)],eax ; (1) kernel tss esp0
   767                                  
   768                                      ; sloppy (datasel maps all of physical ram), but better than
   769                                      ; having to set up a separate gdt stacksel for each cpu
   770 00000546 B810000000                  mov  eax,datasel
   771 0000054B 894608                      mov  [esi+(tss0_ss0-tss0)],eax
   772 0000054E 89F8                        mov  eax,edi
   773 00000550 0500100000                  add  eax,0x1000                 ; end of the tss page
   774 00000555 894604                      mov  [esi+(tss0_esp0-tss0)],eax ; (2) user tss esp0
   775                                  
   776                                      ; patch the tss addresses into the reserved gdt selectors
   777                                  
   778 00000558 89DA                        mov  edx,ebx
   779 0000055A C1E204                      shl  edx,4                      ; 16x because selectors are in pairs
   780 0000055D 83C250                      add  edx,tasksel_k00
   781                                  
   782 00000560 89F8                        mov  eax,edi
   783 00000562 C1E818                      shr  eax,24
   784 00000565 8882[07000000]              mov  byte [gdt+edx+7],al        ; base 24-32
   785 0000056B 81E7FFFFFF00                and  edi,0xffffff
   786 00000571 0BBA[02000000]              or   edi,[gdt+edx+2]            ; or in flags
   787 00000577 89BA[02000000]              mov  [gdt+edx+2],edi            ; base 0-23 and flags
   788                                  
   789 0000057D 83C208                      add  edx,8                      ; move to tasksel_uxx
   790                                  
   791 00000580 89F0                        mov  eax,esi
   792 00000582 C1E818                      shr  eax,24
   793 00000585 8882[07000000]              mov  byte [gdt+edx+7],al        ; base 24-32
   794 0000058B 81E6FFFFFF00                and  esi,0xffffff
   795 00000591 0BB2[02000000]              or   esi,[gdt+edx+2]            ; or in flags
   796 00000597 89B2[02000000]              mov  [gdt+edx+2],esi            ; base 0-23 and flags
   797                                  
   798                                  create_tss_pair_fail :
   799 0000059D C3                          ret
   800                                  
   801                                  ; -------- interrupt handlers --------
   802                                  %include "ozirq.asm"
   803                              <1> ; OZ - A more utopian OS    x86-32 interrupts
   804                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
   805                              <1> ;
   806                              <1> ; Copyright (C) 2015  Duane Voth
   807                              <1> ;
   808                              <1> ;   This program is free software: you can redistribute it and/or modify
   809                              <1> ;   it under the terms of the GNU Affero General Public License as
   810                              <1> ;   published by the Free Software Foundation, either version 3 of the
   811                              <1> ;   License, or (at your option) any later version.
   812                              <1> ;
   813                              <1> ;   This program is distributed in the hope that it will be useful,
   814                              <1> ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
   815                              <1> ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   816                              <1> ;   GNU Affero General Public License for more details.
   817                              <1> ;
   818                              <1> ;   You should have received a copy of the GNU Affero General Public License
   819                              <1> ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
   820                              <1> ;
   821                              <1> ;
   822                              <1> ; IRQ handling
   823                              <1> ;
   824                              <1> ; resources:
   825                              <1> ;       http://forum.osdev.org/viewtopic.php?p=107868#107868
   826                              <1> 
   827 0000059E 63707500            <1> cpumsg      db      "cpu",0
   828                              <1> 
   829 000005A2 646976696465206279- <1> int00msg    db      "divide by zero ",0
   830 000005AB 207A65726F2000      <1>
   831 000005B2 646562756720657863- <1> int01msg    db      "debug exception ",0
   832 000005BB 657074696F6E2000    <1>
   833 000005C3 6E6D692000          <1> int02msg    db      "nmi ",0
   834 000005C8 627265616B706F696E- <1> int03msg    db      "breakpoint exception ",0
   835 000005D1 742065786365707469- <1>
   836 000005DA 6F6E2000            <1>
   837 000005DE 6F766572666C6F7720- <1> int04msg    db      "overflow exception ",0
   838 000005E7 657863657074696F6E- <1>
   839 000005F0 2000                <1>
   840 000005F2 626F756E6420657863- <1> int05msg    db      "bound exceeded ",0
   841 000005FB 65656465642000      <1>
   842 00000602 696E76616C6964206F- <1> int06msg    db      "invalid opcode ",0
   843 0000060B 70636F64652000      <1>
   844 00000612 64657669636520756E- <1> int07msg    db      "device unavailable ",0
   845 0000061B 617661696C61626C65- <1>
   846 00000624 2000                <1>
   847 00000626 646F75626C65206661- <1> int08msg    db      "double fault ",0
   848 0000062F 756C742000          <1>
   849 00000634 636F70726F63657373- <1> int09msg    db      "coprocessor segment overrun ",0
   850 0000063D 6F72207365676D656E- <1>
   851 00000646 74206F76657272756E- <1>
   852 0000064F 2000                <1>
   853 00000651 696E76616C69642074- <1> int10msg    db      "invalid tss ",0
   854 0000065A 73732000            <1>
   855 0000065E 7365676D656E74206E- <1> int11msg    db      "segment not present ",0
   856 00000667 6F742070726573656E- <1>
   857 00000670 742000              <1>
   858 00000673 737461636B20666175- <1> int12msg    db      "stack fault ",0
   859 0000067C 6C742000            <1>
   860 00000680 67656E6572616C2070- <1> int13msg    db      "general protection fault ",0
   861 00000689 726F74656374696F6E- <1>
   862 00000692 206661756C742000    <1>
   863 0000069A 6B65726E656C207061- <1> int14kmsg   db      "kernel page fault addr=",0
   864 000006A3 6765206661756C7420- <1>
   865 000006AC 616464723D00        <1>
   866 000006B2 617070207061676520- <1> int14umsg   db      "app page fault addr=",0
   867 000006BB 6661756C7420616464- <1>
   868 000006C4 723D00              <1>
   869 000006C7 666C6F6174696E6720- <1> int16msg    db      "floating point err ",0
   870 000006D0 706F696E7420657272- <1>
   871 000006D9 2000                <1>
   872 000006DB 616C69676E6D656E74- <1> int17msg    db      "alignment check ",0
   873 000006E4 20636865636B2000    <1>
   874 000006EC 6D616368696E652063- <1> int18msg    db      "machine check ",0
   875 000006F5 6865636B2000        <1>
   876 000006FB 73696D6420666C6F61- <1> int19msg    db      "simd floating point err ",0
   877 00000704 74696E6720706F696E- <1>
   878 0000070D 74206572722000      <1>
   879                              <1> 
   880 00000714 687720696E74303220- <1> int34msg    db      "hw int02 ",0
   881 0000071D 00                  <1>
   882 0000071E 687720696E74303320- <1> int35msg    db      "hw int03 ",0
   883 00000727 00                  <1>
   884 00000728 687720696E74303420- <1> int36msg    db      "hw int04 ",0
   885 00000731 00                  <1>
   886 00000732 687720696E74303520- <1> int37msg    db      "hw int05 ",0
   887 0000073B 00                  <1>
   888 0000073C 687720696E74303620- <1> int38msg    db      "hw int06 ",0
   889 00000745 00                  <1>
   890 00000746 687720696E74303720- <1> int39msg    db      "hw int07 ",0
   891 0000074F 00                  <1>
   892 00000750 687720696E74303820- <1> int40msg    db      "hw int08 ",0
   893 00000759 00                  <1>
   894 0000075A 687720696E74303920- <1> int41msg    db      "hw int09 ",0
   895 00000763 00                  <1>
   896 00000764 687720696E74313020- <1> int42msg    db      "hw int10 ",0
   897 0000076D 00                  <1>
   898 0000076E 687720696E74313120- <1> int43msg    db      "hw int11 ",0
   899 00000777 00                  <1>
   900 00000778 687720696E74313220- <1> int44msg    db      "hw int12 ",0
   901 00000781 00                  <1>
   902 00000782 687720696E74313320- <1> int45msg    db      "hw int13 ",0
   903 0000078B 00                  <1>
   904 0000078C 687720696E74313420- <1> int46msg    db      "hw int14 ",0
   905 00000795 00                  <1>
   906 00000796 687720696E74313520- <1> int47msg    db      "hw int15 ",0
   907 0000079F 00                  <1>
   908                              <1> 
   909 000007A0 73707572696F757320- <1> spuriousmsg db      "spurious int ",0
   910 000007A9 696E742000          <1>
   911 000007AE 617069636572722069- <1> apicerrmsg  db      "apicerr int ",0
   912 000007B7 6E742000            <1>
   913 000007BB 68692000            <1> himsg       db      "hi ",0
   914 000007BF 756E6B6E6F776E2073- <1> int255msg           db  "unknown system call ",0
   915 000007C8 797374656D2063616C- <1>
   916 000007D1 6C2000              <1>
   917                              <1> 
   918 000007D4 766D206661756C743A- <1> intvmmsg            db  "vm fault: ",0
   919 000007DD 2000                <1>
   920                              <1> 
   921 000007DF 90                  <1>   align 4
   922 000007E0 00000000            <1> irq_err_lno dd 0
   923                              <1> 
   924                              <1> ; ---- IRQ hardware initialization ----
   925                              <1> 
   926                              <1> bits 16
   927                              <1> 
   928                              <1> irq_init_hardware :
   929                              <1> 
   930                              <1>     ; re-program the 8259's to move the hardware vectors out of the
   931                              <1>     ; soft int range ... C'mon, Intel was pretty clear about this!
   932                              <1> 
   933 000007E4 B011                <1>     mov  al,0x11
   934 000007E6 E620                <1>     out  0x20,al            ; init the 1st 8259
   935 000007E8 B011                <1>     mov  al,0x11
   936 000007EA E6A0                <1>     out  0xA0,al            ; init the 2nd 8259
   937 000007EC B020                <1>     mov  al,apic0_irqbase
   938 000007EE E621                <1>     out  0x21,al            ; base for the 1st 8259
   939 000007F0 B028                <1>     mov  al,apic1_irqbase
   940 000007F2 E6A1                <1>     out  0xA1,al            ; base for the 2nd 8259
   941 000007F4 B004                <1>     mov  al,0x04
   942 000007F6 E621                <1>     out  0x21,al            ; set 1st 8259 as master
   943 000007F8 B002                <1>     mov  al,0x02
   944 000007FA E6A1                <1>     out  0xA1,al            ; set 2nd 8259 as slave
   945 000007FC B001                <1>     mov  al,0x01
   946 000007FE E621                <1>     out  0x21,al
   947 00000800 B001                <1>     mov  al,0x01
   948 00000802 E6A1                <1>     out  0xA1,al
   949 00000804 B0FC                <1>     mov  al,0xfc            ; PIC1 disable all but the timer and kbd
   950 00000806 E621                <1>     out  0x21,al
   951 00000808 B0FF                <1>     mov  al,0xff            ; PIC2 disable everything
   952 0000080A E6A1                <1>     out  0xA1,al
   953 0000080C C3                  <1>     ret
   954                              <1> 
   955                              <1> bits 32
   956                              <1> 
   957                              <1> ; ----------
   958                              <1> 
   959                              <1> irq_init_bsp_apic_hardware :
   960                              <1>     ;jmp  no_apic
   961                              <1> 
   962                              <1>     ; ---- test for an apic
   963                              <1> 
   964 0000080D A17003E0FE          <1>     mov  eax,[0xfee00370]
   965 00000812 2500FFFFFF          <1>     and  eax,0xffffff00
   966 00000817 0DF0000000          <1>     or   eax,apicerr_int
   967 0000081C A37003E0FE          <1>     mov  [0xfee00370],eax   ; setup LVT3 error vector
   968                              <1> 
   969 00000821 B8EF010000          <1>     mov  eax,0x00000100 + spurious_int    ; enable + spurious int
   970 00000826 A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
   971 0000082B B800000001          <1>     mov  eax,0x01000000
   972 00000830 A3D000E0FE          <1>     mov  [0xfee000d0],eax   ; set our LDR
   973 00000835 B8FFFFFFFF          <1>     mov  eax,0xffffffff
   974 0000083A A3E000E0FE          <1>     mov  [0xfee000e0],eax   ; set our DFR
   975 0000083F 31C0                <1>     xor  eax,eax
   976 00000841 A3B000E0FE          <1>     mov  [0xfee000b0],eax   ; eoi anything outstanding
   977                              <1> 
   978                              <1> ;    ; ---- enable the local apic via msr
   979                              <1> ; but apparently not needed ...
   980                              <1> ;    mov  ecx,0x1b
   981                              <1> ;    xor  edx,edx
   982                              <1> ; ;  mov  eax,0xfffff800
   983                              <1> ;    mov  eax,0x00000800
   984                              <1> ;    wrmsr
   985                              <1> ;    mov  eax,[0xfffff030]
   986                              <1> 
   987                              <1>     ; ---- visual indicator: lapic active
   988                              <1> 
   989 00000846 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
   990 0000084A 8EE8                <1>     mov  gs,ax          
   991 0000084C 65C605320000002B    <1>     mov  byte [gs:25*2],'+'
   992                              <1> 
   993 00000854 C3                  <1>     ret
   994                              <1> 
   995                              <1> ; ----------
   996                              <1> 
   997                              <1> irq_init_ap_apic_hardware :
   998                              <1>     ; eax = cpu number
   999                              <1> 
  1000                              <1>     ; ---- mtrr for 0xfee00000 -> strong uncachable (UC) ?
  1001                              <1> 
  1002 00000855 50                  <1>     push eax                ; save cpu number
  1003 00000856 89C1                <1>     mov  ecx,eax
  1004 00000858 A0[30030000]        <1>     mov  al,[enabled_lapic]
  1005 0000085D 08C0                <1>     or   al,al
  1006 0000085F 7432                <1>     jz  no_lapic_init2
  1007                              <1> 
  1008 00000861 BB00000001          <1>     mov  ebx,0x01000000
  1009 00000866 D3E3                <1>     shl  ebx,cl             ; bit mask based on cpu number
  1010 00000868 891DD000E0FE        <1>     mov  [0xfee000d0],ebx   ; set our LDR
  1011                              <1> 
  1012 0000086E A17003E0FE          <1>     mov  eax,[0xfee00370]
  1013 00000873 2500FFFFFF          <1>     and  eax,0xffffff00
  1014 00000878 0DF0000000          <1>     or   eax,apicerr_int
  1015 0000087D A37003E0FE          <1>     mov  [0xfee00370],eax   ; setup LVT3 error vector
  1016                              <1> 
  1017 00000882 B8EF010000          <1>     mov  eax,0x00000100 + spurious_int  ; enable + spurious int
  1018 00000887 A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
  1019 0000088C 31C0                <1>     xor  eax,eax
  1020 0000088E A3B000E0FE          <1>     mov  [0xfee000b0],eax   ; eoi anything outstanding
  1021                              <1> no_lapic_init2 :
  1022 00000893 58                  <1>     pop  eax
  1023 00000894 C3                  <1>     ret
  1024                              <1> 
  1025                              <1> ; ---- IRQ handlers ----
  1026                              <1> 
  1027 00000895 90<rept>            <1> align 4
  1028                              <1> int_handler_div0 :
  1029 00000898 56                  <1>     push esi
  1030 00000899 BE[A2050000]        <1>     mov  esi,int00msg
  1031 0000089E E861040000          <1>     call irq_print_msg
  1032 000008A3 5E                  <1>     pop  esi
  1033 000008A4 E9EC000000          <1>     jmp  int_handler_show_eip
  1034                              <1> 
  1035 000008A9 90<rept>            <1> align 4
  1036                              <1> int_handler_debug :
  1037 000008AC 56                  <1>     push esi
  1038 000008AD BE[B2050000]        <1>     mov  esi,int01msg
  1039 000008B2 E84D040000          <1>     call irq_print_msg
  1040 000008B7 5E                  <1>     pop  esi
  1041 000008B8 E9D8000000          <1>     jmp  int_handler_show_eip
  1042                              <1> 
  1043 000008BD 90<rept>            <1> align 4
  1044                              <1> int_handler_nmi :
  1045 000008C0 56                  <1>     push esi
  1046 000008C1 BE[C3050000]        <1>     mov  esi,int02msg
  1047 000008C6 E839040000          <1>     call irq_print_msg
  1048 000008CB 5E                  <1>     pop  esi
  1049 000008CC CF                  <1>     iret
  1050                              <1>     ;jmp  reboot_on_alt_key
  1051                              <1> 
  1052 000008CD 90<rept>            <1> align 4
  1053                              <1> int_handler_brkp :
  1054 000008D0 56                  <1>     push esi
  1055 000008D1 BE[C8050000]        <1>     mov  esi,int03msg
  1056 000008D6 E829040000          <1>     call irq_print_msg
  1057 000008DB 5E                  <1>     pop  esi
  1058 000008DC E9B4000000          <1>     jmp  int_handler_show_eip
  1059                              <1> 
  1060 000008E1 90<rept>            <1> align 4
  1061                              <1> int_handler_ovrflw :
  1062 000008E4 56                  <1>     push esi
  1063 000008E5 BE[DE050000]        <1>     mov  esi,int04msg
  1064 000008EA E815040000          <1>     call irq_print_msg
  1065 000008EF 5E                  <1>     pop  esi
  1066 000008F0 E9A0000000          <1>     jmp  int_handler_show_eip
  1067                              <1> 
  1068 000008F5 90<rept>            <1> align 4
  1069                              <1> int_handler_bound :
  1070 000008F8 56                  <1>     push esi
  1071 000008F9 BE[F2050000]        <1>     mov  esi,int05msg
  1072 000008FE E801040000          <1>     call irq_print_msg
  1073 00000903 5E                  <1>     pop  esi
  1074 00000904 E98C000000          <1>     jmp  int_handler_show_eip
  1075                              <1> 
  1076 00000909 90<rept>            <1> align 4
  1077                              <1> int_handler_invop :
  1078 0000090C 56                  <1>     push esi
  1079 0000090D BE[02060000]        <1>     mov  esi,int06msg
  1080 00000912 E8ED030000          <1>     call irq_print_msg
  1081 00000917 5E                  <1>     pop  esi
  1082 00000918 EB7B                <1>     jmp  int_handler_show_eip
  1083                              <1> 
  1084 0000091A 90<rept>            <1> align 4
  1085                              <1> int_handler_devna :
  1086                              <1>     ;push esi
  1087                              <1>     ;mov  esi,int07msg
  1088                              <1>     ;call irq_print_msg
  1089                              <1>     ;pop  esi
  1090                              <1>     ; FIXME fxsave/fxrestore the fpu/sse/mmx regs
  1091 0000091C 0F06                <1>     clts                ; sure! you can use the fpu
  1092 0000091E CF                  <1>     iret
  1093                              <1> 
  1094 0000091F 90                  <1> align 4
  1095                              <1> int_handler_cpsego :
  1096 00000920 56                  <1>     push esi
  1097 00000921 BE[34060000]        <1>     mov  esi,int09msg
  1098 00000926 E8D9030000          <1>     call irq_print_msg
  1099 0000092B 5E                  <1>     pop  esi
  1100 0000092C EB67                <1>     jmp  int_handler_show_eip
  1101                              <1> 
  1102 0000092E 90<rept>            <1> align 4
  1103                              <1> int_handler_segnp :
  1104                              <1>     ; ec = seg selector
  1105 00000930 56                  <1>     push esi
  1106 00000931 BE[5E060000]        <1>     mov  esi,int11msg
  1107 00000936 E8C9030000          <1>     call irq_print_msg
  1108 0000093B 5E                  <1>     pop  esi
  1109 0000093C EB32                <1>     jmp  int_handler_show_ec_eip
  1110                              <1> 
  1111 0000093E 90<rept>            <1> align 4
  1112                              <1> int_handler_stkflt :
  1113                              <1>     ; ec = seg selector
  1114 00000940 56                  <1>     push esi
  1115 00000941 BE[73060000]        <1>     mov  esi,int12msg
  1116 00000946 E8B9030000          <1>     call irq_print_msg
  1117 0000094B 5E                  <1>     pop  esi
  1118 0000094C B904000000          <1>     mov  ecx,4
  1119 00000951 83C302              <1>     add  ebx,2
  1120                              <1> int_handler_show_stack_loop :
  1121 00000954 58                  <1>     pop  eax
  1122 00000955 E84EFBFFFF          <1>     call putx_vga
  1123 0000095A E2F8                <1>     loop int_handler_show_stack_loop
  1124 0000095C E9F7030000          <1>     jmp  reboot_on_alt_key
  1125                              <1> 
  1126 00000961 90<rept>            <1> align 4
  1127                              <1> int_handler_gpf :
  1128                              <1>     ; ec = various ...
  1129                              <1>     ;test dword [esp+0xc],1 << 17    ; check the eflags vm bit
  1130                              <1>     ;jnz  int_handler_vm_gpf
  1131                              <1> 
  1132 00000964 56                  <1>     push esi
  1133 00000965 BE[80060000]        <1>     mov  esi,int13msg
  1134 0000096A E895030000          <1>     call irq_print_msg
  1135 0000096F 5E                  <1>     pop  esi
  1136                              <1> int_handler_show_ec_eip :
  1137 00000970 65C60365            <1>     mov  byte [gs:ebx],'e'
  1138 00000974 83C302              <1>     add  ebx,2
  1139 00000977 65C60363            <1>     mov  byte [gs:ebx],'c'
  1140 0000097B 83C302              <1>     add  ebx,2
  1141 0000097E 65C6033D            <1>     mov  byte [gs:ebx],'='
  1142 00000982 83C302              <1>     add  ebx,2
  1143 00000985 58                  <1>     pop  eax                ; ec
  1144 00000986 E80DFBFFFF          <1>     call putbx_vga
  1145 0000098B 83EB02              <1>     sub  ebx,2
  1146 0000098E 65C60320            <1>     mov  byte [gs:ebx],' '
  1147 00000992 83C302              <1>     add  ebx,2
  1148                              <1> int_handler_show_eip :
  1149 00000995 65C60363            <1>     mov  byte [gs:ebx],'c'
  1150 00000999 83C302              <1>     add  ebx,2
  1151 0000099C 65C60373            <1>     mov  byte [gs:ebx],'s'
  1152 000009A0 83C302              <1>     add  ebx,2
  1153 000009A3 65C6033A            <1>     mov  byte [gs:ebx],':'
  1154 000009A7 83C302              <1>     add  ebx,2
  1155 000009AA 65C60365            <1>     mov  byte [gs:ebx],'e'
  1156 000009AE 83C302              <1>     add  ebx,2
  1157 000009B1 65C60369            <1>     mov  byte [gs:ebx],'i'
  1158 000009B5 83C302              <1>     add  ebx,2
  1159 000009B8 65C60370            <1>     mov  byte [gs:ebx],'p'
  1160 000009BC 83C302              <1>     add  ebx,2
  1161 000009BF 65C6033D            <1>     mov  byte [gs:ebx],'='
  1162 000009C3 83C302              <1>     add  ebx,2
  1163 000009C6 5A                  <1>     pop  edx                ; eip
  1164 000009C7 58                  <1>     pop  eax                ; cs
  1165 000009C8 E8DBFAFFFF          <1>     call putx_vga
  1166 000009CD 83EB02              <1>     sub  ebx,2
  1167 000009D0 65C6033A            <1>     mov  byte [gs:ebx],':'
  1168 000009D4 83C302              <1>     add  ebx,2
  1169 000009D7 89D0                <1>     mov  eax,edx
  1170 000009D9 E8CAFAFFFF          <1>     call putx_vga
  1171 000009DE E975030000          <1>     jmp  reboot_on_alt_key
  1172                              <1> 
  1173                              <1> int_handler_vm_gpf :
  1174 000009E3 53                  <1>     push ebx
  1175                              <1>     ;mov  ebx,[esp+8]        ; faulter's eip
  1176 000009E4 2E8A1B              <1>     mov  bl,[cs:ebx]        ; get the opcode that caused the fault
  1177 000009E7 80FBF4              <1>     cmp  bl,0xf4            ; 'hlt' is ok
  1178 000009EA 7452                <1>     jz   int_handler_vm_normal_return
  1179                              <1> 
  1180 000009EC 56                  <1>     push esi
  1181 000009ED 50                  <1>     push eax
  1182 000009EE 53                  <1>     push ebx
  1183 000009EF BE[D4070000]        <1>     mov  esi,intvmmsg
  1184 000009F4 E80B030000          <1>     call irq_print_msg
  1185 000009F9 65C6036F            <1>     mov  byte [gs:ebx],'o'
  1186 000009FD 83C302              <1>     add  ebx,2
  1187 00000A00 65C60370            <1>     mov  byte [gs:ebx],'p'
  1188 00000A04 83C302              <1>     add  ebx,2
  1189 00000A07 65C60363            <1>     mov  byte [gs:ebx],'c'
  1190 00000A0B 83C302              <1>     add  ebx,2
  1191 00000A0E 65C6036F            <1>     mov  byte [gs:ebx],'o'
  1192 00000A12 83C302              <1>     add  ebx,2
  1193 00000A15 65C60364            <1>     mov  byte [gs:ebx],'d'
  1194 00000A19 83C302              <1>     add  ebx,2
  1195 00000A1C 65C60365            <1>     mov  byte [gs:ebx],'e'
  1196 00000A20 83C302              <1>     add  ebx,2
  1197 00000A23 65C60328            <1>     mov  byte [gs:ebx],'('
  1198 00000A27 83C302              <1>     add  ebx,2
  1199 00000A2A 58                  <1>     pop  eax
  1200 00000A2B 25FF000000          <1>     and  eax,0xff
  1201 00000A30 E863FAFFFF          <1>     call putbx_vga
  1202 00000A35 83C302              <1>     add  ebx,2
  1203 00000A38 65C60329            <1>     mov  byte [gs:ebx],')'
  1204 00000A3C 58                  <1>     pop  eax
  1205 00000A3D 5E                  <1>     pop  esi
  1206                              <1> int_handler_vm_normal_return :
  1207 00000A3E 5B                  <1>     pop  ebx
  1208                              <1> 
  1209 00000A3F FF74240C            <1>     push dword [esp+0xc]    ; eflags
  1210 00000A43 9D                  <1>     popf                    ; restore the VM and NT flags
  1211 00000A44 CF                  <1>     iret                    ; chain back via nested task
  1212                              <1>                             ; from v86 tss to original caller
  1213                              <1> 
  1214 00000A45 90<rept>            <1> align 4
  1215                              <1> int_handler_pgflt :
  1216 00000A48 58                  <1>     pop  eax
  1217 00000A49 50                  <1>     push eax
  1218 00000A4A A904000000          <1>     test eax,0x4                        ; user mode or supervisor?
  1219 00000A4F 7407                <1>     jz   int_handler_pgflt_bad_kaddr    ; if not, kernel failed
  1220                              <1> 
  1221                              <1> int_handler_pgflt_bad_uaddr :
  1222 00000A51 BE[B2060000]        <1>     mov  esi,int14umsg
  1223 00000A56 EB05                <1>     jmp  int_handler_pgflt_msg
  1224                              <1> 
  1225                              <1> int_handler_pgflt_bad_kaddr :
  1226 00000A58 BE[9A060000]        <1>     mov  esi,int14kmsg
  1227                              <1> 
  1228                              <1> int_handler_pgflt_msg :
  1229 00000A5D E8A2020000          <1>     call irq_print_msg
  1230 00000A62 0F20D0              <1>     mov  eax,cr2
  1231 00000A65 E83EFAFFFF          <1>     call putx_vga                       ; print the addres of the fault
  1232 00000A6A E901FFFFFF          <1>     jmp  int_handler_show_ec_eip
  1233                              <1> 
  1234 00000A6F 90                  <1> align 4
  1235                              <1> int_handler_fpuerr :
  1236 00000A70 56                  <1>     push esi
  1237 00000A71 BE[C7060000]        <1>     mov  esi,int16msg
  1238 00000A76 E889020000          <1>     call irq_print_msg
  1239                              <1>     ; FIXME flags identify error
  1240                              <1>     ;   IS - FPU stack overflow
  1241                              <1>     ;   IA - Invalid arithmetic operation
  1242                              <1>     ;   Z  - Divide by zero
  1243                              <1>     ;   D  - Source operand is a denormal number
  1244                              <1>     ;   O  - Overflow in result
  1245                              <1>     ;   U  - Underflow in result
  1246                              <1>     ;   P  - Inexact result
  1247 00000A7B E915FFFFFF          <1>     jmp  int_handler_show_eip
  1248                              <1> 
  1249                              <1> align 4
  1250                              <1> int_handler_algnchk :
  1251                              <1>     ; ec = zero
  1252 00000A80 56                  <1>     push esi
  1253 00000A81 BE[DB060000]        <1>     mov  esi,int17msg
  1254 00000A86 E879020000          <1>     call irq_print_msg
  1255 00000A8B 5E                  <1>     pop  esi
  1256 00000A8C 58                  <1>     pop  eax                    ; toss the ec
  1257 00000A8D E903FFFFFF          <1>     jmp  int_handler_show_eip
  1258                              <1> 
  1259 00000A92 90<rept>            <1> align 4
  1260                              <1> int_handler_machchk :
  1261 00000A94 56                  <1>     push esi
  1262 00000A95 BE[EC060000]        <1>     mov  esi,int18msg
  1263 00000A9A E865020000          <1>     call irq_print_msg
  1264 00000A9F 5E                  <1>     pop  esi
  1265 00000AA0 E9F0FEFFFF          <1>     jmp  int_handler_show_eip
  1266                              <1> 
  1267 00000AA5 90<rept>            <1> align 4
  1268                              <1> int_handler_simdfpe :
  1269 00000AA8 56                  <1>     push esi
  1270 00000AA9 BE[FB060000]        <1>     mov  esi,int19msg
  1271 00000AAE E851020000          <1>     call irq_print_msg
  1272 00000AB3 5E                  <1>     pop  esi
  1273 00000AB4 E9DCFEFFFF          <1>     jmp  int_handler_show_eip
  1274                              <1> 
  1275 00000AB9 90<rept>            <1> align 4
  1276                              <1> int_handler_timer :     
  1277 00000ABC 50                  <1>     push eax
  1278 00000ABD 53                  <1>     push ebx
  1279 00000ABE 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
  1280 00000AC2 8EE8                <1>     mov  gs,ax          
  1281 00000AC4 658A1D01000000      <1>     mov  bl,byte [gs:1]     ; inc the color of the first two chars
  1282 00000ACB FEC3                <1>     inc  bl
  1283 00000ACD 80E30F              <1>     and  bl,0xf             ; just the foreground
  1284 00000AD0 65881D01000000      <1>     mov  byte [gs:1],bl
  1285 00000AD7 65881D03000000      <1>     mov  byte [gs:3],bl
  1286 00000ADE 5B                  <1>     pop  ebx
  1287                              <1> 
  1288                              <1>     ; ---- wakeup any sleeping cpus (see syscall_sleep)
  1289                              <1> 
  1290 00000ADF A0[30030000]        <1>     mov  al,[enabled_lapic]
  1291 00000AE4 08C0                <1>     or   al,al
  1292 00000AE6 741B                <1>     jz   no_sleepers
  1293                              <1> 
  1294                              <1>     ; the race here is not important, we'll catch them on the next tick
  1295                              <1> 
  1296 00000AE8 A1[1C030000]        <1>     mov  eax,[sleepers]
  1297 00000AED 09C0                <1>     or   eax,eax
  1298 00000AEF 7412                <1>     jz   no_sleepers
  1299 00000AF1 C1E018              <1>     shl  eax,24                     ; FIXME can only handle 8 cpus
  1300 00000AF4 A31003E0FE          <1>     mov  dword [0xfee00310],eax     ; via the destination register ...
  1301 00000AF9 B8FE480000          <1>     mov  eax,0x04800 + wakeup_int   ; no shrthnd, fixed, logical, edge
  1302 00000AFE A30003E0FE          <1>     mov  dword [0xfee00300],eax
  1303                              <1> 
  1304                              <1> no_sleepers :
  1305 00000B03 B020                <1>     mov  al,0x20        
  1306 00000B05 E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1307 00000B07 58                  <1>     pop  eax
  1308 00000B08 CF                  <1>     iret                
  1309                              <1> 
  1310 00000B09 90<rept>            <1> align 4
  1311                              <1> int_handler_kbd :
  1312 00000B0C 50                  <1>     push eax
  1313 00000B0D 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
  1314 00000B11 8EE8                <1>     mov  gs,ax          
  1315                              <1> 
  1316 00000B13 53                  <1>     push ebx
  1317 00000B14 BB3C000000          <1>     mov  ebx,30*2
  1318 00000B19 E460                <1>     in   al,0x60
  1319 00000B1B 50                  <1>     push eax
  1320 00000B1C E877F9FFFF          <1>     call putbx_vga
  1321 00000B21 58                  <1>     pop  eax
  1322                              <1> 
  1323 00000B22 3C53                <1>     cmp  al,0x53            ; scan code for the DEL key
  1324 00000B24 0F8434020000        <1>     jz   reboot
  1325                              <1> 
  1326 00000B2A 65A044000000        <1>     mov  al,[gs:34*2]
  1327 00000B30 FEC0                <1>     inc  al
  1328 00000B32 65A244000000        <1>     mov  [gs:34*2],al       ; change a character on screen
  1329 00000B38 5B                  <1>     pop  ebx
  1330                              <1> 
  1331 00000B39 B020                <1>     mov  al,0x20
  1332 00000B3B E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1333                              <1> 
  1334 00000B3D 58                  <1>     pop  eax
  1335 00000B3E CF                  <1>     iret
  1336                              <1> 
  1337 00000B3F 90                  <1> align 4
  1338                              <1> int_handler_hw02 :          ; cascade
  1339 00000B40 56                  <1>     push esi
  1340 00000B41 BE[14070000]        <1>     mov  esi,int34msg
  1341 00000B46 E8B9010000          <1>     call irq_print_msg
  1342 00000B4B 5E                  <1>     pop  esi
  1343 00000B4C E907020000          <1>     jmp  reboot_on_alt_key
  1344                              <1> 
  1345 00000B51 90<rept>            <1> align 4
  1346                              <1> int_handler_hw03 :          ; serial port 2
  1347 00000B54 56                  <1>     push esi
  1348 00000B55 BE[1E070000]        <1>     mov  esi,int35msg
  1349 00000B5A E8A5010000          <1>     call irq_print_msg
  1350 00000B5F 5E                  <1>     pop  esi
  1351 00000B60 E9F3010000          <1>     jmp  reboot_on_alt_key
  1352                              <1> 
  1353 00000B65 90<rept>            <1> align 4
  1354                              <1> int_handler_hw04 :          ; serial port 1
  1355 00000B68 56                  <1>     push esi
  1356 00000B69 BE[28070000]        <1>     mov  esi,int36msg
  1357 00000B6E E891010000          <1>     call irq_print_msg
  1358 00000B73 5E                  <1>     pop  esi
  1359 00000B74 E9DF010000          <1>     jmp  reboot_on_alt_key
  1360                              <1> 
  1361 00000B79 90<rept>            <1> align 4
  1362                              <1> int_handler_hw05 :          ; parallel port 2 or sound card
  1363 00000B7C 56                  <1>     push esi
  1364 00000B7D BE[32070000]        <1>     mov  esi,int37msg
  1365 00000B82 E87D010000          <1>     call irq_print_msg
  1366 00000B87 5E                  <1>     pop  esi
  1367 00000B88 E9CB010000          <1>     jmp  reboot_on_alt_key
  1368                              <1> 
  1369 00000B8D 90<rept>            <1> align 4
  1370                              <1> int_handler_hw06 :          ; floppy disk controller
  1371 00000B90 56                  <1>     push esi
  1372 00000B91 BE[3C070000]        <1>     mov  esi,int38msg
  1373 00000B96 E869010000          <1>     call irq_print_msg
  1374 00000B9B 5E                  <1>     pop  esi
  1375 00000B9C E9B7010000          <1>     jmp  reboot_on_alt_key
  1376                              <1> 
  1377 00000BA1 90<rept>            <1> align 4
  1378                              <1> int_handler_hw07 :          ; parallel port 1
  1379 00000BA4 56                  <1>     push esi
  1380 00000BA5 BE[46070000]        <1>     mov  esi,int39msg
  1381 00000BAA E855010000          <1>     call irq_print_msg
  1382 00000BAF 5E                  <1>     pop  esi
  1383 00000BB0 B020                <1>     mov  al,0x20
  1384 00000BB2 E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1385 00000BB4 CF                  <1>     iret
  1386                              <1>     ;jmp  reboot_on_alt_key
  1387                              <1> 
  1388 00000BB5 90<rept>            <1> align 4
  1389                              <1> int_handler_hw08 :          ; RTC
  1390 00000BB8 56                  <1>     push esi
  1391 00000BB9 BE[50070000]        <1>     mov  esi,int40msg
  1392 00000BBE E841010000          <1>     call irq_print_msg
  1393 00000BC3 5E                  <1>     pop  esi
  1394 00000BC4 E98F010000          <1>     jmp  reboot_on_alt_key
  1395                              <1> 
  1396 00000BC9 90<rept>            <1> align 4
  1397                              <1> int_handler_hw09 :          ; acpi
  1398 00000BCC 56                  <1>     push esi
  1399 00000BCD BE[5A070000]        <1>     mov  esi,int41msg
  1400 00000BD2 E82D010000          <1>     call irq_print_msg
  1401 00000BD7 5E                  <1>     pop  esi
  1402 00000BD8 E97B010000          <1>     jmp  reboot_on_alt_key
  1403                              <1> 
  1404 00000BDD 90<rept>            <1> align 4
  1405                              <1> int_handler_hw10 :
  1406 00000BE0 56                  <1>     push esi
  1407 00000BE1 BE[64070000]        <1>     mov  esi,int42msg
  1408 00000BE6 E819010000          <1>     call irq_print_msg
  1409 00000BEB 5E                  <1>     pop  esi
  1410 00000BEC E967010000          <1>     jmp  reboot_on_alt_key
  1411                              <1> 
  1412 00000BF1 90<rept>            <1> align 4
  1413                              <1> int_handler_hw11 :
  1414 00000BF4 56                  <1>     push esi
  1415 00000BF5 BE[6E070000]        <1>     mov  esi,int43msg
  1416 00000BFA E805010000          <1>     call irq_print_msg
  1417 00000BFF 5E                  <1>     pop  esi
  1418 00000C00 E953010000          <1>     jmp  reboot_on_alt_key
  1419                              <1> 
  1420 00000C05 90<rept>            <1> align 4
  1421                              <1> int_handler_hw12 :          ; mouse
  1422 00000C08 56                  <1>     push esi
  1423 00000C09 BE[78070000]        <1>     mov  esi,int44msg
  1424 00000C0E E8F1000000          <1>     call irq_print_msg
  1425 00000C13 5E                  <1>     pop  esi
  1426 00000C14 E93F010000          <1>     jmp  reboot_on_alt_key
  1427                              <1> 
  1428 00000C19 90<rept>            <1> align 4
  1429                              <1> int_handler_hw13 :          ; co-processor
  1430 00000C1C 56                  <1>     push esi
  1431 00000C1D BE[82070000]        <1>     mov  esi,int45msg
  1432 00000C22 E8DD000000          <1>     call irq_print_msg
  1433 00000C27 5E                  <1>     pop  esi
  1434 00000C28 E92B010000          <1>     jmp  reboot_on_alt_key
  1435                              <1> 
  1436 00000C2D 90<rept>            <1> align 4
  1437                              <1> int_handler_hw14 :          ; ata disk controller primary
  1438 00000C30 56                  <1>     push esi
  1439 00000C31 BE[8C070000]        <1>     mov  esi,int46msg
  1440 00000C36 E8C9000000          <1>     call irq_print_msg
  1441 00000C3B 5E                  <1>     pop  esi
  1442 00000C3C E917010000          <1>     jmp  reboot_on_alt_key
  1443                              <1> 
  1444 00000C41 90<rept>            <1> align 4
  1445                              <1> int_handler_hw15 :          ; ata disk controller secondary
  1446 00000C44 56                  <1>     push esi
  1447 00000C45 BE[96070000]        <1>     mov  esi,int47msg
  1448 00000C4A E8B5000000          <1>     call irq_print_msg
  1449 00000C4F 5E                  <1>     pop  esi
  1450 00000C50 E903010000          <1>     jmp  reboot_on_alt_key
  1451                              <1> 
  1452                              <1> ; called via the double fault task
  1453 00000C55 90<rept>            <1> align 4
  1454                              <1> int_handler_tg_dblflt :
  1455 00000C58 56                  <1>     push esi
  1456 00000C59 BE[26060000]        <1>     mov  esi,int08msg
  1457 00000C5E E8A1000000          <1>     call irq_print_msg
  1458 00000C63 5E                  <1>     pop  esi
  1459 00000C64 E9EF000000          <1>     jmp  reboot_on_alt_key
  1460                              <1> 
  1461                              <1> ; called via the invalid tss task
  1462 00000C69 90<rept>            <1> align 4
  1463                              <1> int_handler_tg_invtss :
  1464 00000C6C 56                  <1>     push esi
  1465 00000C6D BE[51060000]        <1>     mov  esi,int10msg
  1466 00000C72 E88D000000          <1>     call irq_print_msg
  1467 00000C77 5E                  <1>     pop  esi
  1468                              <1>     ; FIXME need to go back to previous tss to get ec via that stack
  1469 00000C78 83C302              <1>     add  ebx,2
  1470 00000C7B 58                  <1>     pop  eax                ; ec == invalid tss selector
  1471 00000C7C E827F8FFFF          <1>     call putx_vga
  1472 00000C81 E9D2000000          <1>     jmp  reboot_on_alt_key
  1473                              <1> 
  1474 00000C86 90<rept>            <1> align 4
  1475                              <1> int_handler_spurious :
  1476 00000C88 56                  <1>     push esi
  1477 00000C89 BE[A0070000]        <1>     mov  esi,spuriousmsg
  1478 00000C8E E871000000          <1>     call irq_print_msg
  1479 00000C93 5E                  <1>     pop  esi
  1480 00000C94 CF                  <1>     iret
  1481                              <1> 
  1482 00000C95 90<rept>            <1> align 4
  1483                              <1> int_handler_apicerr :
  1484 00000C98 56                  <1>     push esi
  1485 00000C99 BE[AE070000]        <1>     mov  esi,apicerrmsg
  1486 00000C9E E861000000          <1>     call irq_print_msg
  1487 00000CA3 5E                  <1>     pop  esi
  1488 00000CA4 CF                  <1>     iret
  1489                              <1> 
  1490                              <1> ; serves only to eoi the fixed ipi used for sleep wakeup
  1491 00000CA5 90<rept>            <1> align 4
  1492                              <1> wakeup :
  1493 00000CA8 50                  <1>     push eax
  1494 00000CA9 31C0                <1>     xor  eax,eax
  1495 00000CAB A3B000E0FE          <1>     mov  [0xfee000b0],eax    ; lapic eoi
  1496 00000CB0 58                  <1>     pop  eax
  1497 00000CB1 CF                  <1>     iret
  1498                              <1> 
  1499                              <1> 
  1500 00000CB2 90<rept>            <1> align 4
  1501                              <1> ; %if ($ >= 0x8000) bomb
  1502                              <1> sysent :
  1503 00000CB4 3D00020000          <1>     cmp  eax,0x0200
  1504 00000CB9 0F84D5020000        <1>     jz   syscall_klog
  1505 00000CBF 3D00100000          <1>     cmp  eax,0x1000
  1506 00000CC4 0F84DF020000        <1>     jz   syscall_ncpus
  1507 00000CCA 3D00200000          <1>     cmp  eax,0x2000
  1508 00000CCF 0F8439030000        <1>     jz   syscall_sleep
  1509 00000CD5 3D00210000          <1>     cmp  eax,0x2100
  1510 00000CDA 0F84CF020000        <1>     jz   syscall_new_thread
  1511 00000CE0 3D00270000          <1>     cmp  eax,0x2700
  1512 00000CE5 0F8458030000        <1>     jz   syscall_request_pmem_access
  1513 00000CEB 3D00FE0000          <1>     cmp  eax,0xfe00
  1514 00000CF0 0F84AD020000        <1>     jz   syscall_sipi_vector
  1515 00000CF6 BE[BF070000]        <1>     mov  esi,int255msg
  1516 00000CFB E804000000          <1>     call irq_print_msg
  1517 00000D00 31C0                <1>     xor  eax,eax
  1518 00000D02 48                  <1>     dec  eax
  1519 00000D03 CF                  <1>     iret
  1520                              <1> 
  1521                              <1> 
  1522                              <1> ; ---- IRQ support code ---- 
  1523                              <1> 
  1524                              <1> irq_print_msg :
  1525 00000D04 B801000000          <1>     mov  eax,1
  1526 00000D09 0FC105[E0070000]    <1>     xadd [irq_err_lno],eax
  1527 00000D10 50                  <1>     push eax                ; remember line number
  1528 00000D11 83E003              <1>     and  eax,0x3            ; only four lines
  1529 00000D14 40                  <1>     inc  eax                ; start with line 1
  1530 00000D15 BBA0000000          <1>     mov  ebx,160            ; vga line length
  1531 00000D1A 0FAFC3              <1>     imul eax,ebx
  1532 00000D1D 89C3                <1>     mov  ebx,eax
  1533                              <1> 
  1534 00000D1F A0[30030000]        <1>     mov  al,[enabled_lapic]
  1535 00000D24 08C0                <1>     or   al,al
  1536 00000D26 58                  <1>     pop  eax
  1537 00000D27 742A                <1>     jz   skip_cpumsg
  1538                              <1> 
  1539 00000D29 56                  <1>     push esi
  1540 00000D2A 50                  <1>     push eax
  1541 00000D2B BE[9E050000]        <1>     mov  esi,cpumsg
  1542 00000D30 E84CF7FFFF          <1>     call puts_vga
  1543 00000D35 A12000E0FE          <1>     mov  eax,[0xfee00020]   ; print our apic id
  1544 00000D3A C1E818              <1>     shr  eax,24
  1545 00000D3D 83C030              <1>     add  eax,'0'
  1546 00000D40 658803              <1>     mov  [gs:ebx],al
  1547 00000D43 58                  <1>     pop  eax                ; recover line number
  1548 00000D44 C0E802              <1>     shr  al,2               ; provide a rolling effect for
  1549 00000D47 240F                <1>     and  al,0xf             ;     unending irq messages
  1550 00000D49 0C08                <1>     or   al,0x8
  1551 00000D4B 65884301            <1>     mov  [gs:ebx+1],al
  1552 00000D4F 83C304              <1>     add  ebx,4
  1553 00000D52 5E                  <1>     pop  esi
  1554                              <1> 
  1555                              <1> skip_cpumsg :
  1556 00000D53 E929F7FFFF          <1>     jmp  puts_vga
  1557                              <1> 
  1558                              <1> 
  1559                              <1> reboot_on_alt_key :
  1560                              <1> reboot_on_alt_key_loop :
  1561 00000D58 E460                <1>     in   al,0x60
  1562 00000D5A 3C53                <1>     cmp  al,0x53            ; scan code for the DEL key
  1563 00000D5C 75FA                <1>     jnz  reboot_on_alt_key_loop
  1564                              <1> reboot :
  1565 00000D5E 0F011D[8A0D0000]    <1>     lidt [reboot_idt]       ; restore boot idt (helps qemu ...)
  1566 00000D65 EA[6C0D0000]2800    <1>     jmp  rmcssel:reboot_exit_pmode      ; thankyou hpa
  1567                              <1> reboot_exit_pmode :
  1568                              <1> bits 16
  1569 00000D6C B83000              <1>     mov  ax,rmdssel
  1570 00000D6F 8ED8                <1>     mov  ds,ax
  1571 00000D71 8EC0                <1>     mov  es,ax
  1572 00000D73 8ED0                <1>     mov  ss,ax
  1573 00000D75 8EE0                <1>     mov  fs,ax
  1574 00000D77 8EE8                <1>     mov  gs,ax
  1575                              <1> 
  1576 00000D79 0F20C0              <1>     mov  eax,cr0
  1577 00000D7C 6625FEFFFF7F        <1>     and  eax,0x7ffffffe
  1578 00000D82 0F22C0              <1>     mov  cr0,eax            ; disable pmode and paging
  1579 00000D85 EA0000FFFF          <1>     jmp  0xffff:0           ; jump to the warm start vector and
  1580                              <1>                             ; flush the I prefetch queue all at once
  1581                              <1> 
  1582                              <1> reboot_idt :
  1583 00000D8A FFFF                <1>     dw 0xffff
  1584 00000D8C 00000000            <1>     dd 0
  1585                              <1> 
  1586                              <1> 
  1587                              <1> ; ---- IDT initialization table ---- 
  1588                              <1> ;
  1589                              <1> ; One dw (2 bytes per vector) is used which means that all
  1590                              <1> ; int_handler entry points must reside below 0x10000!
  1591                              <1> ;
  1592                              <1> ; And since all int_handler routines are 4 byte aligned,
  1593                              <1> ; the bottom two bits are available to indicate type.
  1594                              <1> ; These bits index into the irq_types table below.
  1595                              <1> 
  1596                              <1> align 4
  1597                              <1> 
  1598                              <1> ; note: these are not gdt/ldt descriptors (see swdev3a 6.11 pg 228)
  1599                              <1> 
  1600 00000D90 8E                  <1> irq_types   db  0x8e            ; dpl=0 32bit interrupt gate (sets IF flag)
  1601 00000D91 EE                  <1>             db  0xee            ; dpl=3 32bit app (ring3) interrupt gate
  1602 00000D92 85                  <1>             db  0x85            ; dpl=0 32bit task gate
  1603 00000D93 8F                  <1>             db  0x8f            ; dpl=0 32bit trap gate (does not set IF flag)
  1604                              <1> 
  1605                              <1> ; all handlers/selectors are 4 byte aligned - this gives us
  1606                              <1> ; two bits to use to designate 1 of 4 types of idt descriptors ...
  1607                              <1> 
  1608                              <1> irqt_intr   equ 0
  1609                              <1> irqt_app    equ 1
  1610                              <1> irqt_task   equ 2
  1611                              <1> irqt_trap   equ 3
  1612                              <1> 
  1613                              <1> irq_setup_table:
  1614                              <1>     ; cpu defined
  1615 00000D94 [9B08]              <1>     dw  int_handler_div0      + irqt_trap ; 0
  1616 00000D96 [AF08]              <1>     dw  int_handler_debug     + irqt_trap ; 1
  1617 00000D98 [C008]              <1>     dw  int_handler_nmi       + irqt_intr ; 2
  1618 00000D9A [D108]              <1>     dw  int_handler_brkp      + irqt_app  ; 3
  1619 00000D9C [E508]              <1>     dw  int_handler_ovrflw    + irqt_app  ; 4
  1620 00000D9E [F908]              <1>     dw  int_handler_bound     + irqt_app  ; 5
  1621 00000DA0 [0F09]              <1>     dw  int_handler_invop     + irqt_trap ; 6
  1622 00000DA2 [1F09]              <1>     dw  int_handler_devna     + irqt_trap ; 7
  1623 00000DA4 4200                <1>     dw  tasksel_f08           + irqt_task ; 8   double fault
  1624 00000DA6 [2309]              <1>     dw  int_handler_cpsego    + irqt_trap ; 9
  1625 00000DA8 4A00                <1>     dw  tasksel_f10           + irqt_task ; 10  invalid tss
  1626 00000DAA [3309]              <1>     dw  int_handler_segnp     + irqt_trap ; 11
  1627 00000DAC [4309]              <1>     dw  int_handler_stkflt    + irqt_trap ; 12
  1628 00000DAE [6709]              <1>     dw  int_handler_gpf       + irqt_trap ; 13
  1629 00000DB0 [480A]              <1>     dw  int_handler_pgflt     + irqt_intr ; 14
  1630 00000DB2 0000                <1>     dw  0                                 ; 15  Intel reserved
  1631 00000DB4 [730A]              <1>     dw  int_handler_fpuerr    + irqt_trap ; 16
  1632 00000DB6 [830A]              <1>     dw  int_handler_algnchk   + irqt_trap ; 17
  1633 00000DB8 [970A]              <1>     dw  int_handler_machchk   + irqt_trap ; 18
  1634 00000DBA [AB0A]              <1>     dw  int_handler_simdfpe   + irqt_trap ; 19
  1635 00000DBC 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0
  1636 00000DC5 000000000000000000- <1>
  1637 00000DCE 000000000000        <1>
  1638                              <1>     ; hw defined
  1639                              <1> apic0_irqbase equ ($ - irq_setup_table)/2
  1640 00000DD4 [BC0A]              <1>     dw  int_handler_timer     + irqt_intr ; 32  0x20
  1641 00000DD6 [0C0B]              <1>     dw  int_handler_kbd       + irqt_intr ; 33
  1642 00000DD8 [400B]              <1>     dw  int_handler_hw02      + irqt_intr ; 34
  1643 00000DDA [540B]              <1>     dw  int_handler_hw03      + irqt_intr ; 35
  1644 00000DDC [680B]              <1>     dw  int_handler_hw04      + irqt_intr ; 36
  1645 00000DDE [7C0B]              <1>     dw  int_handler_hw05      + irqt_intr ; 37
  1646 00000DE0 [900B]              <1>     dw  int_handler_hw06      + irqt_intr ; 38
  1647 00000DE2 [A40B]              <1>     dw  int_handler_hw07      + irqt_intr ; 39
  1648                              <1> apic1_irqbase equ ($ - irq_setup_table)/2
  1649 00000DE4 [B80B]              <1>     dw  int_handler_hw08      + irqt_intr ; 40
  1650 00000DE6 [CC0B]              <1>     dw  int_handler_hw09      + irqt_intr ; 41
  1651 00000DE8 [E00B]              <1>     dw  int_handler_hw10      + irqt_intr ; 42
  1652 00000DEA [F40B]              <1>     dw  int_handler_hw11      + irqt_intr ; 43
  1653 00000DEC [080C]              <1>     dw  int_handler_hw12      + irqt_intr ; 44
  1654 00000DEE [1C0C]              <1>     dw  int_handler_hw13      + irqt_intr ; 45
  1655 00000DF0 [300C]              <1>     dw  int_handler_hw14      + irqt_intr ; 46
  1656 00000DF2 [440C]              <1>     dw  int_handler_hw15      + irqt_intr ; 47  0x2f
  1657                              <1>     ; undefined - hw can expand here
  1658 00000DF4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x30
  1659 00000DFD 000000000000000000- <1>
  1660 00000E06 000000000000000000- <1>
  1661 00000E0F 0000000000          <1>
  1662 00000E14 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x40
  1663 00000E1D 000000000000000000- <1>
  1664 00000E26 000000000000000000- <1>
  1665 00000E2F 0000000000          <1>
  1666 00000E34 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x50
  1667 00000E3D 000000000000000000- <1>
  1668 00000E46 000000000000000000- <1>
  1669 00000E4F 0000000000          <1>
  1670 00000E54 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x60
  1671 00000E5D 000000000000000000- <1>
  1672 00000E66 000000000000000000- <1>
  1673 00000E6F 0000000000          <1>
  1674 00000E74 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x70
  1675 00000E7D 000000000000000000- <1>
  1676 00000E86 000000000000000000- <1>
  1677 00000E8F 0000000000          <1>
  1678 00000E94 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x80
  1679 00000E9D 000000000000000000- <1>
  1680 00000EA6 000000000000000000- <1>
  1681 00000EAF 0000000000          <1>
  1682 00000EB4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x90
  1683 00000EBD 000000000000000000- <1>
  1684 00000EC6 000000000000000000- <1>
  1685 00000ECF 0000000000          <1>
  1686 00000ED4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xa0
  1687 00000EDD 000000000000000000- <1>
  1688 00000EE6 000000000000000000- <1>
  1689 00000EEF 0000000000          <1>
  1690                              <1>     ; set up cpu thread management tss gates
  1691                              <1>     ; these map 1-to-1 to cpus
  1692                              <1> first_thread_tss_gate equ ($ - irq_setup_table)/2
  1693 00000EF4 5A00                <1>     dw  tasksel_u00           + irqt_task
  1694 00000EF6 6A00                <1>     dw  tasksel_u01           + irqt_task
  1695 00000EF8 7A00                <1>     dw  tasksel_u02           + irqt_task
  1696 00000EFA 8A00                <1>     dw  tasksel_u03           + irqt_task
  1697 00000EFC 9A00                <1>     dw  tasksel_u04           + irqt_task
  1698 00000EFE AA00                <1>     dw  tasksel_u05           + irqt_task
  1699 00000F00 BA00                <1>     dw  tasksel_u06           + irqt_task
  1700 00000F02 CA00                <1>     dw  tasksel_u07           + irqt_task
  1701                              <1> %ifdef FOO
  1702                              <1>     dw  tasksel_u08           + irqt_task
  1703                              <1>     dw  tasksel_u09           + irqt_task
  1704                              <1>     dw  tasksel_u10           + irqt_task
  1705                              <1>     dw  tasksel_u11           + irqt_task
  1706                              <1>     dw  tasksel_u12           + irqt_task
  1707                              <1>     dw  tasksel_u13           + irqt_task
  1708                              <1>     dw  tasksel_u14           + irqt_task
  1709                              <1>     dw  tasksel_u15           + irqt_task
  1710                              <1> %endif
  1711 00000F04 000000000000000000- <1>     dw                  0,0,0,0,0,0,0,0   ; 0xb0
  1712 00000F0D 00000000000000      <1>
  1713 00000F14 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xc0
  1714 00000F1D 000000000000000000- <1>
  1715 00000F26 000000000000000000- <1>
  1716 00000F2F 0000000000          <1>
  1717 00000F34 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xd0
  1718 00000F3D 000000000000000000- <1>
  1719 00000F46 000000000000000000- <1>
  1720 00000F4F 0000000000          <1>
  1721 00000F54 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     ; 0xe0
  1722 00000F5D 000000000000000000- <1>
  1723 00000F66 000000000000000000- <1>
  1724 00000F6F 000000              <1>
  1725                              <1> spurious_int equ ($ - irq_setup_table)/2
  1726 00000F72 [880C]              <1>     dw  int_handler_spurious  + irqt_intr
  1727                              <1> apicerr_int equ ($ - irq_setup_table)/2
  1728 00000F74 [990C]              <1>     dw  int_handler_apicerr   + irqt_app
  1729 00000F76 000000000000000000- <1>     dw    0,0,0,0,0,0,0,0,0,0,0,0,0       ; 0xf0
  1730 00000F7F 000000000000000000- <1>
  1731 00000F88 0000000000000000    <1>
  1732                              <1>     ; sw defined - expand down if needed
  1733                              <1> wakeup_int equ ($ - irq_setup_table)/2
  1734 00000F90 [A90C]              <1>     dw  wakeup                + irqt_app
  1735 00000F92 [B50C]              <1>     dw  sysent                + irqt_app  ; 256  0xff
  1736                              <1> irq_setup_table_size equ ($ - irq_setup_table)/2
  1737                              <1> 
  1738                                  
  1739                                  ; -------- system calls --------
  1740                                  %include "ozsys.asm"
  1741                              <1> ; OZ - A more utopian OS    x86-32 system calls
  1742                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
  1743                              <1> ;
  1744                              <1> ; Copyright (C) 2015  Duane Voth
  1745                              <1> ;
  1746                              <1> ;   This program is free software: you can redistribute it and/or modify
  1747                              <1> ;   it under the terms of the GNU Affero General Public License as
  1748                              <1> ;   published by the Free Software Foundation, either version 3 of the
  1749                              <1> ;   License, or (at your option) any later version.
  1750                              <1> ;
  1751                              <1> ;   This program is distributed in the hope that it will be useful,
  1752                              <1> ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
  1753                              <1> ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1754                              <1> ;   GNU Affero General Public License for more details.
  1755                              <1> ;
  1756                              <1> ;   You should have received a copy of the GNU Affero General Public License
  1757                              <1> ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
  1758                              <1> ;
  1759                              <1> ;
  1760                              <1> ; OZ System Calls  (for ozapps)
  1761                              <1> 
  1762                              <1> bits 32
  1763                              <1> 
  1764                              <1> ;------------------------------------------------------------------
  1765                              <1> ;   syscall_klog : place a message on the vga line reserved for klog  :D
  1766                              <1> ;
  1767                              <1> ;   entry:
  1768                              <1> ;       esi = message address
  1769                              <1> ;   exit:
  1770                              <1> 
  1771                              <1> syscall_klog :
  1772 00000F94 53                  <1>     push ebx
  1773 00000F95 BB20030000          <1>     mov  ebx,5 * 160        ; line 6
  1774 00000F9A E8E2F4FFFF          <1>     call puts_vga
  1775 00000F9F 5B                  <1>     pop  ebx
  1776 00000FA0 31C0                <1>     xor  eax,eax
  1777 00000FA2 CF                  <1>     iret
  1778                              <1> 
  1779                              <1> ;------------------------------------------------------------------
  1780                              <1> ;   syscall_sipi_vector : get the entry vector for non-boot cpus
  1781                              <1> ;
  1782                              <1> ;   entry:
  1783                              <1> ;   exit:
  1784                              <1> ;       eax = N cpus
  1785                              <1> 
  1786                              <1> syscall_sipi_vector :
  1787 00000FA3 B800700000          <1>     mov  eax,sipi_vector
  1788 00000FA8 CF                  <1>     iret
  1789                              <1> 
  1790                              <1> ;------------------------------------------------------------------
  1791                              <1> ;   syscall_ncpus : get how many cpu threads are running
  1792                              <1> ;
  1793                              <1> ;   entry:
  1794                              <1> ;   exit:
  1795                              <1> ;       eax = N cpus
  1796                              <1> 
  1797                              <1> syscall_ncpus :
  1798 00000FA9 A1[14030000]        <1>     mov  eax,[ncpus]
  1799 00000FAE CF                  <1>     iret
  1800                              <1> 
  1801                              <1> ;------------------------------------------------------------------
  1802                              <1> ;   syscall_new_thread : ask for another cpu to execute code in
  1803                              <1> ;                        the current app
  1804                              <1> ;
  1805                              <1> ;   This implementation is quite a bit of a hack - apps can basically
  1806                              <1> ;   commendere any specific non-boot cpu they want ...
  1807                              <1> ;
  1808                              <1> ;   entry:
  1809                              <1> ;       edx = function start address in the app
  1810                              <1> ;       ecx = address of the top of the app's new thread stack
  1811                              <1> ;       ebx = app's new thread index
  1812                              <1> ;   exit:
  1813                              <1> ;       eax = 0 success, -1 failure
  1814                              <1> 
  1815                              <1> syscall_new_thread :
  1816 00000FAF 09DB                <1>     or   ebx,ebx
  1817 00000FB1 7459                <1>     jz   new_thread_fail        ; don't get to ask for cpu 0
  1818                              <1> 
  1819 00000FB3 31C0                <1>     xor  eax,eax
  1820 00000FB5 A0[30030000]        <1>     mov  al,[enabled_lapic]     ; if the lapics are not enabled,
  1821 00000FBA 08C0                <1>     or   al,al                  ; none of this is useful
  1822 00000FBC 744E                <1>     jz   new_thread_fail
  1823                              <1> 
  1824                              <1>     ; setup the tss
  1825                              <1>     ; slightly squirly - get the tss address from the task selector
  1826                              <1>     ; but there could be a race here: ncpus is updated before
  1827                              <1>     ; create_tss_pair is called, so the task selector could be zero!
  1828                              <1> 
  1829 00000FBE 89DF                <1>     mov  edi,ebx
  1830 00000FC0 C1E704              <1>     shl  edi,4                  ; 8 byte selectors in pairs
  1831 00000FC3 83C758              <1>     add  edi,tasksel_u00
  1832 00000FC6 8BB7[02000000]      <1>     mov  esi,[gdt+edi+2]
  1833 00000FCC 81E6FFFFFF00        <1>     and  esi,0xffffff
  1834 00000FD2 31C0                <1>     xor  eax,eax
  1835 00000FD4 8A87[07000000]      <1>     mov  al,[gdt+edi+7]
  1836 00000FDA C1E018              <1>     shl  eax,24
  1837 00000FDD 09C6                <1>     or   esi,eax
  1838 00000FDF 742B                <1>     jz   new_thread_fail        ; cpu isn't yet ready ...
  1839                              <1> 
  1840                              <1>     ; really should check the previous task link to see if this
  1841                              <1>     ; cpu is busy ...
  1842                              <1> 
  1843 00000FE1 894E38              <1>     mov  [esi+(tss0_esp-tss0)],ecx  ; set the app's stack
  1844 00000FE4 895620              <1>     mov  [esi+(tss0_eip-tss0)],edx  ; set the ip to the entry point
  1845                              <1> 
  1846                              <1>     ; lookup the requested cpu's int/taskgate gdt selector
  1847                              <1> 
  1848 00000FE7 89DF                <1>     mov  edi,ebx
  1849 00000FE9 81C7B0000000        <1>     add  edi,first_thread_tss_gate  ; convert ebx to int/taskgate number
  1850                              <1> 
  1851                              <1>     ; ipi a cpu.  no fancy affinity scheduling yet,
  1852                              <1>     ; just let the app ask for a specific cpu to do the work
  1853                              <1> 
  1854 00000FEF B800000001          <1>     mov  eax,0x01000000
  1855 00000FF4 89D9                <1>     mov  ecx,ebx                    ; recover requested cpu number
  1856 00000FF6 D3E0                <1>     shl  eax,cl                     ; form the icr destination field
  1857                              <1> 
  1858                              <1>     ; poke the cpu that matches our thread index - we only get 8 :/
  1859                              <1> 
  1860 00000FF8 A31003E0FE          <1>     mov  dword [0xfee00310],eax
  1861 00000FFD B800480000          <1>     mov  eax,0x4800                 ; no shorthand, fixed, logical, edge
  1862 00001002 09F8                <1>     or   eax,edi                    ; make int/taskgate number the vector
  1863 00001004 A30003E0FE          <1>     mov  dword [0xfee00300],eax
  1864                              <1> 
  1865 00001009 31C0                <1>     xor  eax,eax
  1866 0000100B CF                  <1>     iret
  1867                              <1> 
  1868                              <1> new_thread_fail :
  1869 0000100C 48                  <1>     dec  eax                    ; -1
  1870 0000100D C3                  <1>     ret
  1871                              <1> 
  1872                              <1> ;------------------------------------------------------------------
  1873                              <1> ;   syscall_sleep : wait for N timer interrupts
  1874                              <1> ;
  1875                              <1> ;   entry:
  1876                              <1> ;       edx = N ticks
  1877                              <1> ;   exit:
  1878                              <1> 
  1879                              <1> syscall_sleep :
  1880 0000100E A0[30030000]        <1>     mov  al,[enabled_lapic]
  1881 00001013 08C0                <1>     or   al,al
  1882 00001015 7415                <1>     jz   sleep_loop
  1883                              <1> 
  1884 00001017 A12000E0FE          <1>     mov  eax,[0xfee00020]
  1885 0000101C C1E818              <1>     shr  eax,24
  1886 0000101F 09C0                <1>     or   eax,eax
  1887 00001021 7409                <1>     jz   sleep_loop         ; the boot cpu services the timer int
  1888 00001023 88C1                <1>     mov  cl,al              ; so don't add it to the sleeper list
  1889 00001025 B801000000          <1>     mov  eax,1
  1890 0000102A D3E0                <1>     shl  eax,cl
  1891                              <1> 
  1892                              <1> sleep_loop :
  1893 0000102C F00905[1C030000]    <1>     lock or [sleepers],eax  ; announce we are sleeping
  1894 00001033 FB                  <1>     sti
  1895 00001034 F4                  <1>     hlt                     ; wait for an int to wake us up
  1896 00001035 4A                  <1>     dec  edx                ; decrement the tick count
  1897 00001036 75F4                <1>     jnz  sleep_loop
  1898                              <1> 
  1899 00001038 83F0FF              <1>     xor  eax,-1
  1900 0000103B F02105[1C030000]    <1>     lock and [sleepers],eax ; renounce sleepiness
  1901 00001042 CF                  <1>     iret
  1902                              <1> 
  1903                              <1> ;------------------------------------------------------------------
  1904                              <1> ;   syscall_request_pmem_access : ask for access to a physical
  1905                              <1> ;            memory address
  1906                              <1> ;
  1907                              <1> ;   entry:
  1908                              <1> ;       edx = phys memory address
  1909                              <1> ;
  1910                              <1> ;   exit:
  1911                              <1> ;       (need to return a logical address in eax)  For now just
  1912                              <1> ;       direct maps the physical address into logical addr space.
  1913                              <1> 
  1914                              <1> syscall_request_pmem_access :
  1915 00001043 E801000000          <1>     call map_pmem
  1916 00001048 CF                  <1>     iret
  1917                              <1> 
  1918                              <1> ;------------------------------------------------------------------
  1919                              <1> ;   map_pmem - add entries to the current page directory/table
  1920                              <1> ;              to direct map the requested physical memory address
  1921                              <1> ;              (logical identical to physical for now)
  1922                              <1> ;
  1923                              <1> ;   entry:
  1924                              <1> ;       edx = phys memory address
  1925                              <1> ;
  1926                              <1> ;   returns:
  1927                              <1> ;       (need to return a logical address in eax)  For now just
  1928                              <1> ;       direct maps the physical address into logical addr space.
  1929                              <1> ;       eax =  0 success
  1930                              <1> ;       eax = -1 fail
  1931                              <1> 
  1932                              <1> map_pmem :
  1933 00001049 53                  <1>     push ebx
  1934 0000104A 57                  <1>     push edi
  1935                              <1> 
  1936 0000104B 0F013A              <1>     invlpg [edx]
  1937 0000104E 52                  <1>     push edx
  1938 0000104F 0F20DB              <1>     mov  ebx,cr3
  1939 00001052 81E300F0FFFF        <1>     and  ebx,0xfffff000
  1940 00001058 89D7                <1>     mov  edi,edx
  1941 0000105A 81E70000C0FF        <1>     and  edi,0xffc00000
  1942 00001060 C1EF14              <1>     shr  edi,(22 - 2)           ; calc page directory index
  1943 00001063 81E200F03F00        <1>     and  edx,0x003ff000
  1944 00001069 C1EA0A              <1>     shr  edx,(12 - 2)           ; calc page table index
  1945                              <1> 
  1946 0000106C 8B043B              <1>     mov  eax,[ebx+edi]
  1947 0000106F 09C0                <1>     or   eax,eax                ; is there a page table here?
  1948 00001071 750F                <1>     jnz  map_pmem_have_pgtbl
  1949 00001073 E85BF4FFFF          <1>     call mem_alloc_kernel_page
  1950 00001078 09C0                <1>     or   eax,eax
  1951 0000107A 741F                <1>     jz   map_pmem_fail
  1952 0000107C C1E00C              <1>     shl  eax,12                 ; convert pgno to pgtbl entry
  1953 0000107F 89043B              <1>     mov  [ebx+edi],eax          ; update page table
  1954                              <1> 
  1955                              <1> map_pmem_have_pgtbl :
  1956                              <1>     ; for now, no security check, just direct map the address
  1957                              <1>     ; and mark the pages and the page table r/w by all
  1958 00001082 830C3B07            <1>     or   dword [ebx+edi],7      ; user, r/w, present
  1959                              <1> 
  1960 00001086 8B1C3B              <1>     mov  ebx,[ebx+edi]
  1961 00001089 81E300F0FFFF        <1>     and  ebx,0xfffff000
  1962 0000108F 58                  <1>     pop  eax                    ; recover requested phys mem addr
  1963                              <1>     ; FIXME yup, big security hole if called by ring 0! And it is ...
  1964 00001090 83C807              <1>     or   eax,7                  ; user, r/w, present
  1965 00001093 890413              <1>     mov  [ebx+edx],eax          ; update page directory
  1966 00001096 31C0                <1>     xor  eax,eax                ; 0
  1967                              <1> map_pmem_exit :
  1968 00001098 5F                  <1>     pop  edi
  1969 00001099 5B                  <1>     pop  ebx
  1970 0000109A C3                  <1>     ret
  1971                              <1> 
  1972                              <1> map_pmem_fail :
  1973 0000109B 48                  <1>     dec  eax                    ; -1
  1974 0000109C EBFA                <1>     jmp  map_pmem_exit
  1975                              <1> 
  1976                                  
  1977 0000109E 00<rept>                align 16, db 0
  1978                                  kernel_text_size equ ($-textstart)
  1979                                  
  1980                                  ; ---------------------------------------------------------------------------
  1981                                  section .data
  1982                                  datastart :
  1983                                  
  1984                                  ; -------- descriptors --------------
  1985                                  ; Intel SW dev manual 3a, 3.4.5, pg 103
  1986                                  ;
  1987                                  ; In my opinion, macros for descriptor entries
  1988                                  ; don't make the code that much more readable.
  1989                                  
  1990                                  descriptor_size equ 8
  1991                                  
  1992                                  gdt :
  1993                                  nullsel equ $-gdt           ; nullsel = 0h
  1994 00000000 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
  1995                                  
  1996                                  codesel equ $-gdt           ; codesel = 8h  4Gb flat over all logical mem
  1997 00000008 FFFF                        dw 0xffff               ; limit 0-15
  1998 0000000A 0000                        dw 0x0000               ; base  0-15
  1999 0000000C 00                          db 0x00                 ; base 16-23
  2000 0000000D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  2001 0000000E CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  2002 0000000F 00                          db 0x00                 ; base 24-31
  2003                                  
  2004                                  datasel equ $-gdt           ; datasel = 10h  4Gb flat over all logical mem
  2005 00000010 FFFF                        dw 0xffff               ; limit 0-15
  2006 00000012 0000                        dw 0x0000               ; base  0-15
  2007 00000014 00                          db 0x00                 ; base 16-23
  2008 00000015 92                          db 0x92                 ; present, dpl=0, data r/w
  2009 00000016 CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  2010 00000017 00                          db 0x00                 ; base 24-31
  2011                                  
  2012                                  stacksel equ $-gdt          ; stacksel = 18h  small limited stack
  2013 00000018 FF1F                        dw kstack_size-1        ; limit
  2014 0000001A 0010                        dw kstack_loc           ; base
  2015 0000001C 00                          db 0
  2016 0000001D 92                          db 0x92                 ; present, dpl=0, data, r/w
  2017 0000001E 40                          db 0x40                 ; byte granular, 32bit/8bit
  2018 0000001F 00                          db 0
  2019                                  
  2020                                  videosel equ $-gdt          ; videosel = 20h
  2021 00000020 9F0F                        dw 3999                 ; limit 80*25*2-1
  2022 00000022 0080                        dw 0x8000               ; base 0xb8000
  2023 00000024 0B                          db 0x0b
  2024 00000025 92                          db 0x92                 ; present, dpl=0, data, r/w
  2025 00000026 40                          db 0x40                 ; byte granular, 32bit/8bit
  2026 00000027 00                          db 0
  2027                                  
  2028                                  rmcssel equ $-gdt           ; real mode CS selector = 28h
  2029 00000028 FFFF                        dw 0xffff               ; limit 0-15
  2030 0000002A 0000                        dw 0x0000               ; base  0-15
  2031 0000002C 00                          db 0x00                 ; base 16-23
  2032 0000002D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  2033 0000002E 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  2034 0000002F 00                          db 0x00                 ; base 24-31
  2035                                  
  2036                                  rmdssel equ $-gdt           ; real mode DS selector = 30h
  2037 00000030 FFFF                        dw 0xffff               ; limit 0-15
  2038 00000032 0000                        dw 0x0000               ; base  0-15
  2039 00000034 00                          db 0x00                 ; base 16-23
  2040 00000035 92                          db 0x92                 ; present, dpl=0, data r/w
  2041 00000036 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  2042 00000037 00                          db 0x00                 ; base 24-31
  2043                                  
  2044                                  ldtsel1 equ $-gdt
  2045 00000038 1800                        dw ldt1_len             ; length of the ldt
  2046 0000003A [5001]                      dw ldt1                 ; address of the ldt
  2047 0000003C 00                          db 0
  2048 0000003D 82                          db 0x82                 ; present, dpl=0, ldt
  2049 0000003E 40                          db 0x40                 ; byte granular, 32bit/8bit
  2050 0000003F 00                          db 0
  2051                                  
  2052                                  tasksel_f08 equ $-gdt       ; the double fault task selector
  2053 00000040 6800                        dw tss_len              ; tss length
  2054 00000042 [6801]                      dw tss_f08              ; tss physical address
  2055 00000044 00                          db 0
  2056 00000045 89                          db 0x89                 ; present, dpl=0, tss32
  2057 00000046 40                          db 0x40                 ; byte granular, 32bit/8bit
  2058 00000047 00                          db 0
  2059                                  
  2060                                  tasksel_f10 equ $-gdt       ; the invalid tss task selector
  2061 00000048 6800                        dw tss_len              ; tss length
  2062 0000004A [D001]                      dw tss_f10              ; tss physical address
  2063 0000004C 00                          db 0
  2064 0000004D 89                          db 0x89                 ; present, dpl=0, tss32
  2065 0000004E 40                          db 0x40                 ; byte granular, 32bit/8bit
  2066 0000004F 00                          db 0
  2067                                  
  2068                                  ; there is one kernel thread tss (ring 0) and one user thread tss (ring 1)
  2069                                  ; per cpu.  memory for tss structs for the non-boot cpus are allocated as
  2070                                  ; each non-boot cpu comes online (see create_tss_pair).  tasksel_uXX tss
  2071                                  ; gates are installed in the idt (starting at first_thread_tss_gate),
  2072                                  ; they also map 1-to-1 with cpus.  (the thread is launched via an lapic
  2073                                  ; vectored interrupt that jumps immediately into user space - and to call a
  2074                                  ; task gate from an interrupt requires an existing ring 0 tss to be active)
  2075                                  ; tasksel_uXX tsses are initialized in new_thread.
  2076                                  
  2077                                  tasksel_k00 equ $-gdt
  2078 00000050 6800[3802]00894000                              dw tss_len, tss0, 0x8900, 0x40
  2079                                  tasksel_u00 equ $-gdt
  2080 00000058 6800[A002]00894000                              dw tss_len, tss1, 0x8900, 0x40
  2081                                  tasksel_k01 equ $-gdt
  2082 00000060 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2083                                  tasksel_u01 equ $-gdt
  2084 00000068 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2085                                  tasksel_k02 equ $-gdt
  2086 00000070 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2087                                  tasksel_u02 equ $-gdt
  2088 00000078 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2089                                  tasksel_k03 equ $-gdt
  2090 00000080 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2091                                  tasksel_u03 equ $-gdt
  2092 00000088 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2093                                  tasksel_k04 equ $-gdt
  2094 00000090 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2095                                  tasksel_u04 equ $-gdt
  2096 00000098 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2097                                  tasksel_k05 equ $-gdt
  2098 000000A0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2099                                  tasksel_u05 equ $-gdt
  2100 000000A8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2101                                  tasksel_k06 equ $-gdt
  2102 000000B0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2103                                  tasksel_u06 equ $-gdt
  2104 000000B8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2105                                  tasksel_k07 equ $-gdt
  2106 000000C0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2107                                  tasksel_u07 equ $-gdt
  2108 000000C8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2109                                  tasksel_k08 equ $-gdt
  2110 000000D0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2111                                  tasksel_u08 equ $-gdt
  2112 000000D8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2113                                  tasksel_k09 equ $-gdt
  2114 000000E0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2115                                  tasksel_u09 equ $-gdt
  2116 000000E8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2117                                  tasksel_k10 equ $-gdt
  2118 000000F0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2119                                  tasksel_u10 equ $-gdt
  2120 000000F8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2121                                  tasksel_k11 equ $-gdt
  2122 00000100 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2123                                  tasksel_u11 equ $-gdt
  2124 00000108 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2125                                  tasksel_k12 equ $-gdt
  2126 00000110 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2127                                  tasksel_u12 equ $-gdt
  2128 00000118 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2129                                  tasksel_k13 equ $-gdt
  2130 00000120 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2131                                  tasksel_u13 equ $-gdt
  2132 00000128 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2133                                  tasksel_k14 equ $-gdt
  2134 00000130 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2135                                  tasksel_u14 equ $-gdt
  2136 00000138 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2137                                  tasksel_k15 equ $-gdt
  2138 00000140 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2139                                  tasksel_u15 equ $-gdt
  2140 00000148 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2141                                  
  2142                                  max_threads equ ($-gdt-tasksel_k00)/descriptor_size/2
  2143                                  
  2144                                  gdt_end :
  2145                                  
  2146                                  ; ---------------------
  2147                                  
  2148                                  ldt1 :
  2149                                  nullsel1 equ $-ldt1         ; nullsel1 = 07h
  2150 00000150 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
  2151                                  
  2152                                  codesel1 equ $-ldt1         ; codesel1 = 0fh  4Gb flat over all logical mem
  2153 00000158 FFFF                        dw 0xffff               ; limit 0-15
  2154 0000015A 0000                        dw 0x0000               ; base  0-15
  2155 0000015C 00                          db 0x00                 ; base 16-23
  2156 0000015D FA                          db 0xfa                 ; present, dpl=3, code e/r
  2157 0000015E CF                          db 0xcf                 ; 4k granular, 32bit, limit 16-19
  2158 0000015F 00                          db 0x00                 ; base 24-31
  2159                                  
  2160                                  datasel1 equ $-ldt1         ; datasel1 = 17h  4Gb flat over all logical mem
  2161 00000160 FFFF                        dw 0xffff               ; limit 0-15
  2162 00000162 0000                        dw 0x0000               ; base  0-15
  2163 00000164 00                          db 0x00                 ; base 16-23
  2164 00000165 F2                          db 0xf2                 ; present, dpl=3, data r/w
  2165 00000166 CF                          db 0xcf                 ; 4k granular, 32bit, limit 16-19
  2166 00000167 00                          db 0x00                 ; base 24-31
  2167                                  
  2168                                  ; gcc wants the ds, es, and ss segment registers to match
  2169                                  ;stacksel1 equ $-ldt1        ; stacksel = 1ch  small limited stack
  2170                                  ;    dw 0xffff               ; limit
  2171                                  ;    dw 0x0000               ; base  0-15
  2172                                  ;    db 0x00
  2173                                  ;    db 0xf2                 ; present, dpl=3, data, r/w
  2174                                  ;    db 0                    ; byte granular, 16 bit
  2175                                  ;    db 0
  2176                                  
  2177                                  ldt1_end :
  2178                                  
  2179                                  ldt1_len equ ldt1_end-ldt1
  2180                                  
  2181                                  ; ---------------------
  2182                                  ; the tss that handles double fault exceptions
  2183                                  
  2184                                  tss_f08 :                   ; intel sw 3a 7.6  pg 287 of 756
  2185 00000168 00000000                    dw 0,0                  ; previous task link
  2186 0000016C 005F0000                    dd tss_f08_stk-0x100    ; esp0
  2187 00000170 10000000                    dw datasel,0            ; ss0
  2188 00000174 00000000                    dd 0                    ; esp1
  2189 00000178 00000000                    dw 0,0                  ; ss1
  2190 0000017C 00000000                    dd 0                    ; esp2
  2191 00000180 00000000                    dw 0,0                  ; ss2
  2192                                  tss_f08_cr3 :
  2193 00000184 00000000                    dd 0                    ; cr3
  2194 00000188 [580C0000]                  dd int_handler_tg_dblflt ; eip
  2195 0000018C 00000000                    dd 0                    ; eflags
  2196 00000190 00000000                    dd 0                    ; eax
  2197 00000194 00000000                    dd 0                    ; ecx
  2198 00000198 00000000                    dd 0                    ; edx
  2199 0000019C 00000000                    dd 0                    ; ebx
  2200 000001A0 00600000                    dd tss_f08_stk          ; esp
  2201 000001A4 00000000                    dd 0                    ; ebp
  2202 000001A8 00000000                    dd 0                    ; esi
  2203 000001AC 00000000                    dd 0                    ; edi
  2204 000001B0 10000000                    dw datasel,0            ; es
  2205 000001B4 08000000                    dw codesel,0            ; cs
  2206 000001B8 10000000                    dw datasel,0            ; ss
  2207 000001BC 10000000                    dw datasel,0            ; ds
  2208 000001C0 00000000                    dw 0,0                  ; fs
  2209 000001C4 20000000                    dw videosel,0           ; gs
  2210 000001C8 00000000                    dw 0,0                  ; ldt
  2211 000001CC 0000                        dw 0                    ; trap
  2212 000001CE 0000                        dw 0                    ; iomap
  2213                                  
  2214                                  ; ---------------------
  2215                                  ; the tss that handles invalid tss exceptions
  2216                                  
  2217                                  tss_f10 :                   ; intel sw 3a 7.6  pg 287 of 756
  2218 000001D0 00000000                    dw 0,0                  ; previous task link
  2219 000001D4 006F0000                    dd tss_f10_stk-0x100    ; esp0
  2220 000001D8 10000000                    dw datasel,0            ; ss0
  2221 000001DC 00000000                    dd 0                    ; esp1
  2222 000001E0 00000000                    dw 0,0                  ; ss1
  2223 000001E4 00000000                    dd 0                    ; esp2
  2224 000001E8 00000000                    dw 0,0                  ; ss2
  2225                                  tss_f10_cr3 :
  2226 000001EC 00000000                    dd 0                    ; cr3
  2227 000001F0 [6C0C0000]                  dd int_handler_tg_invtss ; eip
  2228 000001F4 00000000                    dd 0                    ; eflags
  2229 000001F8 00000000                    dd 0                    ; eax
  2230 000001FC 00000000                    dd 0                    ; ecx
  2231 00000200 00000000                    dd 0                    ; edx
  2232 00000204 00000000                    dd 0                    ; ebx
  2233 00000208 00700000                    dd tss_f10_stk          ; esp
  2234 0000020C 00000000                    dd 0                    ; ebp
  2235 00000210 00000000                    dd 0                    ; esi
  2236 00000214 00000000                    dd 0                    ; edi
  2237 00000218 10000000                    dw datasel,0            ; es
  2238 0000021C 08000000                    dw codesel,0            ; cs
  2239 00000220 10000000                    dw datasel,0            ; ss
  2240 00000224 10000000                    dw datasel,0            ; ds
  2241 00000228 00000000                    dw 0,0                  ; fs
  2242 0000022C 20000000                    dw videosel,0           ; gs
  2243 00000230 00000000                    dw 0,0                  ; ldt
  2244 00000234 0000                        dw 0                    ; trap
  2245 00000236 0000                        dw 0                    ; iomap
  2246                                  
  2247                                  ; ---------------------
  2248                                  ; tss0 and tss1 are cpu0's pair
  2249                                  
  2250                                  tss0 :                      ; intel swdev3a 7.6  pg 287 of 756
  2251 00000238 00000000                    dw 0,0                  ; previous task link
  2252                                  tss0_esp0 :
  2253 0000023C 00000000                    dd 0                    ; esp0
  2254                                  tss0_ss0 :
  2255 00000240 00000000                    dw 0,0                  ; ss0
  2256 00000244 00000000                    dd 0                    ; esp1
  2257 00000248 00000000                    dw 0,0                  ; ss1
  2258 0000024C 00000000                    dd 0                    ; esp2
  2259 00000250 00000000                    dw 0,0                  ; ss2
  2260                                  tss0_cr3 :
  2261 00000254 00000000                    dd 0                    ; cr3
  2262                                  tss0_eip :
  2263 00000258 00000000                    dd 0                    ; eip
  2264 0000025C 00000000                    dd 0                    ; eflags
  2265                                  tss0_eax :
  2266 00000260 00000000                    dd 0                    ; eax
  2267 00000264 00000000                    dd 0                    ; ecx
  2268 00000268 00000000                    dd 0                    ; edx
  2269 0000026C 00000000                    dd 0                    ; ebx
  2270                                  tss0_esp :
  2271 00000270 00000000                    dd 0                    ; esp
  2272 00000274 00000000                    dd 0                    ; ebp
  2273 00000278 00000000                    dd 0                    ; esi
  2274 0000027C 00000000                    dd 0                    ; edi
  2275                                  tss0_es :
  2276 00000280 00000000                    dw 0,0                  ; es
  2277                                  tss0_cs :
  2278 00000284 00000000                    dw 0,0                  ; cs
  2279                                  tss0_ss :
  2280 00000288 00000000                    dw 0,0                  ; ss
  2281                                  tss0_ds :
  2282 0000028C 00000000                    dw 0,0                  ; ds
  2283 00000290 00000000                    dw 0,0                  ; fs
  2284 00000294 20000000                    dw videosel,0           ; gs
  2285                                  tss0_ldt :
  2286 00000298 00000000                    dw 0,0                  ; ldt
  2287 0000029C 0000                        dw 0                    ; trap
  2288 0000029E 0000                        dw 0                    ; iomap
  2289                                  tss0_end :
  2290                                  
  2291                                  tss_len equ tss0_end-tss0
  2292                                  
  2293                                  ; user tss
  2294                                  
  2295                                  tss1 :                      ; intel sw 3a 7.6  pg 287 of 756
  2296 000002A0 00000000                    dw 0,0                  ; previous task link
  2297                                  tss1_esp0 :
  2298 000002A4 00000000                    dd 0                    ; esp0  (int and irq support)
  2299 000002A8 18000000                    dw stacksel,0           ; ss0   (filled in when running init apps)
  2300 000002AC 00000000                    dd 0                    ; esp1
  2301 000002B0 00000000                    dw 0,0                  ; ss1
  2302 000002B4 00000000                    dd 0                    ; esp2
  2303 000002B8 00000000                    dw 0,0                  ; ss2
  2304                                  tss1_cr3 :
  2305 000002BC 00000000                    dd 0                    ; cr3
  2306                                  tss1_eip :
  2307 000002C0 00000000                    dd 0                    ; eip
  2308 000002C4 00000000                    dd 0                    ; eflags
  2309 000002C8 00000000                    dd 0                    ; eax
  2310 000002CC 00000000                    dd 0                    ; ecx
  2311 000002D0 00000000                    dd 0                    ; edx
  2312 000002D4 00000000                    dd 0                    ; ebx
  2313 000002D8 00000000                    dd 0                    ; esp
  2314 000002DC 00000000                    dd 0                    ; ebp
  2315 000002E0 00000000                    dd 0                    ; esi
  2316 000002E4 00000000                    dd 0                    ; edi
  2317 000002E8 17000000                    dw datasel1+7,0         ; es
  2318 000002EC 0F000000                    dw codesel1+7,0         ; cs
  2319 000002F0 17000000                    dw datasel1+7,0         ; ss
  2320 000002F4 17000000                    dw datasel1+7,0         ; ds
  2321 000002F8 00000000                    dw 0,0                  ; fs
  2322 000002FC 00000000                    dw 0,0                  ; gs
  2323 00000300 3B000000                    dw ldtsel1+3,0          ; ldt
  2324 00000304 0000                        dw 0                    ; trap
  2325 00000306 0000                        dw 0                    ; iomap
  2326                                  
  2327                                  ; ---------------------
  2328                                  
  2329                                  gdtr :
  2330 00000308 4F01                        dw gdt_end - gdt - 1    ; gdt length
  2331 0000030A [00000000]                  dd gdt                  ; gdt physical address
  2332                                  
  2333                                  idtr :
  2334                                      ; irq_setup_table_size == the number of gates in the idt
  2335 0000030E FF07                        dw irq_setup_table_size * 8 - 1     ; idt limit (should be 2k)
  2336                                  idtr_addr :
  2337 00000310 00000000                    dd 0                                ; address of the idt
  2338                                  
  2339 00000314 00000000                ncpus           dd 0        ; number of running cpus
  2340                                  
  2341 00000318 00000000                next_free_page  dd 0        ; initialized after page tables are setup
  2342                                  
  2343 0000031C 0000000000000000        sleepers        dq 0        ; one bit per cpu
  2344                                  
  2345 00000324 00000000                pgdirp          dd 0
  2346 00000328 00000000                pgtb0p          dd 0
  2347 0000032C 00000000                pgtb1p          dd 0
  2348                                  
  2349 00000330 00                      enabled_lapic   db 0        ; set to 1 if an lapic is present and in use
  2350                                  
  2351 00000331 AA55                    dbgwall         db 0xaa,0x55
  2352                                  
  2353 00000333 00<rept>                align 16, db 0
  2354                                  kernel_data_size equ ($-datastart)
  2355                                  
  2356                                  
  2357                                  ; ---------------------
  2358                                  ; Need to align to a physical page boundary here so that appended init apps
  2359                                  ; are always page aligned.  The problem is our text section starts 1k below
  2360                                  ; a page boundary, and so an 'align 4096' doesn't match up with physical
  2361                                  ; memory.
  2362                                  
  2363                                  ; Add larger tests here if the times expression turns up negative, to make
  2364                                  ; the kernel image size right, but your next problem will be that the boot
  2365                                  ; loader will likely refuse to load all these sectors in one pass.
  2366                                  
  2367                                  section .fill
  2368                                  
  2369                                  fill :
  2370                                  
  2371                                  %if total_size > 4096+1024
  2372                                      times (4096+4096+1024-total_size) db 0
  2373                                  %elif total_size > 1024
  2374 00000000 00<rept>                    times (4096+1024-total_size) db 0
  2375                                  %endif
  2376                                  
  2377                                  kend :
  2378                                  
