     1                                  ; OZ - A more utopian OS   x86-32 startup 
     2                                  ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
     3                                  ;
     4                                  ; Copyright (C) 2015  Duane Voth
     5                                  ;
     6                                  ;   This program is free software: you can redistribute it and/or modify
     7                                  ;   it under the terms of the GNU Affero General Public License as
     8                                  ;   published by the Free Software Foundation, either version 3 of the
     9                                  ;   License, or (at your option) any later version.
    10                                  ;
    11                                  ;   This program is distributed in the hope that it will be useful,
    12                                  ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
    13                                  ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    14                                  ;   GNU Affero General Public License for more details.
    15                                  ;
    16                                  ;   You should have received a copy of the GNU Affero General Public License
    17                                  ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
    18                                  ;
    19                                  ;
    20                                  ;
    21                                  ; usage:
    22                                  ;	$ qemu-system-i386 -boot a -fda oz_fd -monitor stdio
    23                                  ;
    24                                  ; requires: nasm-2.07  or later from: http://www.nasm.us
    25                                  ;
    26                                  ; contributors:
    27                                  ;        djv - Duane Voth
    28                                  ;
    29                                  ; history:
    30                                  ; 2007/03/03 - 0.00.01 - djv - begin with various web examples
    31                                  ;                      http://linuxgazette.net/issue82/misc/raghu/code.asm.txt
    32                                  ;                      http://www.osdever.net/tutorials/brunmar/simple_asm.txt
    33                                  ; 2007/03/04 - 0.00.02 - djv - add timer interrupt support with stray int dbg
    34                                  ; 2007/03/05 - 0.00.03 - djv - remove stray int dbg, add mbr data struc back
    35                                  ; 2007/03/11 - 0.00.04 - djv - debug USB boot problem
    36                                  ; 2007/03/28 - 0.01.00 - djv - add a real-mode stage2 loader in the mbr to
    37                                  ;                              load the sectors past the mbr on the boot
    38                                  ;                              device into the memory behind the mbr.  so even
    39                                  ;                              tho the read from the device happens in two
    40                                  ;                              parts, memory contains a linear image of the
    41                                  ;                              first few sectors of the boot device.
    42                                  ; 2009/02/01 - 0.02.00 - djv - begin to define application and dynamic library
    43                                  ;                              binary formats with headers detailing size and
    44                                  ;                              entry points.
    45                                  ; 2009/08/01 - 0.03.00 - djv - create the OZ app execution container using
    46                                  ;                              TSSes, paging, and rings 0 and 3.  begin to
    47                                  ;                              play with system calls.
    48                                  ; 2015/10/12 - 0.03.01 - djv - cleanup, add smp usermode tss structs, sleep,
    49                                  ;                              wakeup, and ipi for user thread creation.
    50                                  
    51                                  %ifdef USB
    52                                  [map symbols oz_usb.map]
    53                                  %else
    54                                  [map symbols oz_fd.map]
    55                                  %endif
    56                                  
    57                                  ; -------- stage 1 ---------------------------------------------------------
    58                                  ; A classic x86 Master Boot Record
    59                                  
    60                                  section .text start=0x7c00  ; PC BIOS boot loader entry point
    61                                  textstart :
    62                                  
    63                                  bios_entry :
    64 00000000 FA                          cli
    65 00000001 EA[2400]0000                jmp 0:load_stage2       ; load cs, skip over mbr data struct
    66                                  
    67                                  times 6-($-$$)  db 0
    68 00000006 6F7A                    oemid db "oz"
    69                                  
    70 00000008 00<rept>                times 11-($-$$)  db 0
    71                                  
    72                                  ; compute the size of the kernel image in 512 byte sectors
    73                                  total_size equ (kernel_text_size + kernel_data_size)
    74                                  kisectors  equ (total_size)/512 + (APP_SIZE + 512)/512
    75                                  ; compute the end of the kernel image (with apps attached)
    76                                  kilast equ 0x7c00 + kisectors * 512
    77                                  
    78                                  ; MS MBR  (http://support.microsoft.com/kb/140418)
    79                                  %ifdef FLOPPY
    80 0000000B 0002                        dw 512                  ; Bytes per sector
    81 0000000D 01                          db 1                    ; Sectors per cluster
    82 0000000E 3A00                        dw kisectors            ; Number of reserved sectors
    83 00000010 02                          db 2                    ; Number of FATs
    84 00000011 E000                        dw 0x00e0               ; Number of dirs in root
    85 00000013 400B                        dw 0x0b40               ; Number of sectors in volume
    86 00000015 F0                          db 0xf0                 ; Media descriptor
    87 00000016 0900                        dw 9                    ; Number of sectors per FAT
    88 00000018 1200                        dw 18                   ; Number of sectors per track
    89 0000001A 0200                        dw 2                    ; Number of heads
    90 0000001C 00000000                    dd 0                    ; Number of hidden sectors
    91 00000020 00000000                    dd 0                    ; Large Sectors
    92                                  %endif
    93                                  
    94                                  %ifdef USB
    95                                      dw 0                    ; Bytes per sector
    96                                      db 0                    ; Sectors per cluster
    97                                      dw kisectors            ; Number of reserved sectors
    98                                      db 0                    ; Number of FATs
    99                                      dw 0                    ; Number of dirs in root
   100                                      dw 0                    ; Number of sectors in volume
   101                                      db 0                    ; Media descriptor
   102                                      dw 0                    ; Number of sectors per FAT
   103                                      dw 0                    ; Number of sectors per track
   104                                      dw 0                    ; Number of heads
   105                                      dd 0                    ; Number of hidden sectors
   106                                      dd 0                    ; Large Sectors
   107                                  %endif
   108                                  
   109                                  ; -------- stage 2 loader ------------
   110                                  bits 16
   111                                  alignb 2
   112                                  
   113                                  load_stage2 :
   114 00000024 B80010                      mov  ax,kstack_loc
   115 00000027 89C4                        mov  sp,ax
   116 00000029 31C0                        xor  ax,ax
   117 0000002B 8ED0                        mov  ss,ax
   118 0000002D 8EC0                        mov  es,ax
   119 0000002F 8ED8                        mov  ds,ax
   120 00000031 8EE0                        mov  fs,ax
   121 00000033 8EE8                        mov  gs,ax
   122 00000035 FC                          cld
   123                                  
   124 00000036 52                          push dx                 ; save BIOS drive number
   125                                  
   126 00000037 B80006                      mov  ax,0x0600          ; ah=6 scroll window up, if al = 0 clrscr
   127 0000003A B90000                      mov  cx,0x0000          ; clear window from 0,0 
   128 0000003D BA4F17                      mov  dx,0x174f          ; to 23,79
   129 00000040 B70F                        mov  bh,0xf             ; fill with hi white
   130 00000042 CD10                        int  0x10               ; clear screen for direct writes to video memory
   131                                  
   132 00000044 BE[B700]                    mov  si,bootmsg
   133 00000047 31DB                        xor  bx,bx
   134 00000049 E85700                      call puts_vga_rm
   135                                                              ; puts_vga_rm leaves gs pointing at video mem
   136 0000004C 65C60601000E                mov  byte [gs:1],0xE    ; turn the first two chars yellow
   137 00000052 65C60603000E                mov  byte [gs:3],0xE
   138                                  
   139                                      ;F - white              
   140                                      ;E - yellow             
   141                                      ;D - magenta            
   142                                      ;C - red                
   143                                      ;B - cyan               
   144                                      ;A - green              
   145                                      ;9 - blue               
   146                                      ;8 - dark grey          
   147                                  
   148 00000058 A1[0002]                    mov  ax,[stage2]         ; check the signature byte
   149 0000005B 0306[0202]                  add  ax,[stage2+2]
   150 0000005F 3DA17A                      cmp  ax,0x7a6f+0x32
   151 00000062 741D                        jz   stage2_present
   152                                  
   153                                      ; -------- stage2 boot loader --------
   154                                  
   155                                      ; Assume that the kernel is smaller than whatever space
   156                                      ; is provided prior to file system data structures on the
   157                                      ; boot device, and that it can immediately follow the MBR.
   158                                  
   159 00000064 B402                        mov  ah,02h
   160 00000066 B039                        mov  al,kisectors-1     ; number of sectors to load
   161 00000068 BB[0002]                    mov  bx,stage2
   162 0000006B B90200                      mov  cx,2
   163 0000006E 5A                          pop  dx                 ; recover BIOS drive number
   164 0000006F 0E                          push cs
   165 00000070 07                          pop  es
   166 00000071 CD13                        int  13h
   167 00000073 7211                        jc   ioerr
   168                                  
   169                                      ; ---- make sure second stage actually got loaded
   170                                  
   171 00000075 A1[0002]                    mov  ax,[stage2]        ; check the signature byte
   172 00000078 0306[0202]                  add  ax,[stage2+2]
   173 0000007C 3DA17A                      cmp  ax,0x7a6f+0x32
   174 0000007F 750A                        jnz  s2err
   175                                  stage2_present :
   176 00000081 EA[0902]0000                jmp  0:start_stage2     ; use an absolute jump so stage 1
   177                                                              ; can be position independent
   178                                  
   179                                  ioerr :                     ; ah has status...
   180 00000086 BE[E700]                    mov  si,ioerrmsg
   181 00000089 EB03                        jmp  print_err
   182                                  
   183                                  s2err :
   184 0000008B BE[D100]                    mov  si,s2errmsg
   185                                  print_err :
   186 0000008E BBA000                      mov  bx,160
   187 00000091 E80F00                      call puts_vga_rm
   188 00000094 65C60601000C                mov  byte [gs:1],0xC    ; turn the first two vga chars red
   189 0000009A 65C60603000C                mov  byte [gs:3],0xC
   190                                  
   191                                  hang :
   192 000000A0 F4                          hlt
   193 000000A1 EBFD                        jmp  hang
   194                                  
   195                                  ; ----------------------------
   196                                  ;   puts_vga_rm - write a null delimited string to the VGA controller
   197                                  ;                 in real mode
   198                                  ;
   199                                  ;    enter:
   200                                  ;            esi - address of string
   201                                  ;            ebx - screen location (2 bytes per char, 160 bytes per line)
   202                                  ;    exit:
   203                                  ;            eax - destroyed
   204                                  ;             gs - set to video memory selector
   205                                  
   206                                  puts_vga_rm :
   207 000000A3 B800B8                      mov  ax,0xb800      ; point gs at video memory
   208 000000A6 8EE8                        mov  gs,ax          
   209                                  puts_vga_rm_loop :
   210 000000A8 AC                          lodsb
   211 000000A9 3C00                        cmp  al,0
   212 000000AB 7409                        jz   puts_vga_rm_done
   213 000000AD 658807                      mov  [gs:bx],al
   214 000000B0 6683C302                    add  ebx,2
   215 000000B4 EBF2                        jmp  puts_vga_rm_loop
   216                                  puts_vga_rm_done :
   217 000000B6 C3                          ret
   218                                  
   219 000000B7 4F5A2076302E30332E-     bootmsg     db      "OZ v0.03.01 - 2015/10/12 ",0
   220 000000C0 3031202D2032303135-
   221 000000C9 2F31302F31322000   
   222 000000D1 73746167652032206C-     s2errmsg    db      "stage 2 load failure ",0
   223 000000DA 6F6164206661696C75-
   224 000000E3 72652000           
   225 000000E7 692F6F206572726F72-     ioerrmsg    db      "i/o error loading stage 2 ",0
   226 000000F0 206C6F6164696E6720-
   227 000000F9 737461676520322000 
   228                                  
   229 00000102 00<rept>                times 446-($-$$) db 0       ; fill with zeros up to partition table
   230                                  
   231                                  tmpstk      equ     $
   232                                  
   233                                  ; If the kernel is loaded from a disk (including usb) the MBR
   234                                  ; must include a partition table based on the device geometry.
   235                                  ; This gets fed into oz.asm here via usbptbl.inc
   236                                  %ifdef USB
   237                                  %include "usbptbl.inc"
   238                                  %else
   239                                      ; If the kernel is placed in memory by some other means
   240                                      ; (PXE, pxelinux, etc.) the partition table is irrelevant
   241                                      ; but the space is still required.  Make the default ptbl
   242                                      ; match a 1.44MB floppy.
   243 000001BE 800101000601124F            db 0x80,0x01,0x01,0x00,0x06,0x01,0x12,0x4f
   244 000001C6 120000002E0B0000            db 0x12,0x00,0x00,0x00,0x2e,0x0b,0x00,0x00
   245 000001CE 000000000000000000-         db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   246 000001D7 00000000000000     
   247 000001DE 000000000000000000-         db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   248 000001E7 00000000000000     
   249 000001EE 000000000000000000-         db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   250 000001F7 00000000000000     
   251                                  %endif
   252                                  
   253                                  %ifdef NEWUSB
   254                                  new usb?  gpt correct?
   255                                  0000 01B0: 00 00 00 00 00 2C 44 63  E0 36 03 00 00 00 80 20  .....,Dc .6.....
   256                                  0000 01C0: 21 00 83 9D 11 4C 00 08  00 00 00 C0 12 00 00 9D  !....L.. ........
   257                                  0000 01D0: 12 4C 83 57 25 F2 00 C8  12 00 00 A0 28 00 00 00  .L.W%... ....(...
   258                                  0000 01E0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ........ ........
   259                                  0000 01F0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 AA  ........ ......U.
   260                                  %endif
   261                                  
   262                                  
   263                                  times 510-($-$$) db 0       ; fill with zeros up to MBR signature
   264                                  
   265 000001FE 55AA                                dw 0x0aa55      ; write aa55 in bytes 511,512 to indicate
   266                                                              ; that it is a boot sector. 
   267                                  
   268                                  ; end of MBR
   269                                  ;
   270                                  ; -------- stage 2 ---------------------------------------------------------
   271                                  ;
   272                                  ; If a boot loader only loads 512 bytes in the first pass, the following
   273                                  ; code won't appear in memory until the code above has completed.  Other
   274                                  ; loaders however can load the entire OZ kernel image into memory in one
   275                                  ; shot.
   276                                  
   277                                  bits 16
   278                                  
   279                                  stage2 :
   280 00000200 6F7A3200                    db "oz2",0                      ; stage2 signature
   281                                  
   282                                  non_boot_cpu_ljmp_instruction :     ; place this in 16 bit code land
   283 00000204 EA00000000                  jmp word 0:0                    ; so we get the right opcode
   284                                  
   285                                  kstack_loc  equ 0x1000      ; must be on a 4k pysical page boundary
   286                                  kstack_size equ 4096*2
   287                                  
   288                                  pgdir equ 0x3000            ; use some of the free memory below us
   289                                  pgtb0 equ 0x4000            ; code below assumes this follows pgdir
   290                                  pgtb1 equ 0x5000            ; code below assumes this follows pgtb0
   291                                  
   292                                  idt   equ 0x7000            ; use some of the free memory below us
   293                                  
   294                                  ; ---------------------
   295                                  
   296                                  start_stage2 :
   297                                  
   298 00000209 B80030                      mov  ax,kstack_loc+kstack_size  ; setup the kernel stack
   299 0000020C 89C4                        mov  sp,ax
   300                                  
   301                                      ; ---- initialize the 8259's while in real mode
   302                                  
   303 0000020E E84305                      call irq_init_hardware
   304                                  
   305                                  ; ------------ main kernel entry point ------------
   306                                  ; all cpus enter here
   307                                  main :
   308                                  
   309                                      ; -------- enter protected mode --------
   310                                  
   311 00000211 0F0116[0803]                lgdt [gdtr]             ; initialize the gdt
   312 00000216 0F20C0                      mov  eax,cr0
   313 00000219 0C01                        or   al,0x01            ; set the protected mode bit (lsb of cr0)
   314 0000021B 0F22C0                      mov  cr0,eax
   315 0000021E EA[2302]0800                jmp  codesel:flush_ip1  ; flush the cpu instruction pipeline
   316                                  flush_ip1: 
   317                                  bits 32                     ; instructions after this point are 32bit
   318                                  
   319 00000223 B801000000                  mov  eax,1
   320 00000228 0FC105[14030000]            xadd [ncpus],eax        ; get our unique cpu number
   321                                                              ; could use the lapic id if available
   322 0000022F 89C6                        mov  esi,eax
   323 00000231 66B81000                    mov  ax,datasel   
   324 00000235 8ED8                        mov  ds,ax              ; initialize the data segments
   325 00000237 8EC0                        mov  es,ax
   326 00000239 66B81800                    mov  ax,stacksel        ; setup a restricted stack segment
   327 0000023D 8ED0                        mov  ss,ax
   328 0000023F BC00200000                  mov  esp,kstack_size
   329 00000244 89F0                        mov  eax,esi
   330 00000246 C1E008                      shl  eax,8              ; divvy up the stack, 256 bytes per cpu
   331 00000249 29C4                        sub  esp,eax
   332                                  
   333 0000024B 89F0                        mov  eax,esi
   334 0000024D 50                          push eax
   335 0000024E 89C3                        mov  ebx,eax
   336 00000250 80C330                      add  bl,'0'             ; boot cpu announces via ascii 0
   337 00000253 BF9E000000                  mov  edi,160-2          ; last chracter on first line of vga
   338 00000258 D1E0                        shl  eax,1
   339 0000025A 29C7                        sub  edi,eax
   340 0000025C 66B82000                    mov  ax,videosel        ; point gs at video memory
   341 00000260 8EE8                        mov  gs,ax
   342 00000262 65881F                      mov  [gs:edi],bl        ; announce cpu presence
   343 00000265 58                          pop  eax
   344                                  
   345 00000266 09C0                        or   eax,eax            ; are we the boot cpu?
   346 00000268 0F8F4E010000                jg   non_boot_init      ; if not, do non_boot_init
   347                                  
   348 0000026E E80A050000                  call irq_init_bsp_apic_hardware
   349                                  
   350                                      ; ---- debug marker
   351 00000273 65C605010000000A            mov  byte [gs:1],0xA    ; turn the first two chars green
   352 0000027B 65C605030000000A            mov  byte [gs:3],0xA
   353                                  
   354                                      ; ---- build the interrupt descriptor table
   355                                  
   356 00000283 BE[E40C0000]                mov  esi,irq_setup_table
   357 00000288 B900010000                  mov  ecx,irq_setup_table_size
   358 0000028D BA00700000                  mov  edx,idt
   359                                  irq_init :
   360 00000292 31C0                        xor  eax,eax
   361 00000294 8902                        mov  [edx],eax                  ; clear the idt entry
   362 00000296 894202                      mov  [edx+2],eax
   363 00000299 66AD                        lodsw
   364 0000029B 6689C3                      mov  bx,ax
   365 0000029E 6625FCFF                    and  ax,strict 0xfffc           ; separate config flags
   366 000002A2 6683E303                    and  bx,3                       ; from selector/offset value
   367 000002A6 6683FB02                    cmp  bx,irqt_task               ; task gates are different
   368 000002AA 7407                        jz   irq_init_task_gate
   369 000002AC 668902                      mov  [edx],ax                   ; store the handler offset
   370 000002AF 66B80800                    mov  ax,codesel
   371                                  irq_init_task_gate :
   372 000002B3 66894202                    mov  word [edx+2],ax
   373 000002B7 678AA7[E00C]                mov  ah,byte [bx+irq_types]
   374 000002BC 30C0                        xor  al,al
   375 000002BE 66894204                    mov  word [edx+4],ax
   376 000002C2 83C208                      add  edx,8
   377 000002C5 E2CB                        loop irq_init
   378                                  
   379 000002C7 0F011D[0E030000]            lidt [idtr]                     ; install the idt
   380                                  
   381                                      ; ---- setup entry point for non_boot_cpus
   382                                  
   383 000002CE A0[04020000]                mov  al,[non_boot_cpu_ljmp_instruction]     ; get the ljmp instruction
   384 000002D3 A200100000                  mov  [kstack_loc],al                        ; place it at a 4k phys mem boundary
   385 000002D8 C70501100000-               mov  dword [kstack_loc+1],main
   386 000002DE [11020000]         
   387                                  
   388                                      ; ---- setup the paging tables
   389                                  
   390 000002E2 BF00300000                  mov  edi,pgdir          ; first the page directory
   391 000002E7 0F22DF                      mov  cr3,edi            ; install the page directory
   392 000002EA B807400000                  mov  eax,pgtb0 + 7      ; page table 0: present, pl=3, r/w
   393 000002EF AB                          stosd                   ; ... pl=3 for now (simplify vga access)
   394 000002F0 B807500000                  mov  eax,pgtb1 + 7      ; page table 1: present, pl=3, r/w
   395 000002F5 AB                          stosd                   ; ... app memory
   396 000002F6 31C0                        xor  eax,eax            ; invalidate the rest of the app laddr space
   397 000002F8 B9FE030000                  mov  ecx,0x400-2        ; (yeah, only one pgdir for kernel+apps for now)
   398 000002FD F3AB                        rep stosd
   399                                  
   400                                              ; assume pgtb0 physically follows the pg dir
   401                                              ; pgtb0 is the page table for kernel memory
   402                                  
   403 000002FF AB                          stosd                   ; access to page 0 will always cause a fault
   404 00000300 B803100000                  mov  eax,0x1000 + 3     ; rest are direct map: present, pl=0, r/w
   405 00000305 B9FF030000                  mov  ecx,0x400-1
   406                                  pgtb0_fill :
   407 0000030A AB                          stosd
   408 0000030B 0500100000                  add  eax,0x1000
   409 00000310 E2F8                        loop pgtb0_fill
   410                                  
   411                                              ; assume pgtb1 physically follows pgtb0
   412                                              ; pgtb1 is the first page table for app code/data/stack
   413                                  
   414 00000312 31C0                        xor  eax,eax            ; invalidate the app logical address space
   415 00000314 B900040000                  mov  ecx,0x400          ; (we'll fill in what we need later)
   416 00000319 F3AB                        rep stosd
   417                                  
   418                                              ; enable paging
   419                                  
   420 0000031B 0F20C0                      mov  eax,cr0
   421 0000031E 0D00000080                  or   eax,0x80000000     ; msb of cr0
   422 00000323 0F22C0                      mov  cr0,eax
   423 00000326 EB00                        jmp  flush_ip2          ; flush the cpu instruction pipeline
   424                                  flush_ip2: 
   425                                  
   426                                              ; establish a "pool" of free pyhsical memory
   427                                  
   428 00000328 B810000000                  mov  eax,((kilast+0x1000) >> 12)    ; include a buffer zone
   429 0000032D A3[19030000]                mov  [next_free_page],eax
   430                                  
   431                                              ; if enabled, create page table entry for the lapic
   432                                  
   433 00000332 A0[18030000]                mov  al,[enabled_lapic]
   434 00000337 08C0                        or   al,al
   435 00000339 740F                        jz   no_lapic_init
   436                                  
   437 0000033B BA0000E0FE                  mov  edx,0xfee00000     ; phys address
   438 00000340 B900100000                  mov  ecx,0x1000         ; length
   439 00000345 E8490C0000                  call map_pmem
   440                                  
   441                                  no_lapic_init :
   442                                  
   443                                      ; ---- establish a current task
   444                                  
   445 0000034A 31C0                        xor  eax,eax
   446 0000034C B050                        mov  al,tasksel_k00
   447 0000034E 0F00D8                      ltr  ax
   448                                  
   449                                      ; ---- check for init apps
   450                                  
   451 00000351 BB[E0000000]                mov  ebx, kend
   452                                  app_loop :
   453 00000356 8B4318                      mov  eax, [ebx+0x18]    ; load the entry address
   454 00000359 813B6F7A6170                cmp  dword [ebx], 0x70617a6f  ; check for "ozap"
   455 0000035F 7402                        jz   have_an_app
   456 00000361 31C0                        xor  eax, eax           ; no app
   457                                  have_an_app :
   458                                  
   459 00000363 83F800                      cmp  eax, 0             ; is there an app to run?
   460 00000366 0F848E000000                jz   idle               ; if not, idle right away
   461                                  
   462                                      ; ---- setup the init task entry point
   463                                  
   464 0000036C BF[C0020000]                mov  edi,tss1_eip
   465 00000371 AB                          stosd
   466                                  
   467                                      ; cheat: reuse the same tss, ldt, and page tables for all
   468                                      ; the init apps - this means they run serialy - each has
   469                                      ; to exit for the next one to run
   470                                  
   471 00000372 31C0                        xor   eax,eax
   472 00000374 A3[A0020000]                mov   [tss1],eax        ; clear out previous task link
   473 00000379 AB                          stosd                   ; and some registers (flags)
   474 0000037A AB                          stosd                   ; (eax)
   475 0000037B AB                          stosd                   ; (ecx)
   476 0000037C AB                          stosd                   ; (edx)
   477 0000037D AB                          stosd                   ; (ebx)
   478 0000037E 8B4310                      mov   eax, [ebx+0x10]   ; get the end of the app
   479                                      ;add   eax,0x8001000     ; (this tests app stack page faults)
   480 00000381 AB                          stosd                   ; (esp)
   481 00000382 31C0                        xor   eax,eax
   482 00000384 AB                          stosd                   ; (ebp)
   483 00000385 AB                          stosd                   ; (esi)
   484 00000386 AB                          stosd                   ; (edi)
   485                                  
   486 00000387 BF00500000                  mov  edi,pgtb1          ; rewrite the app's page table
   487 0000038C 89D8                        mov  eax,ebx
   488 0000038E 83C805                      or   eax,5              ; init app code at 0x400000 (4Mb) present and r/o
   489 00000391 AB                          stosd                   ; assume all the init apps are < 4k
   490 00000392 0502100000                  add  eax,0x1000 + 2     ; add one page for data/bss/stack
   491 00000397 AB                          stosd
   492                                  
   493                                      ; ---- start the app
   494                                  
   495 00000398 53                          push ebx
   496 00000399 FB                          sti
   497 0000039A 9A000000005800              call tasksel_u00:0
   498 000003A1 5B                          pop  ebx
   499                                  
   500                                      ; ---- point to the end of this init app
   501                                  
   502 000003A2 0F013D00004000              invlpg [0x400000]       ; FIXME 80386 needs to reload cr3
   503 000003A9 0F013D00104000              invlpg [0x401000]
   504                                  
   505 000003B0 8B4310                      mov  eax, [ebx+0x10]    ; load the app end address
   506 000003B3 2D00004000                  sub  eax,0x400000
   507 000003B8 01C3                        add  ebx,eax            ; point ebx to the next app
   508 000003BA EB9A                        jmp  app_loop
   509                                  
   510                                  ; -------- non-boot cpu initialization --------
   511                                  
   512                                  non_boot_init :
   513                                  
   514 000003BC 0F011D[0E030000]            lidt [idtr]             ; install the global idt
   515                                  
   516                                      ; ---- enable paging
   517                                  
   518 000003C3 BF00300000                  mov  edi,pgdir          ; load this cpu's paging register
   519 000003C8 0F22DF                      mov  cr3,edi
   520                                  
   521 000003CB 50                          push eax
   522 000003CC 0F20C0                      mov  eax,cr0            ; enable paging
   523 000003CF 0D00000080                  or   eax,0x80000000
   524 000003D4 0F22C0                      mov  cr0,eax
   525 000003D7 EB00                        jmp  flush_ip3          ; flush the cpu instruction pipeline
   526                                  flush_ip3 : 
   527 000003D9 58                          pop  eax
   528                                  
   529                                      ; ---- limit the number of cpus we support here
   530                                  
   531 000003DA 83F810                      cmp  eax,16
   532 000003DD 7317                        jae  nb_idle
   533                                  
   534                                      ; ---- init the lapic
   535                                  
   536 000003DF E8F0030000                  call irq_init_ap_apic_hardware
   537                                  
   538                                      ; setup smbase?
   539                                  
   540                                      ; ---- establish a current task
   541                                  
   542 000003E4 89C3                        mov  ebx,eax            ; move cpu number to ebx
   543 000003E6 E885000000                  call create_tss_pair
   544 000003EB 53                          push ebx
   545 000003EC C1E304                      shl  ebx,4              ; 16x (selector size x2)
   546 000003EF 83C350                      add  ebx,tasksel_k00
   547 000003F2 0F00DB                      ltr  bx                 ; establish a current task
   548 000003F5 5B                          pop  ebx
   549                                  
   550                                      ; test kernel page fault handler
   551                                      ;mov  [321],eax
   552                                  
   553                                  nb_idle :
   554 000003F6 FB                          sti
   555 000003F7 F4                          hlt                     ; wait for something to do
   556 000003F8 EBFC                        jmp  nb_idle            ; (see new_thread)
   557                                  
   558                                      ; -------- boot cpu idle task --------
   559                                      ; could be combined with nb_idle but separating
   560                                      ; these can allow for easier debug
   561                                  
   562                                  idle :
   563 000003FA FB                          sti
   564 000003FB F4                          hlt                     ; wait for interrupts
   565 000003FC EBFC                        jmp  idle
   566                                  
   567                                  
   568                                  ; ----------------------------
   569                                  ;    puts_vga - write a null delimited string to the VGA controller
   570                                  ;               in protected mode
   571                                  ;    enter:
   572                                  ;         esi - address of string
   573                                  ;         ebx - screen location (2 bytes per char, 160 bytes per line)
   574                                  ;    exit:
   575                                  ;         eax - destroyed
   576                                  ;         ebx - next screen location
   577                                  ;          gs - set to video memory selector
   578                                  bits 32
   579                                  
   580                                  puts_vga :
   581 000003FE 66B82000                    mov  ax,videosel        ; point gs at video memory
   582 00000402 8EE8                        mov  gs,ax
   583                                  puts_vga_loop :
   584 00000404 2E8A06                      mov  al,[cs:esi]        ; use cs so irq handlers don't
   585 00000407 46                          inc  esi                ; have to load kernel ds
   586 00000408 3C00                        cmp  al,0
   587 0000040A 7408                        jz   puts_vga_done
   588 0000040C 658803                      mov  [gs:ebx],al
   589 0000040F 83C302                      add  ebx,2
   590 00000412 EBF0                        jmp  puts_vga_loop
   591                                  puts_vga_done :
   592 00000414 C3                          ret
   593                                  
   594                                  ; ----------------------------
   595                                  ;   putx_vga - write the contents of eax in hex to the VGA controller
   596                                  ;              (in protected mode)
   597                                  ;   putbx_vga - write the contents of al in hex to the VGA controller
   598                                  ;
   599                                  ;   enter:
   600                                  ;       eax - value to convert to hex
   601                                  ;       ebx - screen location (2 bytes per char, 160 bytes per line)
   602                                  ;   exit:
   603                                  ;       ebx - next screen location
   604                                  ;        gs - set to video memory selector
   605                                  bits 32
   606                                  
   607                                  putbx_vga :
   608 00000415 51                          push ecx
   609 00000416 B902000000                  mov  ecx,2
   610 0000041B 25FF000000                  and  eax,0xff
   611 00000420 C1C018                      rol  eax,24
   612 00000423 EB06                        jmp putx_vga_loop
   613                                  
   614                                  putx_vga :
   615 00000425 51                          push ecx
   616 00000426 B908000000                  mov  ecx,8
   617                                  putx_vga_loop :
   618 0000042B C1C004                      rol  eax,4
   619 0000042E 50                          push eax
   620 0000042F 240F                        and  al,0xf
   621 00000431 3C09                        cmp  al,9
   622 00000433 7704                        ja   putx_vga_hexdigit
   623 00000435 0430                        add  al,'0'
   624 00000437 EB02                        jmp short putx_vga_putc
   625                                  putx_vga_hexdigit :
   626 00000439 0457                        add  al,'a'-10
   627                                  putx_vga_putc :
   628 0000043B 658803                      mov  [gs:ebx],al
   629 0000043E 83C302                      add  ebx,2
   630 00000441 58                          pop  eax
   631 00000442 83E0F0                      and  eax,0xfffffff0
   632 00000445 E2E4                        loop putx_vga_loop
   633 00000447 65C60320                    mov  byte [gs:ebx],' '
   634 0000044B 83C302                      add  ebx,2
   635 0000044E 59                          pop  ecx
   636 0000044F C3                          ret
   637                                  
   638                                  ;------------------------------------------------------------------
   639                                  ;   mem_alloc_kernel_page - return the 4k page number of 1 page of memory
   640                                  ;                           from the kernel page pool
   641                                  ;
   642                                  ;   returns:    eax = page number, zero means no pages left
   643                                  
   644                                  mem_alloc_kernel_page :
   645 00000450 A1[19030000]                mov  eax,[next_free_page]
   646 00000455 FF05[19030000]              inc  dword [next_free_page]
   647                                      ; probably should check for the end of something ...
   648 0000045B 50                          push eax
   649 0000045C 51                          push ecx
   650 0000045D 57                          push edi
   651 0000045E C1E00C                      shl  eax,12
   652 00000461 B900040000                  mov  ecx,0x1000/4
   653 00000466 89C7                        mov  edi,eax
   654 00000468 31C0                        xor  eax,eax
   655 0000046A F3AB                        rep stosd                   ; zero the page
   656 0000046C 5F                          pop  edi
   657 0000046D 59                          pop  ecx
   658 0000046E 58                          pop  eax
   659 0000046F C3                          ret
   660                                  
   661                                  ;------------------------------------------------------------------
   662                                  ;   create a pair of tss structs for a new cpu
   663                                  ;
   664                                  ;   enter:
   665                                  ;       ebx - cpu number
   666                                  ;   exit:
   667                                  ;       ebx - cpu number
   668                                  
   669                                  create_tss_pair :
   670 00000470 E8DBFFFFFF                  call mem_alloc_kernel_page
   671 00000475 09C0                        or   eax,eax
   672 00000477 0F8495000000                jz   create_tss_pair_fail
   673 0000047D C1E00C                      shl  eax,12                 ; convert pgno to physical addr
   674 00000480 89C7                        mov  edi,eax
   675                                  
   676 00000482 89FE                        mov  esi,edi
   677 00000484 83C668                      add  esi,(tss0_end-tss0)
   678                                  
   679 00000487 B800300000                  mov  eax,pgdir
   680 0000048C 89471C                      mov  [edi+(tss0_cr3-tss0)],eax
   681 0000048F 89461C                      mov  [esi+(tss0_cr3-tss0)],eax
   682                                  
   683 00000492 B817000000                  mov  eax,datasel1+7
   684 00000497 894648                      mov  [esi+(tss0_es-tss0)],eax
   685 0000049A 894650                      mov  [esi+(tss0_ss-tss0)],eax
   686 0000049D 894654                      mov  [esi+(tss0_ds-tss0)],eax
   687 000004A0 B80F000000                  mov  eax,codesel1+7
   688 000004A5 89464C                      mov  [esi+(tss0_cs-tss0)],eax
   689 000004A8 B83B000000                  mov  eax,ldtsel1+3
   690 000004AD 894660                      mov  [esi+(tss0_ldt-tss0)],eax
   691                                  
   692                                      ; setup the tss structs (edi = kernel, esi = user).
   693                                      ; there are three stacks total
   694                                      ;   (1) kernel tss esp0 - placed at the end of this page
   695                                      ;   (2) user tss esp0 (for interrupt handling) - end minus 1k
   696                                      ;   (3) user tss esp3 (esp) - will be set up by new_thread
   697                                  
   698 000004B0 89F8                        mov  eax,edi
   699 000004B2 0500100000                  add  eax,0x1000
   700 000004B7 894704                      mov  [edi+(tss0_esp0-tss0)],eax ; (1) kernel tss esp0
   701 000004BA 2D00040000                  sub  eax,0x400
   702 000004BF 894604                      mov  [esi+(tss0_esp0-tss0)],eax ; (2) user tss esp0
   703                                      ;mov  eax,stacksel
   704 000004C2 B810000000                  mov  eax,datasel
   705 000004C7 894708                      mov  [edi+(tss0_ss0-tss0)],eax
   706 000004CA 894608                      mov  [esi+(tss0_ss0-tss0)],eax
   707                                  
   708                                      ; patch the tss addresses into the reserved gdt selectors
   709                                  
   710 000004CD 89DA                        mov  edx,ebx
   711 000004CF C1E204                      shl  edx,4                      ; 16x because selectors are in pairs
   712 000004D2 83C250                      add  edx,tasksel_k00
   713                                  
   714 000004D5 89F8                        mov  eax,edi
   715 000004D7 C1E818                      shr  eax,24
   716 000004DA 8882[07000000]              mov  byte [gdt+edx+7],al        ; base 24-32
   717 000004E0 81E7FFFFFF00                and  edi,0xffffff
   718 000004E6 0BBA[02000000]              or   edi,[gdt+edx+2]            ; or in flags
   719 000004EC 89BA[02000000]              mov  [gdt+edx+2],edi            ; base 0-23 and flags
   720                                  
   721 000004F2 83C208                      add  edx,8                      ; move to tasksel_uxx
   722                                  
   723 000004F5 89F0                        mov  eax,esi
   724 000004F7 C1E818                      shr  eax,24
   725 000004FA 8882[07000000]              mov  byte [gdt+edx+7],al        ; base 24-32
   726 00000500 81E6FFFFFF00                and  esi,0xffffff
   727 00000506 0BB2[02000000]              or   esi,[gdt+edx+2]            ; or in flags
   728 0000050C 89B2[02000000]              mov  [gdt+edx+2],esi            ; base 0-23 and flags
   729                                  
   730                                  create_tss_pair_fail :
   731 00000512 C3                          ret
   732                                  
   733                                  ; -------- interrupt handlers --------
   734                                  %include "ozirq.asm"
   735                              <1> ; OZ - A more utopian OS    x86-32 interrupts
   736                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
   737                              <1> ;
   738                              <1> ; Copyright (C) 2015  Duane Voth
   739                              <1> ;
   740                              <1> ;   This program is free software: you can redistribute it and/or modify
   741                              <1> ;   it under the terms of the GNU Affero General Public License as
   742                              <1> ;   published by the Free Software Foundation, either version 3 of the
   743                              <1> ;   License, or (at your option) any later version.
   744                              <1> ;
   745                              <1> ;   This program is distributed in the hope that it will be useful,
   746                              <1> ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
   747                              <1> ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   748                              <1> ;   GNU Affero General Public License for more details.
   749                              <1> ;
   750                              <1> ;   You should have received a copy of the GNU Affero General Public License
   751                              <1> ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
   752                              <1> ;
   753                              <1> ;
   754                              <1> ; IRQ handling
   755                              <1> 
   756 00000513 63707500            <1> cpumsg      db      "cpu",0
   757                              <1> 
   758 00000517 646976696465206279- <1> int00msg    db      "divide by zero ",0
   759 00000520 207A65726F2000      <1>
   760 00000527 646562756720657863- <1> int01msg    db      "debug exception ",0
   761 00000530 657074696F6E2000    <1>
   762 00000538 6E6D692000          <1> int02msg    db      "nmi ",0
   763 0000053D 627265616B706F696E- <1> int03msg    db      "breakpoint exception ",0
   764 00000546 742065786365707469- <1>
   765 0000054F 6F6E2000            <1>
   766 00000553 6F766572666C6F7720- <1> int04msg    db      "overflow exception ",0
   767 0000055C 657863657074696F6E- <1>
   768 00000565 2000                <1>
   769 00000567 626F756E6420657863- <1> int05msg    db      "bound exceeded ",0
   770 00000570 65656465642000      <1>
   771 00000577 696E76616C6964206F- <1> int06msg    db      "invalid opcode ",0
   772 00000580 70636F64652000      <1>
   773 00000587 64657669636520756E- <1> int07msg    db      "device unavailable ",0
   774 00000590 617661696C61626C65- <1>
   775 00000599 2000                <1>
   776 0000059B 646F75626C65206661- <1> int08msg    db      "double fault ",0
   777 000005A4 756C742000          <1>
   778 000005A9 636F70726F63657373- <1> int09msg    db      "coprocessor segment overrun ",0
   779 000005B2 6F72207365676D656E- <1>
   780 000005BB 74206F76657272756E- <1>
   781 000005C4 2000                <1>
   782 000005C6 696E76616C69642074- <1> int10msg    db      "invalid tss ",0
   783 000005CF 73732000            <1>
   784 000005D3 7365676D656E74206E- <1> int11msg    db      "segment not present ",0
   785 000005DC 6F742070726573656E- <1>
   786 000005E5 742000              <1>
   787 000005E8 737461636B20666175- <1> int12msg    db      "stack fault ",0
   788 000005F1 6C742000            <1>
   789 000005F5 67656E6572616C2070- <1> int13msg    db      "general protection fault ",0
   790 000005FE 726F74656374696F6E- <1>
   791 00000607 206661756C742000    <1>
   792 0000060F 6B65726E656C207061- <1> int14kmsg   db      "kernel page fault addr=",0
   793 00000618 6765206661756C7420- <1>
   794 00000621 616464723D00        <1>
   795 00000627 617070207061676520- <1> int14umsg   db      "app page fault addr=",0
   796 00000630 6661756C7420616464- <1>
   797 00000639 723D00              <1>
   798 0000063C 666C6F6174696E6720- <1> int16msg    db      "floating point err ",0
   799 00000645 706F696E7420657272- <1>
   800 0000064E 2000                <1>
   801 00000650 616C69676E6D656E74- <1> int17msg    db      "alignment check ",0
   802 00000659 20636865636B2000    <1>
   803 00000661 6D616368696E652063- <1> int18msg    db      "machine check ",0
   804 0000066A 6865636B2000        <1>
   805 00000670 73696D6420666C6F61- <1> int19msg    db      "simd floating point err ",0
   806 00000679 74696E6720706F696E- <1>
   807 00000682 74206572722000      <1>
   808                              <1> 
   809 00000689 687720696E74303220- <1> int34msg    db      "hw int02 ",0
   810 00000692 00                  <1>
   811 00000693 687720696E74303320- <1> int35msg    db      "hw int03 ",0
   812 0000069C 00                  <1>
   813 0000069D 687720696E74303420- <1> int36msg    db      "hw int04 ",0
   814 000006A6 00                  <1>
   815 000006A7 687720696E74303520- <1> int37msg    db      "hw int05 ",0
   816 000006B0 00                  <1>
   817 000006B1 687720696E74303620- <1> int38msg    db      "hw int06 ",0
   818 000006BA 00                  <1>
   819 000006BB 687720696E74303720- <1> int39msg    db      "hw int07 ",0
   820 000006C4 00                  <1>
   821 000006C5 687720696E74303820- <1> int40msg    db      "hw int08 ",0
   822 000006CE 00                  <1>
   823 000006CF 687720696E74303920- <1> int41msg    db      "hw int09 ",0
   824 000006D8 00                  <1>
   825 000006D9 687720696E74313020- <1> int42msg    db      "hw int10 ",0
   826 000006E2 00                  <1>
   827 000006E3 687720696E74313120- <1> int43msg    db      "hw int11 ",0
   828 000006EC 00                  <1>
   829 000006ED 687720696E74313220- <1> int44msg    db      "hw int12 ",0
   830 000006F6 00                  <1>
   831 000006F7 687720696E74313320- <1> int45msg    db      "hw int13 ",0
   832 00000700 00                  <1>
   833 00000701 687720696E74313420- <1> int46msg    db      "hw int14 ",0
   834 0000070A 00                  <1>
   835 0000070B 687720696E74313520- <1> int47msg    db      "hw int15 ",0
   836 00000714 00                  <1>
   837                              <1> 
   838 00000715 73707572696F757320- <1> spuriousmsg db      "spurious int ",0
   839 0000071E 696E742000          <1>
   840 00000723 617069636572722069- <1> apicerrmsg  db      "apicerr int ",0
   841 0000072C 6E742000            <1>
   842 00000730 68692000            <1> himsg       db      "hi ",0
   843 00000734 756E6B6E6F776E2073- <1> int255msg           db  "unknown system call ",0
   844 0000073D 797374656D2063616C- <1>
   845 00000746 6C2000              <1>
   846                              <1> 
   847 00000749 766D206661756C743A- <1> intvmmsg            db  "vm fault: ",0
   848 00000752 2000                <1>
   849                              <1> 
   850                              <1> ; ---- IRQ hardware initialization ----
   851                              <1> 
   852                              <1> bits 16
   853                              <1> 
   854                              <1> irq_init_hardware :
   855                              <1> 
   856                              <1>     ; re-program the 8259's to move the hardware vectors out of the
   857                              <1>     ; soft int range ... C'mon, Intel was pretty clear about this!
   858                              <1> 
   859 00000754 B011                <1>     mov  al,0x11
   860 00000756 E620                <1>     out  0x20,al            ; init the 1st 8259
   861 00000758 B011                <1>     mov  al,0x11
   862 0000075A E6A0                <1>     out  0xA0,al            ; init the 2nd 8259
   863 0000075C B020                <1>     mov  al,apic0_irqbase
   864 0000075E E621                <1>     out  0x21,al            ; base for the 1st 8259
   865 00000760 B028                <1>     mov  al,apic1_irqbase
   866 00000762 E6A1                <1>     out  0xA1,al            ; base for the 2nd 8259
   867 00000764 B004                <1>     mov  al,0x04
   868 00000766 E621                <1>     out  0x21,al            ; set 1st 8259 as master
   869 00000768 B002                <1>     mov  al,0x02
   870 0000076A E6A1                <1>     out  0xA1,al            ; set 2nd 8259 as slave
   871 0000076C B001                <1>     mov  al,0x01
   872 0000076E E621                <1>     out  0x21,al
   873 00000770 B001                <1>     mov  al,0x01
   874 00000772 E6A1                <1>     out  0xA1,al
   875 00000774 B000                <1>     mov  al,0x00
   876 00000776 E621                <1>     out  0x21,al
   877 00000778 B000                <1>     mov  al,0x00
   878 0000077A E6A1                <1>     out  0xA1,al
   879 0000077C C3                  <1>     ret
   880                              <1> 
   881                              <1> bits 32
   882                              <1> 
   883                              <1> ; ----------
   884                              <1> 
   885                              <1> irq_init_bsp_apic_hardware :
   886                              <1>     ;jmp  no_apic
   887                              <1> 
   888                              <1>     ; ---- test for an apic
   889                              <1> 
   890 0000077D B801000000          <1>     mov  eax,1
   891 00000782 0FA2                <1>     cpuid
   892 00000784 83F801              <1>     cmp  eax,1
   893 00000787 724A                <1>     jb   no_apic
   894 00000789 81E200020000        <1>     and  edx,1 << 9         ; apic feature
   895 0000078F 7442                <1>     jz   no_apic
   896                              <1> 
   897                              <1> ;   mov  eax,[0xfee00370]
   898                              <1> ;   and  eax,0xffffff00
   899                              <1> ;   or   eax,apicerr_int
   900                              <1> ;   mov  [0xfee00370],eax   ; setup LVT3 error vector
   901                              <1> 
   902 00000791 A13000E0FE          <1>     mov  eax,[0xfee00030]
   903 00000796 25F0000000          <1>     and  eax,0xf0           ; see if it is a local apic
   904 0000079B 83F810              <1>     cmp  eax,0x10
   905 0000079E 7533                <1>     jnz  no_lapic
   906 000007A0 C605[18030000]01    <1>     mov  byte [enabled_lapic],0x1
   907                              <1> 
   908 000007A7 B8F0010000          <1>     mov  eax,0x000001f0     ; enable lapic, use spurious int 0xf0
   909 000007AC A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
   910 000007B1 B800000001          <1>     mov  eax,0x01000000
   911 000007B6 A3D000E0FE          <1>     mov  [0xfee000d0],eax   ; set our LDR
   912 000007BB B8FFFFFFFF          <1>     mov  eax,0xffffffff
   913 000007C0 A3E000E0FE          <1>     mov  [0xfee000e0],eax   ; set our DFR
   914                              <1> 
   915                              <1> ;    ; ---- enable the local apic via msr
   916                              <1> ; but apparently not needed ...
   917                              <1> ;    mov  ecx,0x1b
   918                              <1> ;    xor  edx,edx
   919                              <1> ; ;  mov  eax,0xfffff800
   920                              <1> ;    mov  eax,0x00000800
   921                              <1> ;    wrmsr
   922                              <1> ;    mov  eax,[0xfffff030]
   923                              <1> 
   924                              <1>     ; ---- visual indicator: lapic active
   925                              <1> 
   926 000007C5 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
   927 000007C9 8EE8                <1>     mov  gs,ax          
   928 000007CB 65C605320000002B    <1>     mov  byte [gs:25*2],'+'
   929                              <1> 
   930                              <1> no_apic :
   931                              <1> no_lapic :
   932 000007D3 C3                  <1>     ret
   933                              <1> 
   934                              <1> ; ----------
   935                              <1> 
   936                              <1> irq_init_ap_apic_hardware :
   937                              <1> 
   938                              <1>     ; ---- mtrr for 0xfee00000 -> strong uncachable (UC) ?
   939                              <1> 
   940 000007D4 50                  <1>     push eax                ; save cpu number
   941 000007D5 89C1                <1>     mov  ecx,eax
   942 000007D7 A0[18030000]        <1>     mov  al,[enabled_lapic]
   943 000007DC 08C0                <1>     or   al,al
   944 000007DE 7432                <1>     jz  no_lapic_init2
   945                              <1> 
   946 000007E0 BB00000001          <1>     mov  ebx,0x01000000
   947 000007E5 D3E3                <1>     shl  ebx,cl             ; bit mask based on cpu number
   948 000007E7 891DD000E0FE        <1>     mov  [0xfee000d0],ebx   ; set our LDR
   949                              <1> 
   950 000007ED A17003E0FE          <1>     mov  eax,[0xfee00370]
   951 000007F2 2500FFFFFF          <1>     and  eax,0xffffff00
   952 000007F7 0DF1000000          <1>     or   eax,apicerr_int
   953 000007FC A37003E0FE          <1>     mov  [0xfee00370],eax   ; setup LVT3 error vector
   954                              <1> 
   955 00000801 B8F0010000          <1>     mov  eax,0x00000100 + spurious_int  ; enable lapic
   956 00000806 A3F000E0FE          <1>     mov  [0xfee000f0],eax   ; Spurious interrupt vector reg
   957 0000080B 31C0                <1>     xor  eax,eax
   958 0000080D A3B000E0FE          <1>     mov  [0xfee000b0],eax   ; eoi anything outstanding
   959                              <1> no_lapic_init2 :
   960 00000812 58                  <1>     pop  eax
   961 00000813 C3                  <1>     ret
   962                              <1> 
   963                              <1> ; ---- IRQ handlers ----
   964                              <1> 
   965                              <1> align 4
   966                              <1> int_handler_div0 :
   967 00000814 56                  <1>     push esi
   968 00000815 BE[17050000]        <1>     mov  esi,int00msg
   969 0000081A E856040000          <1>     call irq_print_msg
   970 0000081F 5E                  <1>     pop  esi
   971 00000820 E9F0000000          <1>     jmp  int_handler_show_eip
   972                              <1> 
   973 00000825 90<rept>            <1> align 4
   974                              <1> int_handler_debug :
   975 00000828 56                  <1>     push esi
   976 00000829 BE[27050000]        <1>     mov  esi,int01msg
   977 0000082E E842040000          <1>     call irq_print_msg
   978 00000833 5E                  <1>     pop  esi
   979 00000834 E9DC000000          <1>     jmp  int_handler_show_eip
   980                              <1> 
   981 00000839 90<rept>            <1> align 4
   982                              <1> int_handler_nmi :
   983 0000083C 56                  <1>     push esi
   984 0000083D BE[38050000]        <1>     mov  esi,int02msg
   985 00000842 E82E040000          <1>     call irq_print_msg
   986 00000847 5E                  <1>     pop  esi
   987 00000848 E958040000          <1>     jmp  reboot_on_alt_key
   988                              <1> 
   989 0000084D 90<rept>            <1> align 4
   990                              <1> int_handler_brkp :
   991 00000850 56                  <1>     push esi
   992 00000851 BE[3D050000]        <1>     mov  esi,int03msg
   993 00000856 E81A040000          <1>     call irq_print_msg
   994 0000085B 5E                  <1>     pop  esi
   995 0000085C E9B4000000          <1>     jmp  int_handler_show_eip
   996                              <1> 
   997 00000861 90<rept>            <1> align 4
   998                              <1> int_handler_ovrflw :
   999 00000864 56                  <1>     push esi
  1000 00000865 BE[53050000]        <1>     mov  esi,int04msg
  1001 0000086A E806040000          <1>     call irq_print_msg
  1002 0000086F 5E                  <1>     pop  esi
  1003 00000870 E9A0000000          <1>     jmp  int_handler_show_eip
  1004                              <1> 
  1005 00000875 90<rept>            <1> align 4
  1006                              <1> int_handler_bound :
  1007 00000878 56                  <1>     push esi
  1008 00000879 BE[67050000]        <1>     mov  esi,int05msg
  1009 0000087E E8F2030000          <1>     call irq_print_msg
  1010 00000883 5E                  <1>     pop  esi
  1011 00000884 E98C000000          <1>     jmp  int_handler_show_eip
  1012                              <1> 
  1013 00000889 90<rept>            <1> align 4
  1014                              <1> int_handler_invop :
  1015 0000088C 56                  <1>     push esi
  1016 0000088D BE[77050000]        <1>     mov  esi,int06msg
  1017 00000892 E8DE030000          <1>     call irq_print_msg
  1018 00000897 5E                  <1>     pop  esi
  1019 00000898 EB7B                <1>     jmp  int_handler_show_eip
  1020                              <1> 
  1021 0000089A 90<rept>            <1> align 4
  1022                              <1> int_handler_devna :
  1023                              <1>     ;push esi
  1024                              <1>     ;mov  esi,int07msg
  1025                              <1>     ;call irq_print_msg
  1026                              <1>     ;pop  esi
  1027                              <1>     ; FIXME fxsave/fxrestore the fpu/sse/mmx regs
  1028 0000089C 0F06                <1>     clts
  1029 0000089E CF                  <1>     iret
  1030                              <1> 
  1031 0000089F 90                  <1> align 4
  1032                              <1> int_handler_cpsego :
  1033 000008A0 56                  <1>     push esi
  1034 000008A1 BE[A9050000]        <1>     mov  esi,int09msg
  1035 000008A6 E8CA030000          <1>     call irq_print_msg
  1036 000008AB 5E                  <1>     pop  esi
  1037 000008AC EB67                <1>     jmp  int_handler_show_eip
  1038                              <1> 
  1039 000008AE 90<rept>            <1> align 4
  1040                              <1> int_handler_segnp :
  1041                              <1>     ; ec = seg selector
  1042 000008B0 56                  <1>     push esi
  1043 000008B1 BE[D3050000]        <1>     mov  esi,int11msg
  1044 000008B6 E8BA030000          <1>     call irq_print_msg
  1045 000008BB 5E                  <1>     pop  esi
  1046 000008BC EB32                <1>     jmp  int_handler_show_ec_eip
  1047                              <1> 
  1048 000008BE 90<rept>            <1> align 4
  1049                              <1> int_handler_stkflt :
  1050                              <1>     ; ec = seg selector
  1051 000008C0 56                  <1>     push esi
  1052 000008C1 BE[E8050000]        <1>     mov  esi,int12msg
  1053 000008C6 E8AA030000          <1>     call irq_print_msg
  1054 000008CB 5E                  <1>     pop  esi
  1055 000008CC B904000000          <1>     mov  ecx,4
  1056 000008D1 83C302              <1>     add  ebx,2
  1057                              <1> int_handler_show_stack_loop :
  1058 000008D4 58                  <1>     pop  eax
  1059 000008D5 E84BFBFFFF          <1>     call putx_vga
  1060 000008DA E2F8                <1>     loop int_handler_show_stack_loop
  1061 000008DC E9C4030000          <1>     jmp  reboot_on_alt_key
  1062                              <1> 
  1063 000008E1 90<rept>            <1> align 4
  1064                              <1> int_handler_gpf :
  1065                              <1>     ; ec = various ...
  1066                              <1>     ;test dword [esp+0xc],1 << 17    ; check the eflags vm bit
  1067                              <1>     ;jnz  int_handler_vm_gpf
  1068                              <1> 
  1069 000008E4 56                  <1>     push esi
  1070 000008E5 BE[F5050000]        <1>     mov  esi,int13msg
  1071 000008EA E886030000          <1>     call irq_print_msg
  1072 000008EF 5E                  <1>     pop  esi
  1073                              <1> int_handler_show_ec_eip :
  1074 000008F0 65C60365            <1>     mov  byte [gs:ebx],'e'
  1075 000008F4 83C302              <1>     add  ebx,2
  1076 000008F7 65C60363            <1>     mov  byte [gs:ebx],'c'
  1077 000008FB 83C302              <1>     add  ebx,2
  1078 000008FE 65C6033D            <1>     mov  byte [gs:ebx],'='
  1079 00000902 83C302              <1>     add  ebx,2
  1080 00000905 58                  <1>     pop  eax                ; ec
  1081 00000906 E80AFBFFFF          <1>     call putbx_vga
  1082 0000090B 83EB02              <1>     sub  ebx,2
  1083 0000090E 65C60320            <1>     mov  byte [gs:ebx],' '
  1084 00000912 83C302              <1>     add  ebx,2
  1085                              <1> int_handler_show_eip :
  1086 00000915 65C60363            <1>     mov  byte [gs:ebx],'c'
  1087 00000919 83C302              <1>     add  ebx,2
  1088 0000091C 65C60373            <1>     mov  byte [gs:ebx],'s'
  1089 00000920 83C302              <1>     add  ebx,2
  1090 00000923 65C6033A            <1>     mov  byte [gs:ebx],':'
  1091 00000927 83C302              <1>     add  ebx,2
  1092 0000092A 65C60365            <1>     mov  byte [gs:ebx],'e'
  1093 0000092E 83C302              <1>     add  ebx,2
  1094 00000931 65C60369            <1>     mov  byte [gs:ebx],'i'
  1095 00000935 83C302              <1>     add  ebx,2
  1096 00000938 65C60370            <1>     mov  byte [gs:ebx],'p'
  1097 0000093C 83C302              <1>     add  ebx,2
  1098 0000093F 65C6033D            <1>     mov  byte [gs:ebx],'='
  1099 00000943 83C302              <1>     add  ebx,2
  1100 00000946 5A                  <1>     pop  edx                ; eip
  1101 00000947 58                  <1>     pop  eax                ; cs
  1102 00000948 E8D8FAFFFF          <1>     call putx_vga
  1103 0000094D 83EB02              <1>     sub  ebx,2
  1104 00000950 65C6033A            <1>     mov  byte [gs:ebx],':'
  1105 00000954 83C302              <1>     add  ebx,2
  1106 00000957 89D0                <1>     mov  eax,edx
  1107 00000959 E8C7FAFFFF          <1>     call putx_vga
  1108 0000095E E942030000          <1>     jmp  reboot_on_alt_key
  1109                              <1> 
  1110                              <1> int_handler_vm_gpf :
  1111 00000963 53                  <1>     push ebx
  1112                              <1>     ;mov  ebx,[esp+8]        ; faulter's eip
  1113 00000964 2E8A1B              <1>     mov  bl,[cs:ebx]        ; get the opcode that caused the fault
  1114 00000967 80FBF4              <1>     cmp  bl,0xf4            ; 'hlt' is ok
  1115 0000096A 7452                <1>     jz   int_handler_vm_normal_return
  1116                              <1> 
  1117 0000096C 56                  <1>     push esi
  1118 0000096D 50                  <1>     push eax
  1119 0000096E 53                  <1>     push ebx
  1120 0000096F BE[49070000]        <1>     mov  esi,intvmmsg
  1121 00000974 E8FC020000          <1>     call irq_print_msg
  1122 00000979 65C6036F            <1>     mov  byte [gs:ebx],'o'
  1123 0000097D 83C302              <1>     add  ebx,2
  1124 00000980 65C60370            <1>     mov  byte [gs:ebx],'p'
  1125 00000984 83C302              <1>     add  ebx,2
  1126 00000987 65C60363            <1>     mov  byte [gs:ebx],'c'
  1127 0000098B 83C302              <1>     add  ebx,2
  1128 0000098E 65C6036F            <1>     mov  byte [gs:ebx],'o'
  1129 00000992 83C302              <1>     add  ebx,2
  1130 00000995 65C60364            <1>     mov  byte [gs:ebx],'d'
  1131 00000999 83C302              <1>     add  ebx,2
  1132 0000099C 65C60365            <1>     mov  byte [gs:ebx],'e'
  1133 000009A0 83C302              <1>     add  ebx,2
  1134 000009A3 65C60328            <1>     mov  byte [gs:ebx],'('
  1135 000009A7 83C302              <1>     add  ebx,2
  1136 000009AA 58                  <1>     pop  eax
  1137 000009AB 25FF000000          <1>     and  eax,0xff
  1138 000009B0 E860FAFFFF          <1>     call putbx_vga
  1139 000009B5 83C302              <1>     add  ebx,2
  1140 000009B8 65C60329            <1>     mov  byte [gs:ebx],')'
  1141 000009BC 58                  <1>     pop  eax
  1142 000009BD 5E                  <1>     pop  esi
  1143                              <1> int_handler_vm_normal_return :
  1144 000009BE 5B                  <1>     pop  ebx
  1145                              <1> 
  1146 000009BF FF74240C            <1>     push dword [esp+0xc]    ; eflags
  1147 000009C3 9D                  <1>     popf                    ; restore the VM and NT flags
  1148 000009C4 CF                  <1>     iret                    ; chain back via nested task
  1149                              <1>                             ; from v86 tss to original caller
  1150                              <1> 
  1151 000009C5 90<rept>            <1> align 4
  1152                              <1> int_handler_pgflt :
  1153 000009C8 58                  <1>     pop  eax
  1154 000009C9 50                  <1>     push eax
  1155 000009CA A904000000          <1>     test eax,0x4                        ; user mode or supervisor?
  1156 000009CF 7407                <1>     jz   int_handler_pgflt_bad_kaddr    ; if not, kernel failed
  1157                              <1> 
  1158                              <1> int_handler_pgflt_bad_uaddr :
  1159 000009D1 BE[27060000]        <1>     mov  esi,int14umsg
  1160 000009D6 EB05                <1>     jmp  int_handler_pgflt_msg
  1161                              <1> 
  1162                              <1> int_handler_pgflt_bad_kaddr :
  1163 000009D8 BE[0F060000]        <1>     mov  esi,int14kmsg
  1164                              <1> 
  1165                              <1> int_handler_pgflt_msg :
  1166 000009DD E893020000          <1>     call irq_print_msg
  1167 000009E2 0F20D0              <1>     mov  eax,cr2
  1168 000009E5 E83BFAFFFF          <1>     call putx_vga                       ; print the addres of the fault
  1169 000009EA E901FFFFFF          <1>     jmp  int_handler_show_ec_eip
  1170                              <1> 
  1171 000009EF 90                  <1> align 4
  1172                              <1> int_handler_fpuerr :
  1173 000009F0 56                  <1>     push esi
  1174 000009F1 BE[3C060000]        <1>     mov  esi,int16msg
  1175 000009F6 E87A020000          <1>     call irq_print_msg
  1176                              <1>     ; FIXME flags identify error
  1177                              <1>     ;   IS - FPU stack overflow
  1178                              <1>     ;   IA - Invalid arithmetic operation
  1179                              <1>     ;   Z  - Divide by zero
  1180                              <1>     ;   D  - Source operand is a denormal number
  1181                              <1>     ;   O  - Overflow in result
  1182                              <1>     ;   U  - Underflow in result
  1183                              <1>     ;   P  - Inexact result
  1184 000009FB E915FFFFFF          <1>     jmp  int_handler_show_eip
  1185                              <1> 
  1186                              <1> align 4
  1187                              <1> int_handler_algnchk :
  1188                              <1>     ; ec = zero
  1189 00000A00 56                  <1>     push esi
  1190 00000A01 BE[50060000]        <1>     mov  esi,int17msg
  1191 00000A06 E86A020000          <1>     call irq_print_msg
  1192 00000A0B 5E                  <1>     pop  esi
  1193 00000A0C 58                  <1>     pop  eax                    ; toss the ec
  1194 00000A0D E903FFFFFF          <1>     jmp  int_handler_show_eip
  1195                              <1> 
  1196 00000A12 90<rept>            <1> align 4
  1197                              <1> int_handler_machchk :
  1198 00000A14 56                  <1>     push esi
  1199 00000A15 BE[61060000]        <1>     mov  esi,int18msg
  1200 00000A1A E856020000          <1>     call irq_print_msg
  1201 00000A1F 5E                  <1>     pop  esi
  1202 00000A20 E9F0FEFFFF          <1>     jmp  int_handler_show_eip
  1203                              <1> 
  1204 00000A25 90<rept>            <1> align 4
  1205                              <1> int_handler_simdfpe :
  1206 00000A28 56                  <1>     push esi
  1207 00000A29 BE[70060000]        <1>     mov  esi,int19msg
  1208 00000A2E E842020000          <1>     call irq_print_msg
  1209 00000A33 5E                  <1>     pop  esi
  1210 00000A34 E9DCFEFFFF          <1>     jmp  int_handler_show_eip
  1211                              <1> 
  1212 00000A39 90<rept>            <1> align 4
  1213                              <1> int_handler_timer :     
  1214                              <1>     ;cli
  1215 00000A3C 60                  <1>     pusha
  1216 00000A3D 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
  1217 00000A41 8EE8                <1>     mov  gs,ax          
  1218 00000A43 658A1D01000000      <1>     mov  bl,byte [gs:1]     ; inc the color of the first two chars
  1219 00000A4A FEC3                <1>     inc  bl
  1220 00000A4C 80E30F              <1>     and  bl,0xf             ; just the foreground
  1221 00000A4F 65881D01000000      <1>     mov  byte [gs:1],bl
  1222 00000A56 65881D03000000      <1>     mov  byte [gs:3],bl
  1223                              <1> 
  1224                              <1>     ; ---- wakeup any sleeping cpus (see syscall_sleep)
  1225                              <1> 
  1226 00000A5D A0[18030000]        <1>     mov  al,[enabled_lapic]
  1227 00000A62 08C0                <1>     or   al,al
  1228 00000A64 741B                <1>     jz   no_sleepers
  1229                              <1> 
  1230                              <1>     ; the race here is not important, we'll catch them on the next tick
  1231                              <1> 
  1232 00000A66 A1[1D030000]        <1>     mov  eax,[sleepers]
  1233 00000A6B 09C0                <1>     or   eax,eax
  1234 00000A6D 7412                <1>     jz   no_sleepers
  1235 00000A6F C1E018              <1>     shl  eax,24                     ; FIXME can only handle 8 cpus
  1236 00000A72 A31003E0FE          <1>     mov  dword [0xfee00310],eax     ; via the destination register ...
  1237 00000A77 B8FE480000          <1>     mov  eax,0x04800 + wakeup_int   ; no shrthnd, fixed, logical, edge
  1238 00000A7C A30003E0FE          <1>     mov  dword [0xfee00300],eax
  1239                              <1> 
  1240                              <1> no_sleepers :
  1241 00000A81 B020                <1>     mov  al,0x20        
  1242 00000A83 E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1243 00000A85 61                  <1>     popa
  1244 00000A86 CF                  <1>     iret                
  1245                              <1> 
  1246 00000A87 90                  <1> align 4
  1247                              <1> int_handler_kbd :
  1248                              <1>     ;cli
  1249 00000A88 B020                <1>     mov  al,0x20
  1250 00000A8A E620                <1>     out  0x20,al            ; signal end of interrupt (eoi)
  1251                              <1> 
  1252 00000A8C 66B82000            <1>     mov  ax,videosel        ; point gs at video memory
  1253 00000A90 8EE8                <1>     mov  gs,ax          
  1254                              <1> 
  1255 00000A92 53                  <1>     push ebx
  1256 00000A93 BB3C000000          <1>     mov  ebx,30*2
  1257 00000A98 E460                <1>     in   al,0x60
  1258 00000A9A 50                  <1>     push eax
  1259 00000A9B E875F9FFFF          <1>     call putbx_vga
  1260 00000AA0 58                  <1>     pop  eax
  1261                              <1> 
  1262 00000AA1 3C5B                <1>     cmp  al,0x5b            ; scan code for "the windows key"
  1263 00000AA3 0F8403020000        <1>     jz   reboot
  1264                              <1> 
  1265 00000AA9 65A044000000        <1>     mov  al,[gs:34*2]
  1266 00000AAF FEC0                <1>     inc  al
  1267 00000AB1 65A244000000        <1>     mov  [gs:34*2],al       ; change a character on screen
  1268                              <1> 
  1269 00000AB7 5B                  <1>     pop  ebx
  1270 00000AB8 CF                  <1>     iret
  1271                              <1> 
  1272 00000AB9 90<rept>            <1> align 4
  1273                              <1> int_handler_hw02 :
  1274 00000ABC 56                  <1>     push esi
  1275 00000ABD BE[89060000]        <1>     mov  esi,int34msg
  1276 00000AC2 E8AE010000          <1>     call irq_print_msg
  1277 00000AC7 5E                  <1>     pop  esi
  1278 00000AC8 E9D8010000          <1>     jmp  reboot_on_alt_key
  1279                              <1> 
  1280 00000ACD 90<rept>            <1> align 4
  1281                              <1> int_handler_hw03 :
  1282 00000AD0 56                  <1>     push esi
  1283 00000AD1 BE[93060000]        <1>     mov  esi,int35msg
  1284 00000AD6 E89A010000          <1>     call irq_print_msg
  1285 00000ADB 5E                  <1>     pop  esi
  1286 00000ADC E9C4010000          <1>     jmp  reboot_on_alt_key
  1287                              <1> 
  1288 00000AE1 90<rept>            <1> align 4
  1289                              <1> int_handler_hw04 :
  1290 00000AE4 56                  <1>     push esi
  1291 00000AE5 BE[9D060000]        <1>     mov  esi,int36msg
  1292 00000AEA E886010000          <1>     call irq_print_msg
  1293 00000AEF 5E                  <1>     pop  esi
  1294 00000AF0 E9B0010000          <1>     jmp  reboot_on_alt_key
  1295                              <1> 
  1296 00000AF5 90<rept>            <1> align 4
  1297                              <1> int_handler_hw05 :
  1298 00000AF8 56                  <1>     push esi
  1299 00000AF9 BE[A7060000]        <1>     mov  esi,int37msg
  1300 00000AFE E872010000          <1>     call irq_print_msg
  1301 00000B03 5E                  <1>     pop  esi
  1302 00000B04 E99C010000          <1>     jmp  reboot_on_alt_key
  1303                              <1> 
  1304 00000B09 90<rept>            <1> align 4
  1305                              <1> int_handler_hw06 :
  1306 00000B0C 56                  <1>     push esi
  1307 00000B0D BE[B1060000]        <1>     mov  esi,int38msg
  1308 00000B12 E85E010000          <1>     call irq_print_msg
  1309 00000B17 5E                  <1>     pop  esi
  1310 00000B18 E988010000          <1>     jmp  reboot_on_alt_key
  1311                              <1> 
  1312 00000B1D 90<rept>            <1> align 4
  1313                              <1> int_handler_hw07 :
  1314 00000B20 56                  <1>     push esi
  1315 00000B21 BE[BB060000]        <1>     mov  esi,int39msg
  1316 00000B26 E84A010000          <1>     call irq_print_msg
  1317 00000B2B 5E                  <1>     pop  esi
  1318 00000B2C E974010000          <1>     jmp  reboot_on_alt_key
  1319                              <1> 
  1320 00000B31 90<rept>            <1> align 4
  1321                              <1> int_handler_hw08 :
  1322 00000B34 56                  <1>     push esi
  1323 00000B35 BE[C5060000]        <1>     mov  esi,int40msg
  1324 00000B3A E836010000          <1>     call irq_print_msg
  1325 00000B3F 5E                  <1>     pop  esi
  1326 00000B40 E960010000          <1>     jmp  reboot_on_alt_key
  1327                              <1> 
  1328 00000B45 90<rept>            <1> align 4
  1329                              <1> int_handler_hw09 :
  1330 00000B48 56                  <1>     push esi
  1331 00000B49 BE[CF060000]        <1>     mov  esi,int41msg
  1332 00000B4E E822010000          <1>     call irq_print_msg
  1333 00000B53 5E                  <1>     pop  esi
  1334 00000B54 E94C010000          <1>     jmp  reboot_on_alt_key
  1335                              <1> 
  1336 00000B59 90<rept>            <1> align 4
  1337                              <1> int_handler_hw10 :
  1338 00000B5C 56                  <1>     push esi
  1339 00000B5D BE[D9060000]        <1>     mov  esi,int42msg
  1340 00000B62 E80E010000          <1>     call irq_print_msg
  1341 00000B67 5E                  <1>     pop  esi
  1342 00000B68 E938010000          <1>     jmp  reboot_on_alt_key
  1343                              <1> 
  1344 00000B6D 90<rept>            <1> align 4
  1345                              <1> int_handler_hw11 :
  1346 00000B70 56                  <1>     push esi
  1347 00000B71 BE[E3060000]        <1>     mov  esi,int43msg
  1348 00000B76 E8FA000000          <1>     call irq_print_msg
  1349 00000B7B 5E                  <1>     pop  esi
  1350 00000B7C E924010000          <1>     jmp  reboot_on_alt_key
  1351                              <1> 
  1352 00000B81 90<rept>            <1> align 4
  1353                              <1> int_handler_hw12 :
  1354 00000B84 56                  <1>     push esi
  1355 00000B85 BE[ED060000]        <1>     mov  esi,int44msg
  1356 00000B8A E8E6000000          <1>     call irq_print_msg
  1357 00000B8F 5E                  <1>     pop  esi
  1358 00000B90 E910010000          <1>     jmp  reboot_on_alt_key
  1359                              <1> 
  1360 00000B95 90<rept>            <1> align 4
  1361                              <1> int_handler_hw13 :
  1362 00000B98 56                  <1>     push esi
  1363 00000B99 BE[F7060000]        <1>     mov  esi,int45msg
  1364 00000B9E E8D2000000          <1>     call irq_print_msg
  1365 00000BA3 5E                  <1>     pop  esi
  1366 00000BA4 E9FC000000          <1>     jmp  reboot_on_alt_key
  1367                              <1> 
  1368 00000BA9 90<rept>            <1> align 4
  1369                              <1> int_handler_hw14 :
  1370 00000BAC 56                  <1>     push esi
  1371 00000BAD BE[01070000]        <1>     mov  esi,int46msg
  1372 00000BB2 E8BE000000          <1>     call irq_print_msg
  1373 00000BB7 5E                  <1>     pop  esi
  1374 00000BB8 E9E8000000          <1>     jmp  reboot_on_alt_key
  1375                              <1> 
  1376 00000BBD 90<rept>            <1> align 4
  1377                              <1> int_handler_hw15 :
  1378 00000BC0 56                  <1>     push esi
  1379 00000BC1 BE[0B070000]        <1>     mov  esi,int47msg
  1380 00000BC6 E8AA000000          <1>     call irq_print_msg
  1381 00000BCB 5E                  <1>     pop  esi
  1382 00000BCC E9D4000000          <1>     jmp  reboot_on_alt_key
  1383                              <1> 
  1384                              <1> ; called via the double fault task
  1385 00000BD1 90<rept>            <1> align 4
  1386                              <1> int_handler_tg_dblflt :
  1387 00000BD4 56                  <1>     push esi
  1388 00000BD5 BE[9B050000]        <1>     mov  esi,int08msg
  1389 00000BDA E896000000          <1>     call irq_print_msg
  1390 00000BDF 5E                  <1>     pop  esi
  1391 00000BE0 E9C0000000          <1>     jmp  reboot_on_alt_key
  1392                              <1> 
  1393                              <1> ; called via the invalid tss task
  1394 00000BE5 90<rept>            <1> align 4
  1395                              <1> int_handler_tg_invtss :
  1396 00000BE8 56                  <1>     push esi
  1397 00000BE9 BE[C6050000]        <1>     mov  esi,int10msg
  1398 00000BEE E882000000          <1>     call irq_print_msg
  1399 00000BF3 5E                  <1>     pop  esi
  1400                              <1>     ; FIXME need to go back to previous tss to get ec via that stack
  1401 00000BF4 83C302              <1>     add  ebx,2
  1402 00000BF7 58                  <1>     pop  eax                ; ec == invalid tss selector
  1403 00000BF8 E828F8FFFF          <1>     call putx_vga
  1404 00000BFD E9A3000000          <1>     jmp  reboot_on_alt_key
  1405                              <1> 
  1406 00000C02 90<rept>            <1> align 4
  1407                              <1> int_handler_spurious :
  1408 00000C04 56                  <1>     push esi
  1409 00000C05 BE[15070000]        <1>     mov  esi,spuriousmsg
  1410 00000C0A E866000000          <1>     call irq_print_msg
  1411 00000C0F 5E                  <1>     pop  esi
  1412 00000C10 CF                  <1>     iret
  1413                              <1> 
  1414 00000C11 90<rept>            <1> align 4
  1415                              <1> int_handler_apicerr :
  1416 00000C14 56                  <1>     push esi
  1417 00000C15 BE[23070000]        <1>     mov  esi,apicerrmsg
  1418 00000C1A E856000000          <1>     call irq_print_msg
  1419 00000C1F 5E                  <1>     pop  esi
  1420 00000C20 CF                  <1>     iret
  1421                              <1> 
  1422                              <1> ; serves only to eoi the fixed ipi used for sleep wakeup
  1423 00000C21 90<rept>            <1> align 4
  1424                              <1> wakeup :
  1425 00000C24 50                  <1>     push eax
  1426 00000C25 31C0                <1>     xor  eax,eax
  1427 00000C27 A3B000E0FE          <1>     mov  [0xfee000b0],eax    ; lapic eoi
  1428 00000C2C 58                  <1>     pop  eax
  1429 00000C2D CF                  <1>     iret
  1430                              <1> 
  1431                              <1> 
  1432 00000C2E 90<rept>            <1> align 4
  1433                              <1> ; %if ($ >= 0x8000) bomb
  1434                              <1> sysent :
  1435 00000C30 3D00020000          <1>     cmp  eax,0x0200
  1436 00000C35 0F84A9020000        <1>     jz   syscall_klog
  1437 00000C3B 3D00100000          <1>     cmp  eax,0x1000
  1438 00000C40 0F84AD020000        <1>     jz   syscall_ncpus
  1439 00000C46 3D00200000          <1>     cmp  eax,0x2000
  1440 00000C4B 0F8407030000        <1>     jz   syscall_sleep
  1441 00000C51 3D00210000          <1>     cmp  eax,0x2100
  1442 00000C56 0F849D020000        <1>     jz   syscall_new_thread
  1443 00000C5C 3D00270000          <1>     cmp  eax,0x2700
  1444 00000C61 0F8426030000        <1>     jz   syscall_request_pmem_access
  1445 00000C67 BE[34070000]        <1>     mov  esi,int255msg
  1446 00000C6C E804000000          <1>     call irq_print_msg
  1447 00000C71 31C0                <1>     xor  eax,eax
  1448 00000C73 48                  <1>     dec  eax
  1449 00000C74 CF                  <1>     iret
  1450                              <1> 
  1451                              <1> 
  1452                              <1> ; ---- IRQ support code ---- 
  1453                              <1> 
  1454                              <1> irq_print_msg :
  1455 00000C75 BBA0000000          <1>     mov  ebx,160            ; line 2
  1456 00000C7A A0[18030000]        <1>     mov  al,[enabled_lapic]
  1457 00000C7F 08C0                <1>     or   al,al
  1458 00000C81 741D                <1>     jz   skip_cpumsg
  1459                              <1> 
  1460 00000C83 56                  <1>     push esi
  1461 00000C84 BE[13050000]        <1>     mov  esi,cpumsg
  1462 00000C89 E870F7FFFF          <1>     call puts_vga
  1463 00000C8E A12000E0FE          <1>     mov  eax,[0xfee00020]   ; print our apic id
  1464 00000C93 C1E818              <1>     shr  eax,24
  1465 00000C96 83C030              <1>     add  eax,'0'
  1466 00000C99 658803              <1>     mov  [gs:ebx],al
  1467 00000C9C 83C304              <1>     add  ebx,4
  1468 00000C9F 5E                  <1>     pop  esi
  1469                              <1> 
  1470                              <1> skip_cpumsg :
  1471 00000CA0 E959F7FFFF          <1>     jmp  puts_vga
  1472                              <1> 
  1473                              <1> 
  1474                              <1> reboot_on_alt_key :
  1475 00000CA5 FA                  <1>     cli
  1476                              <1> reboot_on_alt_key_loop :
  1477 00000CA6 E460                <1>     in   al,0x60
  1478 00000CA8 3C38                <1>     cmp  al,'8'             ; part of the scan code for ALT
  1479 00000CAA 75FA                <1>     jnz  reboot_on_alt_key_loop
  1480                              <1> reboot :
  1481 00000CAC FA                  <1>     cli
  1482 00000CAD 0F011D[D90C0000]    <1>     lidt [reboot_idt]       ; restore boot idt (helps qemu ...)
  1483 00000CB4 EA[BB0C0000]2800    <1>     jmp  rmcssel:reboot_exit_pmode      ; thankyou hpa
  1484                              <1> reboot_exit_pmode :
  1485                              <1> bits 16
  1486 00000CBB B83000              <1>     mov  ax,rmdssel
  1487 00000CBE 8ED8                <1>     mov  ds,ax
  1488 00000CC0 8EC0                <1>     mov  es,ax
  1489 00000CC2 8ED0                <1>     mov  ss,ax
  1490 00000CC4 8EE0                <1>     mov  fs,ax
  1491 00000CC6 8EE8                <1>     mov  gs,ax
  1492                              <1> 
  1493 00000CC8 0F20C0              <1>     mov  eax,cr0
  1494 00000CCB 6625FEFFFF7F        <1>     and  eax,0x7ffffffe
  1495 00000CD1 0F22C0              <1>     mov  cr0,eax            ; disable pmode and paging
  1496 00000CD4 EA0000FFFF          <1>     jmp  0xffff:0           ; jump to the warm start vector and
  1497                              <1>                             ; flush the I prefetch queue all at once
  1498                              <1> 
  1499                              <1> reboot_idt :
  1500 00000CD9 FFFF                <1>     dw 0xffff
  1501 00000CDB 00000000            <1>     dd 0
  1502                              <1> 
  1503                              <1> 
  1504                              <1> ; ---- IDT initialization table ---- 
  1505                              <1> ;
  1506                              <1> ; One dw (2 bytes per vector) is used which means that all
  1507                              <1> ; int_handler entry points must reside below 0x10000!
  1508                              <1> ;
  1509                              <1> ; And since all int_handler routines are 4 byte aligned,
  1510                              <1> ; the bottom two bits are available to indicate type.
  1511                              <1> ; These bits index into the irq_types table below.
  1512                              <1> 
  1513 00000CDF 90                  <1> align 4
  1514                              <1> 
  1515                              <1> ; note: these are not gdt/ldt descriptors (see swdev3a 6.11 pg 228)
  1516                              <1> 
  1517 00000CE0 8E                  <1> irq_types   db  0x8e            ; dpl=0 32bit interrupt gate (sets IF flag)
  1518 00000CE1 EE                  <1>             db  0xee            ; dpl=3 32bit app (ring3) interrupt gate
  1519 00000CE2 85                  <1>             db  0x85            ; dpl=0 32bit task gate
  1520 00000CE3 8F                  <1>             db  0x8f            ; dpl=0 32bit trap gate (does not set IF flag)
  1521                              <1> 
  1522                              <1> ; all handlers/selectors are 4 byte aligned - this gives us
  1523                              <1> ; two bits to use to designate 1 of 4 types of idt descriptors ...
  1524                              <1> 
  1525                              <1> irqt_intr   equ 0
  1526                              <1> irqt_app    equ 1
  1527                              <1> irqt_task   equ 2
  1528                              <1> irqt_trap   equ 3
  1529                              <1> 
  1530                              <1> irq_setup_table:
  1531                              <1>     ; cpu defined
  1532 00000CE4 [1708]              <1>     dw  int_handler_div0      + irqt_trap ; 0
  1533 00000CE6 [2B08]              <1>     dw  int_handler_debug     + irqt_trap ; 1
  1534 00000CE8 [3C08]              <1>     dw  int_handler_nmi       + irqt_intr ; 2
  1535 00000CEA [5108]              <1>     dw  int_handler_brkp      + irqt_app  ; 3
  1536 00000CEC [6508]              <1>     dw  int_handler_ovrflw    + irqt_app  ; 4
  1537 00000CEE [7908]              <1>     dw  int_handler_bound     + irqt_app  ; 5
  1538 00000CF0 [8F08]              <1>     dw  int_handler_invop     + irqt_trap ; 6
  1539 00000CF2 [9F08]              <1>     dw  int_handler_devna     + irqt_trap ; 7
  1540 00000CF4 4200                <1>     dw  tasksel_f08           + irqt_task ; 8   double fault
  1541 00000CF6 [A308]              <1>     dw  int_handler_cpsego    + irqt_trap ; 9
  1542 00000CF8 4A00                <1>     dw  tasksel_f10           + irqt_task ; 10  invalid tss
  1543 00000CFA [B308]              <1>     dw  int_handler_segnp     + irqt_trap ; 11
  1544 00000CFC [C308]              <1>     dw  int_handler_stkflt    + irqt_trap ; 12
  1545 00000CFE [E708]              <1>     dw  int_handler_gpf       + irqt_trap ; 13
  1546 00000D00 [C809]              <1>     dw  int_handler_pgflt     + irqt_intr ; 14
  1547 00000D02 0000                <1>     dw  0                                 ; 15  Intel reserved
  1548 00000D04 [F309]              <1>     dw  int_handler_fpuerr    + irqt_trap ; 16
  1549 00000D06 [030A]              <1>     dw  int_handler_algnchk   + irqt_trap ; 17
  1550 00000D08 [170A]              <1>     dw  int_handler_machchk   + irqt_trap ; 18
  1551 00000D0A [2B0A]              <1>     dw  int_handler_simdfpe   + irqt_trap ; 19
  1552 00000D0C 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0
  1553 00000D15 000000000000000000- <1>
  1554 00000D1E 000000000000        <1>
  1555                              <1>     ; hw defined
  1556                              <1> apic0_irqbase equ ($ - irq_setup_table)/2
  1557 00000D24 [3C0A]              <1>     dw  int_handler_timer     + irqt_intr ; 32  0x20
  1558 00000D26 [880A]              <1>     dw  int_handler_kbd       + irqt_intr ; 33
  1559 00000D28 [BC0A]              <1>     dw  int_handler_hw02      + irqt_intr ; 34
  1560 00000D2A [D00A]              <1>     dw  int_handler_hw03      + irqt_intr ; 35
  1561 00000D2C [E40A]              <1>     dw  int_handler_hw04      + irqt_intr ; 36
  1562 00000D2E [F80A]              <1>     dw  int_handler_hw05      + irqt_intr ; 37
  1563 00000D30 [0C0B]              <1>     dw  int_handler_hw06      + irqt_intr ; 38
  1564 00000D32 [200B]              <1>     dw  int_handler_hw07      + irqt_intr ; 39
  1565                              <1> apic1_irqbase equ ($ - irq_setup_table)/2
  1566 00000D34 [340B]              <1>     dw  int_handler_hw08      + irqt_intr ; 40
  1567 00000D36 [480B]              <1>     dw  int_handler_hw09      + irqt_intr ; 41
  1568 00000D38 [5C0B]              <1>     dw  int_handler_hw10      + irqt_intr ; 42
  1569 00000D3A [700B]              <1>     dw  int_handler_hw11      + irqt_intr ; 43
  1570 00000D3C [840B]              <1>     dw  int_handler_hw12      + irqt_intr ; 44
  1571 00000D3E [980B]              <1>     dw  int_handler_hw13      + irqt_intr ; 45
  1572 00000D40 [AC0B]              <1>     dw  int_handler_hw14      + irqt_intr ; 46
  1573 00000D42 [C00B]              <1>     dw  int_handler_hw15      + irqt_intr ; 47  0x2f
  1574                              <1>     ; undefined - hw can expand here
  1575 00000D44 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x30
  1576 00000D4D 000000000000000000- <1>
  1577 00000D56 000000000000000000- <1>
  1578 00000D5F 0000000000          <1>
  1579 00000D64 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x40
  1580 00000D6D 000000000000000000- <1>
  1581 00000D76 000000000000000000- <1>
  1582 00000D7F 0000000000          <1>
  1583 00000D84 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x50
  1584 00000D8D 000000000000000000- <1>
  1585 00000D96 000000000000000000- <1>
  1586 00000D9F 0000000000          <1>
  1587 00000DA4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x60
  1588 00000DAD 000000000000000000- <1>
  1589 00000DB6 000000000000000000- <1>
  1590 00000DBF 0000000000          <1>
  1591 00000DC4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x70
  1592 00000DCD 000000000000000000- <1>
  1593 00000DD6 000000000000000000- <1>
  1594 00000DDF 0000000000          <1>
  1595 00000DE4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x80
  1596 00000DED 000000000000000000- <1>
  1597 00000DF6 000000000000000000- <1>
  1598 00000DFF 0000000000          <1>
  1599 00000E04 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0x90
  1600 00000E0D 000000000000000000- <1>
  1601 00000E16 000000000000000000- <1>
  1602 00000E1F 0000000000          <1>
  1603 00000E24 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xa0
  1604 00000E2D 000000000000000000- <1>
  1605 00000E36 000000000000000000- <1>
  1606 00000E3F 0000000000          <1>
  1607                              <1>     ; set up cpu thread management tss gates
  1608                              <1>     ; these map 1-to-1 to cpus
  1609                              <1> first_thread_tss_gate equ ($ - irq_setup_table)/2
  1610 00000E44 5A00                <1>     dw  tasksel_u00           + irqt_task
  1611 00000E46 6A00                <1>     dw  tasksel_u01           + irqt_task
  1612 00000E48 7A00                <1>     dw  tasksel_u02           + irqt_task
  1613 00000E4A 8A00                <1>     dw  tasksel_u03           + irqt_task
  1614 00000E4C 9A00                <1>     dw  tasksel_u04           + irqt_task
  1615 00000E4E AA00                <1>     dw  tasksel_u05           + irqt_task
  1616 00000E50 BA00                <1>     dw  tasksel_u06           + irqt_task
  1617 00000E52 CA00                <1>     dw  tasksel_u07           + irqt_task
  1618                              <1> %ifdef FOO
  1619                              <1>     dw  tasksel_u08           + irqt_task
  1620                              <1>     dw  tasksel_u09           + irqt_task
  1621                              <1>     dw  tasksel_u10           + irqt_task
  1622                              <1>     dw  tasksel_u11           + irqt_task
  1623                              <1>     dw  tasksel_u12           + irqt_task
  1624                              <1>     dw  tasksel_u13           + irqt_task
  1625                              <1>     dw  tasksel_u14           + irqt_task
  1626                              <1>     dw  tasksel_u15           + irqt_task
  1627                              <1> %endif
  1628 00000E54 000000000000000000- <1>     dw                  0,0,0,0,0,0,0,0   ; 0xb0
  1629 00000E5D 00000000000000      <1>
  1630 00000E64 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xc0
  1631 00000E6D 000000000000000000- <1>
  1632 00000E76 000000000000000000- <1>
  1633 00000E7F 0000000000          <1>
  1634 00000E84 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xd0
  1635 00000E8D 000000000000000000- <1>
  1636 00000E96 000000000000000000- <1>
  1637 00000E9F 0000000000          <1>
  1638 00000EA4 000000000000000000- <1>     dw  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 0xe0
  1639 00000EAD 000000000000000000- <1>
  1640 00000EB6 000000000000000000- <1>
  1641 00000EBF 0000000000          <1>
  1642                              <1> spurious_int equ ($ - irq_setup_table)/2
  1643 00000EC4 [040C]              <1>     dw  int_handler_spurious  + irqt_intr
  1644                              <1> apicerr_int equ ($ - irq_setup_table)/2
  1645 00000EC6 [150C]              <1>     dw  int_handler_apicerr   + irqt_app
  1646 00000EC8 000000000000000000- <1>     dw      0,0,0,0,0,0,0,0,0,0,0,0       ; 0xf0
  1647 00000ED1 000000000000000000- <1>
  1648 00000EDA 000000000000        <1>
  1649                              <1>     ; sw defined - expand down if needed
  1650                              <1> wakeup_int equ ($ - irq_setup_table)/2
  1651 00000EE0 [250C]              <1>     dw  wakeup                + irqt_app
  1652 00000EE2 [310C]              <1>     dw  sysent                + irqt_app  ; 256  0xff
  1653                              <1> irq_setup_table_size equ ($ - irq_setup_table)/2
  1654                              <1> 
  1655                                  
  1656                                  ; -------- system calls --------
  1657                                  %include "ozsys.asm"
  1658                              <1> ; OZ - A more utopian OS    x86-32 system calls
  1659                              <1> ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
  1660                              <1> ;
  1661                              <1> ; Copyright (C) 2015  Duane Voth
  1662                              <1> ;
  1663                              <1> ;   This program is free software: you can redistribute it and/or modify
  1664                              <1> ;   it under the terms of the GNU Affero General Public License as
  1665                              <1> ;   published by the Free Software Foundation, either version 3 of the
  1666                              <1> ;   License, or (at your option) any later version.
  1667                              <1> ;
  1668                              <1> ;   This program is distributed in the hope that it will be useful,
  1669                              <1> ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
  1670                              <1> ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1671                              <1> ;   GNU Affero General Public License for more details.
  1672                              <1> ;
  1673                              <1> ;   You should have received a copy of the GNU Affero General Public License
  1674                              <1> ;   along with this program. If not, see <http://www.gnu.org/licenses/agpl.html>
  1675                              <1> ;
  1676                              <1> ;
  1677                              <1> ; OZ System Calls  (for ozapps)
  1678                              <1> 
  1679                              <1> bits 32
  1680                              <1> 
  1681                              <1> ;------------------------------------------------------------------
  1682                              <1> ;   syscall_klog : place a message on the vga line reserved for klog  :D
  1683                              <1> ;
  1684                              <1> ;   entry:
  1685                              <1> ;       esi = message address
  1686                              <1> ;   exit:
  1687                              <1> 
  1688                              <1> syscall_klog :
  1689 00000EE4 60                  <1>     pusha
  1690 00000EE5 BB40010000          <1>     mov  ebx,2 * 160        ; line 3
  1691 00000EEA E80FF5FFFF          <1>     call puts_vga
  1692 00000EEF 61                  <1>     popa
  1693 00000EF0 31C0                <1>     xor  eax,eax
  1694 00000EF2 CF                  <1>     iret
  1695                              <1> 
  1696                              <1> ;------------------------------------------------------------------
  1697                              <1> ;   syscall_ncpus : get how many cpu threads are running
  1698                              <1> ;
  1699                              <1> ;   entry:
  1700                              <1> ;   exit:
  1701                              <1> ;       eax = N cpus
  1702                              <1> 
  1703                              <1> syscall_ncpus :
  1704 00000EF3 A1[14030000]        <1>     mov  eax,[ncpus]
  1705 00000EF8 CF                  <1>     iret
  1706                              <1> 
  1707                              <1> ;------------------------------------------------------------------
  1708                              <1> ;   syscall_new_thread : ask for another cpu to execute code in
  1709                              <1> ;                        the current app
  1710                              <1> ;
  1711                              <1> ;   This implementation is quite a bit of a hack - apps can basically
  1712                              <1> ;   commendere any specific non-boot cpu they want ...
  1713                              <1> ;
  1714                              <1> ;   entry:
  1715                              <1> ;       edx = function start address in the app
  1716                              <1> ;       ecx = address of the top of the app's new thread stack
  1717                              <1> ;       ebx = app's new thread index
  1718                              <1> ;   exit:
  1719                              <1> ;       eax = 0 success, -1 failure
  1720                              <1> 
  1721                              <1> syscall_new_thread :
  1722 00000EF9 09DB                <1>     or   ebx,ebx
  1723 00000EFB 7459                <1>     jz   new_thread_fail        ; don't get to ask for cpu 0
  1724                              <1> 
  1725 00000EFD 31C0                <1>     xor  eax,eax
  1726 00000EFF A0[18030000]        <1>     mov  al,[enabled_lapic]     ; if the lapics are not enabled,
  1727 00000F04 08C0                <1>     or   al,al                  ; none of this is useful
  1728 00000F06 744E                <1>     jz   new_thread_fail
  1729                              <1> 
  1730                              <1>     ; setup the tss
  1731                              <1>     ; slightly squirly - get the tss address from the task selector
  1732                              <1>     ; but there could be a race here: ncpus is updated before
  1733                              <1>     ; create_tss_pair is called, so the task selector could be zero!
  1734                              <1> 
  1735 00000F08 89DF                <1>     mov  edi,ebx
  1736 00000F0A C1E704              <1>     shl  edi,4                  ; 8 byte selectors in pairs
  1737 00000F0D 83C758              <1>     add  edi,tasksel_u00
  1738 00000F10 8BB7[02000000]      <1>     mov  esi,[gdt+edi+2]
  1739 00000F16 81E6FFFFFF00        <1>     and  esi,0xffffff
  1740 00000F1C 31C0                <1>     xor  eax,eax
  1741 00000F1E 8A87[07000000]      <1>     mov  al,[gdt+edi+7]
  1742 00000F24 C1E018              <1>     shl  eax,24
  1743 00000F27 09C6                <1>     or   esi,eax
  1744 00000F29 742B                <1>     jz   new_thread_fail        ; cpu isn't yet ready ...
  1745                              <1> 
  1746                              <1>     ; really should check the previous task link to see if this
  1747                              <1>     ; cpu is busy ...
  1748                              <1> 
  1749 00000F2B 894E38              <1>     mov  [esi+(tss0_esp-tss0)],ecx  ; set the app's stack
  1750 00000F2E 895620              <1>     mov  [esi+(tss0_eip-tss0)],edx  ; set the ip to the entry point
  1751                              <1> 
  1752                              <1>     ; lookup the requested cpu's int/taskgate gdt selector
  1753                              <1> 
  1754 00000F31 89DF                <1>     mov  edi,ebx
  1755 00000F33 81C7B0000000        <1>     add  edi,first_thread_tss_gate  ; convert ebx to int/taskgate number
  1756                              <1> 
  1757                              <1>     ; ipi a cpu.  no fancy affinity scheduling yet,
  1758                              <1>     ; just let the app ask for a specific cpu to do the work
  1759                              <1> 
  1760 00000F39 B800000001          <1>     mov  eax,0x01000000
  1761 00000F3E 89D9                <1>     mov  ecx,ebx                    ; recover requested cpu number
  1762 00000F40 D3E0                <1>     shl  eax,cl                     ; form the icr destination field
  1763                              <1> 
  1764                              <1>     ; poke the cpu that matches our thread index - we only get 8 :/
  1765                              <1> 
  1766 00000F42 A31003E0FE          <1>     mov  dword [0xfee00310],eax
  1767 00000F47 B800480000          <1>     mov  eax,0x4800                 ; no shorthand, fixed, logical, edge
  1768 00000F4C 09F8                <1>     or   eax,edi                    ; make int/taskgate number the vector
  1769 00000F4E A30003E0FE          <1>     mov  dword [0xfee00300],eax
  1770                              <1> 
  1771 00000F53 31C0                <1>     xor  eax,eax
  1772 00000F55 CF                  <1>     iret
  1773                              <1> 
  1774                              <1> new_thread_fail :
  1775 00000F56 48                  <1>     dec  eax                    ; -1
  1776 00000F57 C3                  <1>     ret
  1777                              <1> 
  1778                              <1> ;------------------------------------------------------------------
  1779                              <1> ;   syscall_sleep : wait for N timer interrupts
  1780                              <1> ;
  1781                              <1> ;   entry:
  1782                              <1> ;       edx = N ticks
  1783                              <1> ;   exit:
  1784                              <1> 
  1785                              <1> syscall_sleep :
  1786 00000F58 A0[18030000]        <1>     mov  al,[enabled_lapic]
  1787 00000F5D 08C0                <1>     or   al,al
  1788 00000F5F 7415                <1>     jz   sleep_loop
  1789                              <1> 
  1790 00000F61 A12000E0FE          <1>     mov  eax,[0xfee00020]
  1791 00000F66 C1E818              <1>     shr  eax,24
  1792 00000F69 09C0                <1>     or   eax,eax
  1793 00000F6B 7409                <1>     jz   sleep_loop         ; the boot cpu services the timer int
  1794 00000F6D 88C1                <1>     mov  cl,al              ; so don't add it to the sleeper list
  1795 00000F6F B801000000          <1>     mov  eax,1
  1796 00000F74 D3E0                <1>     shl  eax,cl
  1797                              <1> 
  1798                              <1> sleep_loop :
  1799 00000F76 F00905[1D030000]    <1>     lock or [sleepers],eax  ; announce we are sleeping
  1800 00000F7D FB                  <1>     sti
  1801 00000F7E F4                  <1>     hlt                     ; wait for an int to wake us up
  1802 00000F7F 4A                  <1>     dec  edx                ; decrement the tick count
  1803 00000F80 75F4                <1>     jnz  sleep_loop
  1804                              <1> 
  1805 00000F82 83F0FF              <1>     xor  eax,-1
  1806 00000F85 F02105[1D030000]    <1>     lock and [sleepers],eax ; renounce sleepiness
  1807 00000F8C CF                  <1>     iret
  1808                              <1> 
  1809                              <1> ;------------------------------------------------------------------
  1810                              <1> ;   syscall_request_pmem_access : ask for access to a physical
  1811                              <1> ;            memory address
  1812                              <1> ;
  1813                              <1> ;   entry:
  1814                              <1> ;       edx = phys memory address
  1815                              <1> ;
  1816                              <1> ;   exit:
  1817                              <1> ;       (need to return a logical address in eax)  For now just
  1818                              <1> ;       direct maps the physical address into logical addr space.
  1819                              <1> 
  1820                              <1> syscall_request_pmem_access :
  1821 00000F8D E801000000          <1>     call map_pmem
  1822 00000F92 CF                  <1>     iret
  1823                              <1> 
  1824                              <1> ;------------------------------------------------------------------
  1825                              <1> ;   map_pmem - add entries to the current page directory/table
  1826                              <1> ;              to direct map the requested physical memory address
  1827                              <1> ;              (logical identical to physical for now)
  1828                              <1> ;
  1829                              <1> ;   entry:
  1830                              <1> ;       edx = phys memory address
  1831                              <1> ;
  1832                              <1> ;   returns:
  1833                              <1> ;       (need to return a logical address in eax)  For now just
  1834                              <1> ;       direct maps the physical address into logical addr space.
  1835                              <1> ;       eax =  0 success
  1836                              <1> ;       eax = -1 fail
  1837                              <1> 
  1838                              <1> map_pmem :
  1839 00000F93 60                  <1>     pusha
  1840 00000F94 0F013A              <1>     invlpg [edx]
  1841 00000F97 52                  <1>     push edx
  1842 00000F98 0F20DB              <1>     mov  ebx,cr3
  1843 00000F9B 81E300F0FFFF        <1>     and  ebx,0xfffff000
  1844 00000FA1 89D7                <1>     mov  edi,edx
  1845 00000FA3 81E70000C0FF        <1>     and  edi,0xffc00000
  1846 00000FA9 C1EF14              <1>     shr  edi,(22 - 2)           ; calc page directory index
  1847 00000FAC 81E200F03F00        <1>     and  edx,0x003ff000
  1848 00000FB2 C1EA0A              <1>     shr  edx,(12 - 2)           ; calc page table index
  1849                              <1> 
  1850 00000FB5 8B043B              <1>     mov  eax,[ebx+edi]
  1851 00000FB8 09C0                <1>     or   eax,eax                ; is there a page table here?
  1852 00000FBA 750F                <1>     jnz  map_pmem_have_pgtbl
  1853 00000FBC E88FF4FFFF          <1>     call mem_alloc_kernel_page
  1854 00000FC1 09C0                <1>     or   eax,eax
  1855 00000FC3 741E                <1>     jz   map_pmem_fail
  1856 00000FC5 C1E00C              <1>     shl  eax,12                 ; convert pgno to pgtbl entry
  1857 00000FC8 89043B              <1>     mov  [ebx+edi],eax          ; update page table
  1858                              <1> 
  1859                              <1> map_pmem_have_pgtbl :
  1860                              <1>     ; for now, no security check, just direct map the address
  1861                              <1>     ; and mark the pages and the page table r/w by all
  1862 00000FCB 830C3B07            <1>     or   dword [ebx+edi],7      ; user, r/w, present
  1863                              <1> 
  1864 00000FCF 8B1C3B              <1>     mov  ebx,[ebx+edi]
  1865 00000FD2 81E300F0FFFF        <1>     and  ebx,0xfffff000
  1866 00000FD8 58                  <1>     pop  eax                    ; recover requested phys mem addr
  1867                              <1>     ; FIXME yup, big security hole if called by ring 0! And it is ...
  1868 00000FD9 83C807              <1>     or   eax,7                  ; user, r/w, present
  1869 00000FDC 890413              <1>     mov  [ebx+edx],eax          ; update page directory
  1870 00000FDF 61                  <1>     popa
  1871 00000FE0 31C0                <1>     xor  eax,eax                ; 0
  1872 00000FE2 C3                  <1>     ret
  1873                              <1> 
  1874                              <1> map_pmem_fail :
  1875 00000FE3 48                  <1>     dec  eax                    ; -1
  1876 00000FE4 C3                  <1>     ret
  1877                              <1> 
  1878                                  
  1879 00000FE5 00<rept>                align 16, db 0
  1880                                  kernel_text_size equ ($-textstart)
  1881                                  
  1882                                  ; ---------------------------------------------------------------------------
  1883                                  section .data
  1884                                  datastart :
  1885                                  
  1886                                  ; -------- descriptors --------------
  1887                                  ; Intel SW dev manual 3a, 3.4.5, pg 103
  1888                                  ;
  1889                                  ; In my opinion, macros for descriptor entries
  1890                                  ; don't make the code that much more readable.
  1891                                  
  1892                                  gdt :
  1893                                  nullsel equ $-gdt           ; nullsel = 0h
  1894 00000000 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
  1895                                  
  1896                                  codesel equ $-gdt           ; codesel = 8h  4Gb flat over all logical mem
  1897 00000008 FFFF                        dw 0xffff               ; limit 0-15
  1898 0000000A 0000                        dw 0x0000               ; base  0-15
  1899 0000000C 00                          db 0x00                 ; base 16-23
  1900 0000000D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  1901 0000000E CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  1902 0000000F 00                          db 0x00                 ; base 24-31
  1903                                  
  1904                                  datasel equ $-gdt           ; datasel = 10h  4Gb flat over all logical mem
  1905 00000010 FFFF                        dw 0xffff               ; limit 0-15
  1906 00000012 0000                        dw 0x0000               ; base  0-15
  1907 00000014 00                          db 0x00                 ; base 16-23
  1908 00000015 92                          db 0x92                 ; present, dpl=0, data r/w
  1909 00000016 CF                          db 0xcf                 ; 4k granular, 32bit/8bit, limit 16-19
  1910 00000017 00                          db 0x00                 ; base 24-31
  1911                                  
  1912                                  stacksel equ $-gdt          ; stacksel = 18h  small limited stack
  1913 00000018 FF1F                        dw kstack_size-1        ; limit
  1914 0000001A 0010                        dw kstack_loc           ; base
  1915 0000001C 00                          db 0
  1916 0000001D 92                          db 0x92                 ; present, dpl=0, data, r/w
  1917 0000001E 40                          db 0x40                 ; byte granular, 32bit/8bit
  1918 0000001F 00                          db 0
  1919                                  
  1920                                  videosel equ $-gdt          ; videosel = 20h
  1921 00000020 9F0F                        dw 3999                 ; limit 80*25*2-1
  1922 00000022 0080                        dw 0x8000               ; base 0xb8000
  1923 00000024 0B                          db 0x0b
  1924 00000025 92                          db 0x92                 ; present, dpl=0, data, r/w
  1925 00000026 40                          db 0x40                 ; byte granular, 32bit/8bit
  1926 00000027 00                          db 0
  1927                                  
  1928                                  rmcssel equ $-gdt           ; real mode CS selector = 28h
  1929 00000028 FFFF                        dw 0x0ffff              ; limit 0-15
  1930 0000002A 0000                        dw 0x0000               ; base  0-15
  1931 0000002C 00                          db 0x00                 ; base 16-23
  1932 0000002D 9A                          db 0x9a                 ; present, dpl=0, code e/r
  1933 0000002E 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  1934 0000002F 00                          db 0x00                 ; base 24-31
  1935                                  
  1936                                  rmdssel equ $-gdt           ; real mode DS selector = 30h
  1937 00000030 FFFF                        dw 0x0ffff              ; limit 0-15
  1938 00000032 0000                        dw 0x0000               ; base  0-15
  1939 00000034 00                          db 0x00                 ; base 16-23
  1940 00000035 92                          db 0x92                 ; present, dpl=0, data r/w
  1941 00000036 0F                          db 0x0f                 ; byte granular, 16bit, limit 16-19
  1942 00000037 00                          db 0x00                 ; base 24-31
  1943                                  
  1944                                  ldtsel1 equ $-gdt
  1945 00000038 1800                        dw ldt1_len             ; length of the ldt
  1946 0000003A [5001]                      dw ldt1                 ; address of the ldt
  1947 0000003C 00                          db 0
  1948 0000003D 82                          db 0x82                 ; present, dpl=0, ldt
  1949 0000003E 40                          db 0x40                 ; byte granular, 32bit/8bit
  1950 0000003F 00                          db 0
  1951                                  
  1952                                  tasksel_f08 equ $-gdt       ; the double fault task selector
  1953 00000040 6800                        dw tss_len              ; tss length
  1954 00000042 [6801]                      dw tss_f08              ; tss physical address
  1955 00000044 00                          db 0
  1956 00000045 89                          db 0x89                 ; present, dpl=0, tss32
  1957 00000046 40                          db 0x40                 ; byte granular, 32bit/8bit
  1958 00000047 00                          db 0
  1959                                  
  1960                                  tasksel_f10 equ $-gdt       ; the invalid tss task selector
  1961 00000048 6800                        dw tss_len              ; tss length
  1962 0000004A [D001]                      dw tss_f10              ; tss physical address
  1963 0000004C 00                          db 0
  1964 0000004D 89                          db 0x89                 ; present, dpl=0, tss32
  1965 0000004E 40                          db 0x40                 ; byte granular, 32bit/8bit
  1966 0000004F 00                          db 0
  1967                                  
  1968                                  ; there is one kernel thread tss (ring 0) and one user thread tss (ring 1)
  1969                                  ; per cpu.  memory for tss structs for the non-boot cpus are allocated as
  1970                                  ; each non-boot cpu comes online (see create_tss_pair).  tasksel_uXX tss
  1971                                  ; gates are installed in the idt (starting at first_thread_tss_gate),
  1972                                  ; they also map 1-to-1 with cpus.  (the thread is launched via an lapic
  1973                                  ; vectored interrupt that jumps immediately into user space - and to call a
  1974                                  ; task gate from an interrupt requires an existing ring 0 tss to be active)
  1975                                  ; tasksel_uXX tsses are initialized in new_thread.
  1976                                  
  1977                                  tasksel_k00 equ $-gdt
  1978 00000050 6800[3802]00894000                              dw tss_len, tss0, 0x8900, 0x40
  1979                                  tasksel_u00 equ $-gdt
  1980 00000058 6800[A002]00894000                              dw tss_len, tss1, 0x8900, 0x40
  1981                                  tasksel_k01 equ $-gdt
  1982 00000060 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1983                                  tasksel_u01 equ $-gdt
  1984 00000068 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1985                                  tasksel_k02 equ $-gdt
  1986 00000070 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1987                                  tasksel_u02 equ $-gdt
  1988 00000078 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1989                                  tasksel_k03 equ $-gdt
  1990 00000080 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1991                                  tasksel_u03 equ $-gdt
  1992 00000088 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1993                                  tasksel_k04 equ $-gdt
  1994 00000090 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1995                                  tasksel_u04 equ $-gdt
  1996 00000098 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1997                                  tasksel_k05 equ $-gdt
  1998 000000A0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  1999                                  tasksel_u05 equ $-gdt
  2000 000000A8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2001                                  tasksel_k06 equ $-gdt
  2002 000000B0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2003                                  tasksel_u06 equ $-gdt
  2004 000000B8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2005                                  tasksel_k07 equ $-gdt
  2006 000000C0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2007                                  tasksel_u07 equ $-gdt
  2008 000000C8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2009                                  tasksel_k08 equ $-gdt
  2010 000000D0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2011                                  tasksel_u08 equ $-gdt
  2012 000000D8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2013                                  tasksel_k09 equ $-gdt
  2014 000000E0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2015                                  tasksel_u09 equ $-gdt
  2016 000000E8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2017                                  tasksel_k10 equ $-gdt
  2018 000000F0 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2019                                  tasksel_u10 equ $-gdt
  2020 000000F8 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2021                                  tasksel_k11 equ $-gdt
  2022 00000100 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2023                                  tasksel_u11 equ $-gdt
  2024 00000108 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2025                                  tasksel_k12 equ $-gdt
  2026 00000110 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2027                                  tasksel_u12 equ $-gdt
  2028 00000118 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2029                                  tasksel_k13 equ $-gdt
  2030 00000120 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2031                                  tasksel_u13 equ $-gdt
  2032 00000128 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2033                                  tasksel_k14 equ $-gdt
  2034 00000130 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2035                                  tasksel_u14 equ $-gdt
  2036 00000138 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2037                                  tasksel_k15 equ $-gdt
  2038 00000140 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2039                                  tasksel_u15 equ $-gdt
  2040 00000148 6800000000894000                                dw tss_len, 0, 0x8900, 0x40
  2041                                  gdt_end :
  2042                                  
  2043                                  ; ---------------------
  2044                                  
  2045                                  ldt1 :
  2046                                  nullsel1 equ $-ldt1         ; nullsel1 = 07h
  2047 00000150 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
  2048                                  
  2049                                  codesel1 equ $-ldt1         ; codesel1 = 0fh  4Gb flat over all logical mem
  2050 00000158 FFFF                        dw 0xffff               ; limit 0-15
  2051 0000015A 0000                        dw 0x0000               ; base  0-15
  2052 0000015C 00                          db 0x00                 ; base 16-23
  2053 0000015D FA                          db 0xfa                 ; present, dpl=3, code e/r
  2054 0000015E CF                          db 0xcf                 ; 4k granular, 32bit, limit 16-19
  2055 0000015F 00                          db 0x00                 ; base 24-31
  2056                                  
  2057                                  datasel1 equ $-ldt1         ; datasel1 = 17h  4Gb flat over all logical mem
  2058 00000160 FFFF                        dw 0xffff               ; limit 0-15
  2059 00000162 0000                        dw 0x0000               ; base  0-15
  2060 00000164 00                          db 0x00                 ; base 16-23
  2061 00000165 F2                          db 0xf2                 ; present, dpl=3, data r/w
  2062 00000166 CF                          db 0xcf                 ; 4k granular, 32bit, limit 16-19
  2063 00000167 00                          db 0x00                 ; base 24-31
  2064                                  
  2065                                  ; gcc wants the ds, es, and ss segment registers to match
  2066                                  ;stacksel1 equ $-ldt1        ; stacksel = 1ch  small limited stack
  2067                                  ;    dw 0xffff               ; limit
  2068                                  ;    dw 0x0000               ; base  0-15
  2069                                  ;    db 0x00
  2070                                  ;    db 0xf2                 ; present, dpl=3, data, r/w
  2071                                  ;    db 0                    ; byte granular, 16 bit
  2072                                  ;    db 0
  2073                                  
  2074                                  ldt1_end :
  2075                                  
  2076                                  ldt1_len equ ldt1_end-ldt1
  2077                                  
  2078                                  ; ---------------------
  2079                                  ; the tss that handles double fault exceptions
  2080                                  
  2081                                  tss_f08 :                   ; intel sw 3a 7.6  pg 287 of 756
  2082 00000168 00000000                    dw 0,0                  ; previous task link
  2083 0000016C 00000000                    dd 0                    ; esp0
  2084 00000170 00000000                    dw 0,0                  ; ss0
  2085 00000174 00000000                    dd 0                    ; esp1
  2086 00000178 00000000                    dw 0,0                  ; ss1
  2087 0000017C 00000000                    dd 0                    ; esp2
  2088 00000180 00000000                    dw 0,0                  ; ss2
  2089 00000184 00300000                    dd pgdir                ; cr3
  2090 00000188 [D40B0000]                  dd int_handler_tg_dblflt ; eip
  2091 0000018C 00000000                    dd 0                    ; eflags
  2092 00000190 00000000                    dd 0                    ; eax
  2093 00000194 00000000                    dd 0                    ; ecx
  2094 00000198 00000000                    dd 0                    ; edx
  2095 0000019C 00000000                    dd 0                    ; ebx
  2096 000001A0 00080000                    dd kstack_size/4        ; esp
  2097 000001A4 00000000                    dd 0                    ; ebp
  2098 000001A8 00000000                    dd 0                    ; esi
  2099 000001AC 00000000                    dd 0                    ; edi
  2100 000001B0 10000000                    dw datasel,0            ; es
  2101 000001B4 08000000                    dw codesel,0            ; cs
  2102 000001B8 10000000                    dw datasel,0            ; ss
  2103 000001BC 10000000                    dw datasel,0            ; ds
  2104 000001C0 00000000                    dw 0,0                  ; fs
  2105 000001C4 20000000                    dw videosel,0           ; gs
  2106 000001C8 00000000                    dw 0,0                  ; ldt
  2107 000001CC 0000                        dw 0                    ; trap
  2108 000001CE 0000                        dw 0                    ; iomap
  2109                                  
  2110                                  ; ---------------------
  2111                                  ; the tss that handles invalid tss exceptions
  2112                                  
  2113                                  tss_f10 :                   ; intel sw 3a 7.6  pg 287 of 756
  2114 000001D0 00000000                    dw 0,0                  ; previous task link
  2115 000001D4 00000000                    dd 0                    ; esp0
  2116 000001D8 00000000                    dw 0,0                  ; ss0
  2117 000001DC 00000000                    dd 0                    ; esp1
  2118 000001E0 00000000                    dw 0,0                  ; ss1
  2119 000001E4 00000000                    dd 0                    ; esp2
  2120 000001E8 00000000                    dw 0,0                  ; ss2
  2121 000001EC 00300000                    dd pgdir                ; cr3
  2122 000001F0 [E80B0000]                  dd int_handler_tg_invtss ; eip
  2123 000001F4 00000000                    dd 0                    ; eflags
  2124 000001F8 00000000                    dd 0                    ; eax
  2125 000001FC 00000000                    dd 0                    ; ecx
  2126 00000200 00000000                    dd 0                    ; edx
  2127 00000204 00000000                    dd 0                    ; ebx
  2128 00000208 00100000                    dd kstack_size/2        ; esp
  2129 0000020C 00000000                    dd 0                    ; ebp
  2130 00000210 00000000                    dd 0                    ; esi
  2131 00000214 00000000                    dd 0                    ; edi
  2132 00000218 10000000                    dw datasel,0            ; es
  2133 0000021C 08000000                    dw codesel,0            ; cs
  2134 00000220 10000000                    dw datasel,0            ; ss
  2135 00000224 10000000                    dw datasel,0            ; ds
  2136 00000228 00000000                    dw 0,0                  ; fs
  2137 0000022C 20000000                    dw videosel,0           ; gs
  2138 00000230 00000000                    dw 0,0                  ; ldt
  2139 00000234 0000                        dw 0                    ; trap
  2140 00000236 0000                        dw 0                    ; iomap
  2141                                  
  2142                                  ; ---------------------
  2143                                  ; tss0 and tss1 are cpu0's pair, these are also templates for other
  2144                                  ; cpus that come online.
  2145                                  
  2146                                  tss0 :                      ; intel swdev3a 7.6  pg 287 of 756
  2147 00000238 00000000                    dw 0,0                  ; previous task link
  2148                                  tss0_esp0 :
  2149 0000023C 00000000                    dd 0                    ; esp0
  2150                                  tss0_ss0 :
  2151 00000240 00000000                    dw 0,0                  ; ss0
  2152 00000244 00000000                    dd 0                    ; esp1
  2153 00000248 00000000                    dw 0,0                  ; ss1
  2154 0000024C 00000000                    dd 0                    ; esp2
  2155 00000250 00000000                    dw 0,0                  ; ss2
  2156                                  tss0_cr3 :
  2157 00000254 00300000                    dd pgdir                ; cr3
  2158                                  tss0_eip :
  2159 00000258 00000000                    dd 0                    ; eip
  2160 0000025C 00000000                    dd 0                    ; eflags
  2161                                  tss0_eax :
  2162 00000260 00000000                    dd 0                    ; eax
  2163 00000264 00000000                    dd 0                    ; ecx
  2164 00000268 00000000                    dd 0                    ; edx
  2165 0000026C 00000000                    dd 0                    ; ebx
  2166                                  tss0_esp :
  2167 00000270 00000000                    dd 0                    ; esp
  2168 00000274 00000000                    dd 0                    ; ebp
  2169 00000278 00000000                    dd 0                    ; esi
  2170 0000027C 00000000                    dd 0                    ; edi
  2171                                  tss0_es :
  2172 00000280 00000000                    dw 0,0                  ; es
  2173                                  tss0_cs :
  2174 00000284 00000000                    dw 0,0                  ; cs
  2175                                  tss0_ss :
  2176 00000288 00000000                    dw 0,0                  ; ss
  2177                                  tss0_ds :
  2178 0000028C 00000000                    dw 0,0                  ; ds
  2179 00000290 00000000                    dw 0,0                  ; fs
  2180 00000294 20000000                    dw videosel,0           ; gs
  2181                                  tss0_ldt :
  2182 00000298 00000000                    dw 0,0                  ; ldt
  2183 0000029C 0000                        dw 0                    ; trap
  2184 0000029E 0000                        dw 0                    ; iomap
  2185                                  tss0_end :
  2186                                  
  2187                                  tss_len equ tss0_end-tss0
  2188                                  
  2189                                  ; user tss
  2190                                  
  2191                                  tss1 :                      ; intel sw 3a 7.6  pg 287 of 756
  2192 000002A0 00000000                    dw 0,0                  ; previous task link
  2193 000002A4 E01F0000                    dd kstack_size-32       ; esp0  (int and irq support)
  2194 000002A8 10000000                    dw datasel,0            ; ss0   (-32 leaves some stack space for main)
  2195 000002AC 00000000                    dd 0                    ; esp1
  2196 000002B0 00000000                    dw 0,0                  ; ss1
  2197 000002B4 00000000                    dd 0                    ; esp2
  2198 000002B8 00000000                    dw 0,0                  ; ss2
  2199 000002BC 00300000                    dd pgdir                ; cr3
  2200                                  tss1_eip :
  2201 000002C0 00000000                    dd 0                    ; eip
  2202 000002C4 00000000                    dd 0                    ; eflags
  2203 000002C8 00000000                    dd 0                    ; eax
  2204 000002CC 00000000                    dd 0                    ; ecx
  2205 000002D0 00000000                    dd 0                    ; edx
  2206 000002D4 00000000                    dd 0                    ; ebx
  2207 000002D8 00000000                    dd 0                    ; esp
  2208 000002DC 00000000                    dd 0                    ; ebp
  2209 000002E0 00000000                    dd 0                    ; esi
  2210 000002E4 00000000                    dd 0                    ; edi
  2211 000002E8 17000000                    dw datasel1+7,0         ; es
  2212 000002EC 0F000000                    dw codesel1+7,0         ; cs
  2213 000002F0 17000000                    dw datasel1+7,0         ; ss
  2214 000002F4 17000000                    dw datasel1+7,0         ; ds
  2215 000002F8 00000000                    dw 0,0                  ; fs
  2216 000002FC 00000000                    dw 0,0                  ; gs
  2217 00000300 3B000000                    dw ldtsel1+3,0          ; ldt
  2218 00000304 0000                        dw 0                    ; trap
  2219 00000306 0000                        dw 0                    ; iomap
  2220                                  
  2221                                  ; ---------------------
  2222                                  
  2223                                  gdtr :
  2224 00000308 4F01                        dw gdt_end - gdt - 1    ; gdt length
  2225 0000030A [00000000]                  dd gdt                  ; gdt physical address
  2226                                  
  2227                                  idtr :
  2228                                      ; irq_setup_table_size == the number of gates in the idt
  2229 0000030E FF07                        dw irq_setup_table_size * 8 - 1     ; idt limit (should be 2k)
  2230 00000310 00700000                    dd idt                              ; address of the idt
  2231                                  
  2232 00000314 00000000                ncpus           dd 0        ; number of running cpus
  2233                                  
  2234 00000318 00                      enabled_lapic   db 0        ; set to 1 if an lapic is present and in use
  2235                                  
  2236 00000319 00000000                next_free_page  dd 0        ; initialized after page tables are setup
  2237                                  
  2238 0000031D 0000000000000000        sleepers        dq 0        ; one bit per cpu
  2239                                  
  2240 00000325 00<rept>                align 16, db 0
  2241                                  kernel_data_size equ ($-datastart)
  2242                                  
  2243                                  
  2244                                  ; ---------------------
  2245                                  ; Need to align to a physical page boundary here so that appended init apps
  2246                                  ; are always page aligned.  The problem is our text section starts 1k below
  2247                                  ; a page boundary, and so an 'align 4096' doesn't match up with physical
  2248                                  ; memory.
  2249                                  
  2250                                  ; Add larger tests here if the times expression turns up negative, to make
  2251                                  ; the kernel image size right, but your next problem will be that the boot
  2252                                  ; loader will likely refuse to load all these sectors in one pass.
  2253                                  
  2254                                  section .fill
  2255                                  
  2256                                  fill :
  2257                                  
  2258                                  %if total_size > 4096+1024
  2259                                      times (4096+4096+1024-total_size) db 0
  2260                                  %elif total_size > 1024
  2261 00000000 00<rept>                    times (4096+1024-total_size) db 0
  2262                                  %endif
  2263                                  
  2264                                  kend :
  2265                                  
