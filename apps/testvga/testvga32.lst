
testvga32.o:     file format elf32-i386


Disassembly of section .text:

00000000 <syscall3>:

#include "types.h"

long
syscall3(int op, unsigned int arg1, unsigned int arg2, unsigned int arg3)
{
   0:	55                   	push   ebp
   1:	89 e5                	mov    ebp,esp
   3:	57                   	push   edi
   4:	56                   	push   esi
   5:	53                   	push   ebx
   6:	83 ec 10             	sub    esp,0x10
    long ret;
    asm volatile(
   9:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
   c:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
   f:	8b 4d 10             	mov    ecx,DWORD PTR [ebp+0x10]
  12:	8b 5d 14             	mov    ebx,DWORD PTR [ebp+0x14]
  15:	cd ff                	int    0xff
  17:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
        "int $0xff"
        : "=a" (ret)
        : "0" (op), "d" (arg1), "c" (arg2), "b" (arg3)
        : "cc", "edi", "esi", "memory");
    return ret;
  1a:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
}
  1d:	83 c4 10             	add    esp,0x10
  20:	5b                   	pop    ebx
  21:	5e                   	pop    esi
  22:	5f                   	pop    edi
  23:	5d                   	pop    ebp
  24:	c3                   	ret    

00000025 <syscall2>:

long
syscall2(int op, unsigned int arg1, unsigned int arg2)
{
  25:	55                   	push   ebp
  26:	89 e5                	mov    ebp,esp
  28:	57                   	push   edi
  29:	56                   	push   esi
  2a:	53                   	push   ebx
  2b:	83 ec 10             	sub    esp,0x10
    long ret;
    asm volatile(
  2e:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  31:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
  34:	8b 4d 10             	mov    ecx,DWORD PTR [ebp+0x10]
  37:	cd ff                	int    0xff
  39:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
        "int $0xff"
        : "=a" (ret)
        : "0" (op), "d" (arg1), "c" (arg2)
        : "cc", "ebx", "edi", "esi", "memory");
    return ret;
  3c:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
}
  3f:	83 c4 10             	add    esp,0x10
  42:	5b                   	pop    ebx
  43:	5e                   	pop    esi
  44:	5f                   	pop    edi
  45:	5d                   	pop    ebp
  46:	c3                   	ret    

00000047 <syscall1>:

long
syscall1(int op, unsigned int arg1)
{
  47:	55                   	push   ebp
  48:	89 e5                	mov    ebp,esp
  4a:	57                   	push   edi
  4b:	56                   	push   esi
  4c:	53                   	push   ebx
  4d:	83 ec 10             	sub    esp,0x10
    long ret;
    asm volatile(
  50:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  53:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
  56:	cd ff                	int    0xff
  58:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
        "int $0xff"
        : "=a" (ret)
        : "0" (op), "d" (arg1)
        : "cc", "ebx", "edi", "esi", "memory");
    return ret;
  5b:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
}
  5e:	83 c4 10             	add    esp,0x10
  61:	5b                   	pop    ebx
  62:	5e                   	pop    esi
  63:	5f                   	pop    edi
  64:	5d                   	pop    ebp
  65:	c3                   	ret    

00000066 <syscall0>:

long
syscall0(int op)
{
  66:	55                   	push   ebp
  67:	89 e5                	mov    ebp,esp
  69:	57                   	push   edi
  6a:	56                   	push   esi
  6b:	53                   	push   ebx
  6c:	83 ec 10             	sub    esp,0x10
    long ret;
    asm volatile(
  6f:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  72:	cd ff                	int    0xff
  74:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
        "int $0xff"
        : "=a" (ret)
        : "0" (op)
        : "cc", "ebx", "edi", "esi", "memory");
    return ret;
  77:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
}
  7a:	83 c4 10             	add    esp,0x10
  7d:	5b                   	pop    ebx
  7e:	5e                   	pop    esi
  7f:	5f                   	pop    edi
  80:	5d                   	pop    ebp
  81:	c3                   	ret    

00000082 <sleep>:

void
sleep(int ticks)
{
  82:	55                   	push   ebp
  83:	89 e5                	mov    ebp,esp
    //  0x2000 = wait for n timer interrupts
    syscall1(0x2000, ticks);
  85:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  88:	50                   	push   eax
  89:	68 00 20 00 00       	push   0x2000
  8e:	e8 fc ff ff ff       	call   8f <sleep+0xd>
  93:	83 c4 08             	add    esp,0x8
}
  96:	90                   	nop
  97:	c9                   	leave  
  98:	c3                   	ret    

00000099 <pause>:

void
pause(void)
{
  99:	55                   	push   ebp
  9a:	89 e5                	mov    ebp,esp
    //  0x2001 pause : wait for an ipi
    syscall0(0x2001);
  9c:	68 01 20 00 00       	push   0x2001
  a1:	e8 fc ff ff ff       	call   a2 <pause+0x9>
  a6:	83 c4 04             	add    esp,0x4
}
  a9:	90                   	nop
  aa:	c9                   	leave  
  ab:	c3                   	ret    

000000ac <resume>:

void
resume(void)
{
  ac:	55                   	push   ebp
  ad:	89 e5                	mov    ebp,esp
    //  0x2002 = resume all cores via ipi
    syscall0(0x2002);
  af:	68 02 20 00 00       	push   0x2002
  b4:	e8 fc ff ff ff       	call   b5 <resume+0x9>
  b9:	83 c4 04             	add    esp,0x4
}
  bc:	90                   	nop
  bd:	c9                   	leave  
  be:	c3                   	ret    

000000bf <start_threads>:

void
start_threads(void)
{
  bf:	55                   	push   ebp
  c0:	89 e5                	mov    ebp,esp
    //  0x2003 = ipi all cores
    syscall0(0x2003);
  c2:	68 03 20 00 00       	push   0x2003
  c7:	e8 fc ff ff ff       	call   c8 <start_threads+0x9>
  cc:	83 c4 04             	add    esp,0x4
}
  cf:	90                   	nop
  d0:	c9                   	leave  
  d1:	c3                   	ret    

000000d2 <new_thread>:
// disrupting the app's 8k footprint)
unsigned char stack[MAX_THREADS][STACK_SIZE] = {1};

int
new_thread(void (* func)(int), int thno)
{
  d2:	55                   	push   ebp
  d3:	89 e5                	mov    ebp,esp
  d5:	83 ec 10             	sub    esp,0x10
    unsigned char * stackend = stack[MAX_THREADS - thno];
  d8:	b8 20 00 00 00       	mov    eax,0x20
  dd:	2b 45 0c             	sub    eax,DWORD PTR [ebp+0xc]
  e0:	c1 e0 08             	shl    eax,0x8
  e3:	05 00 00 00 00       	add    eax,0x0
  e8:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax

    if (thno == 0)
  eb:	83 7d 0c 00          	cmp    DWORD PTR [ebp+0xc],0x0
  ef:	75 07                	jne    f8 <new_thread+0x26>
        return -1;
  f1:	b8 ff ff ff ff       	mov    eax,0xffffffff
  f6:	eb 29                	jmp    121 <new_thread+0x4f>

    // push thno onto the new thread's stack
    stackend -= sizeof(thno);
  f8:	83 6d fc 04          	sub    DWORD PTR [ebp-0x4],0x4
    *((int *)stackend) = thno;
  fc:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
  ff:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 102:	89 10                	mov    DWORD PTR [eax],edx
    stackend -= sizeof(void *);     // account for a return ip
 104:	83 6d fc 04          	sub    DWORD PTR [ebp-0x4],0x4

    //    0x2100 = new thread
    //      func = function address
    //  stackend = address of the end of a thread specific stack
    //      thno = thread number
    return syscall3(0x2100, (unsigned int)func, (unsigned int)stackend, thno);
 108:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
 10b:	8b 55 fc             	mov    edx,DWORD PTR [ebp-0x4]
 10e:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 111:	51                   	push   ecx
 112:	52                   	push   edx
 113:	50                   	push   eax
 114:	68 00 21 00 00       	push   0x2100
 119:	e8 fc ff ff ff       	call   11a <new_thread+0x48>
 11e:	83 c4 10             	add    esp,0x10
}
 121:	c9                   	leave  
 122:	c3                   	ret    

00000123 <map_vga_memory>:

#define VIDEORAM    ((short *)0xb8000)

void
map_vga_memory()
{
 123:	55                   	push   ebp
 124:	89 e5                	mov    ebp,esp
    //   0x2700 = request mem access
    // videoram = base physical address
    //   0x2000 = length in bytes
    syscall2(0x2700, (unsigned int)VIDEORAM, 0x2000);
 126:	68 00 20 00 00       	push   0x2000
 12b:	68 00 80 0b 00       	push   0xb8000
 130:	68 00 27 00 00       	push   0x2700
 135:	e8 fc ff ff ff       	call   136 <map_vga_memory+0x13>
 13a:	83 c4 0c             	add    esp,0xc
}
 13d:	90                   	nop
 13e:	c9                   	leave  
 13f:	c3                   	ret    

00000140 <pokech>:
#define YELLOW  14
#define WHITE   15

void
pokech(int row, int column, int ch, int color)
{
 140:	55                   	push   ebp
 141:	89 e5                	mov    ebp,esp
 143:	53                   	push   ebx
    VIDEORAM[WIDTH * (TOPLINE + row) + column] = (color << 8) | ch;
 144:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 147:	c1 e0 08             	shl    eax,0x8
 14a:	89 c3                	mov    ebx,eax
 14c:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 14f:	89 c1                	mov    ecx,eax
 151:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 154:	8d 50 06             	lea    edx,[eax+0x6]
 157:	89 d0                	mov    eax,edx
 159:	c1 e0 02             	shl    eax,0x2
 15c:	01 d0                	add    eax,edx
 15e:	c1 e0 04             	shl    eax,0x4
 161:	89 c2                	mov    edx,eax
 163:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 166:	01 d0                	add    eax,edx
 168:	01 c0                	add    eax,eax
 16a:	05 00 80 0b 00       	add    eax,0xb8000
 16f:	09 cb                	or     ebx,ecx
 171:	89 da                	mov    edx,ebx
 173:	66 89 10             	mov    WORD PTR [eax],dx
    //__sync_synchronize();
    //asm volatile ("sfence" ::: "memory");
}
 176:	90                   	nop
 177:	5b                   	pop    ebx
 178:	5d                   	pop    ebp
 179:	c3                   	ret    

0000017a <peekch>:

int
peekch(int row, int column)
{
 17a:	55                   	push   ebp
 17b:	89 e5                	mov    ebp,esp
    return VIDEORAM[WIDTH * (TOPLINE + row) + column];
 17d:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 180:	8d 50 06             	lea    edx,[eax+0x6]
 183:	89 d0                	mov    eax,edx
 185:	c1 e0 02             	shl    eax,0x2
 188:	01 d0                	add    eax,edx
 18a:	c1 e0 04             	shl    eax,0x4
 18d:	89 c2                	mov    edx,eax
 18f:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 192:	01 d0                	add    eax,edx
 194:	01 c0                	add    eax,eax
 196:	05 00 80 0b 00       	add    eax,0xb8000
 19b:	0f b7 00             	movzx  eax,WORD PTR [eax]
 19e:	98                   	cwde   
}
 19f:	5d                   	pop    ebp
 1a0:	c3                   	ret    

000001a1 <pokehstr>:

void
pokehstr(int row, int column, const char * str, int color)
{
 1a1:	55                   	push   ebp
 1a2:	89 e5                	mov    ebp,esp
 1a4:	83 ec 10             	sub    esp,0x10
    const char * p = str;
 1a7:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 1aa:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax
    int i = 0;
 1ad:	c7 45 f8 00 00 00 00 	mov    DWORD PTR [ebp-0x8],0x0

    while (*p) {
 1b4:	eb 29                	jmp    1df <pokehstr+0x3e>
        pokech(row, column+i, *p, color);
 1b6:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 1b9:	0f b6 00             	movzx  eax,BYTE PTR [eax]
 1bc:	0f be c0             	movsx  eax,al
 1bf:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
 1c2:	8b 55 f8             	mov    edx,DWORD PTR [ebp-0x8]
 1c5:	01 ca                	add    edx,ecx
 1c7:	ff 75 14             	push   DWORD PTR [ebp+0x14]
 1ca:	50                   	push   eax
 1cb:	52                   	push   edx
 1cc:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 1cf:	e8 fc ff ff ff       	call   1d0 <pokehstr+0x2f>
 1d4:	83 c4 10             	add    esp,0x10
        i++;
 1d7:	83 45 f8 01          	add    DWORD PTR [ebp-0x8],0x1
        p++;
 1db:	83 45 fc 01          	add    DWORD PTR [ebp-0x4],0x1
    while (*p) {
 1df:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 1e2:	0f b6 00             	movzx  eax,BYTE PTR [eax]
 1e5:	84 c0                	test   al,al
 1e7:	75 cd                	jne    1b6 <pokehstr+0x15>
    }
}
 1e9:	90                   	nop
 1ea:	c9                   	leave  
 1eb:	c3                   	ret    

000001ec <pokehint>:

int
pokehint(int row, int column, int n, int color)
{
 1ec:	55                   	push   ebp
 1ed:	89 e5                	mov    ebp,esp
 1ef:	83 ec 10             	sub    esp,0x10
    int i = 1;
 1f2:	c7 45 fc 01 00 00 00 	mov    DWORD PTR [ebp-0x4],0x1
    if (n > 99) {
 1f9:	83 7d 10 63          	cmp    DWORD PTR [ebp+0x10],0x63
 1fd:	7e 59                	jle    258 <pokehint+0x6c>
        pokech(row, column++, '0' + n/100, YELLOW);
 1ff:	8b 4d 10             	mov    ecx,DWORD PTR [ebp+0x10]
 202:	ba 1f 85 eb 51       	mov    edx,0x51eb851f
 207:	89 c8                	mov    eax,ecx
 209:	f7 ea                	imul   edx
 20b:	c1 fa 05             	sar    edx,0x5
 20e:	89 c8                	mov    eax,ecx
 210:	c1 f8 1f             	sar    eax,0x1f
 213:	29 c2                	sub    edx,eax
 215:	89 d0                	mov    eax,edx
 217:	8d 48 30             	lea    ecx,[eax+0x30]
 21a:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 21d:	8d 50 01             	lea    edx,[eax+0x1]
 220:	89 55 0c             	mov    DWORD PTR [ebp+0xc],edx
 223:	6a 0e                	push   0xe
 225:	51                   	push   ecx
 226:	50                   	push   eax
 227:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 22a:	e8 fc ff ff ff       	call   22b <pokehint+0x3f>
 22f:	83 c4 10             	add    esp,0x10
        n %= 100;
 232:	8b 4d 10             	mov    ecx,DWORD PTR [ebp+0x10]
 235:	ba 1f 85 eb 51       	mov    edx,0x51eb851f
 23a:	89 c8                	mov    eax,ecx
 23c:	f7 ea                	imul   edx
 23e:	c1 fa 05             	sar    edx,0x5
 241:	89 c8                	mov    eax,ecx
 243:	c1 f8 1f             	sar    eax,0x1f
 246:	29 c2                	sub    edx,eax
 248:	89 d0                	mov    eax,edx
 24a:	6b c0 64             	imul   eax,eax,0x64
 24d:	29 c1                	sub    ecx,eax
 24f:	89 c8                	mov    eax,ecx
 251:	89 45 10             	mov    DWORD PTR [ebp+0x10],eax
        i++;
 254:	83 45 fc 01          	add    DWORD PTR [ebp-0x4],0x1
    }
    if (n > 9) {
 258:	83 7d 10 09          	cmp    DWORD PTR [ebp+0x10],0x9
 25c:	7e 5d                	jle    2bb <pokehint+0xcf>
        pokech(row, column++, '0' + n/10, YELLOW);
 25e:	8b 4d 10             	mov    ecx,DWORD PTR [ebp+0x10]
 261:	ba 67 66 66 66       	mov    edx,0x66666667
 266:	89 c8                	mov    eax,ecx
 268:	f7 ea                	imul   edx
 26a:	c1 fa 02             	sar    edx,0x2
 26d:	89 c8                	mov    eax,ecx
 26f:	c1 f8 1f             	sar    eax,0x1f
 272:	29 c2                	sub    edx,eax
 274:	89 d0                	mov    eax,edx
 276:	8d 48 30             	lea    ecx,[eax+0x30]
 279:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 27c:	8d 50 01             	lea    edx,[eax+0x1]
 27f:	89 55 0c             	mov    DWORD PTR [ebp+0xc],edx
 282:	6a 0e                	push   0xe
 284:	51                   	push   ecx
 285:	50                   	push   eax
 286:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 289:	e8 fc ff ff ff       	call   28a <pokehint+0x9e>
 28e:	83 c4 10             	add    esp,0x10
        n %= 10;
 291:	8b 4d 10             	mov    ecx,DWORD PTR [ebp+0x10]
 294:	ba 67 66 66 66       	mov    edx,0x66666667
 299:	89 c8                	mov    eax,ecx
 29b:	f7 ea                	imul   edx
 29d:	c1 fa 02             	sar    edx,0x2
 2a0:	89 c8                	mov    eax,ecx
 2a2:	c1 f8 1f             	sar    eax,0x1f
 2a5:	29 c2                	sub    edx,eax
 2a7:	89 d0                	mov    eax,edx
 2a9:	c1 e0 02             	shl    eax,0x2
 2ac:	01 d0                	add    eax,edx
 2ae:	01 c0                	add    eax,eax
 2b0:	29 c1                	sub    ecx,eax
 2b2:	89 c8                	mov    eax,ecx
 2b4:	89 45 10             	mov    DWORD PTR [ebp+0x10],eax
        i++;
 2b7:	83 45 fc 01          	add    DWORD PTR [ebp-0x4],0x1
    }
    pokech(row, column++, '0' + n, YELLOW);
 2bb:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 2be:	8d 48 30             	lea    ecx,[eax+0x30]
 2c1:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 2c4:	8d 50 01             	lea    edx,[eax+0x1]
 2c7:	89 55 0c             	mov    DWORD PTR [ebp+0xc],edx
 2ca:	6a 0e                	push   0xe
 2cc:	51                   	push   ecx
 2cd:	50                   	push   eax
 2ce:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 2d1:	e8 fc ff ff ff       	call   2d2 <pokehint+0xe6>
 2d6:	83 c4 10             	add    esp,0x10
    return i;
 2d9:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
}
 2dc:	c9                   	leave  
 2dd:	c3                   	ret    

000002de <pokevstr>:

void
pokevstr(int row, int column, const char * str, int color)
{
 2de:	55                   	push   ebp
 2df:	89 e5                	mov    ebp,esp
 2e1:	83 ec 10             	sub    esp,0x10
    const char * p = str;
 2e4:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 2e7:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax
    int i = 0;
 2ea:	c7 45 f8 00 00 00 00 	mov    DWORD PTR [ebp-0x8],0x0

    while (*p) {
 2f1:	eb 29                	jmp    31c <pokevstr+0x3e>
        pokech(row+i, column, *p, color);
 2f3:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 2f6:	0f b6 00             	movzx  eax,BYTE PTR [eax]
 2f9:	0f be c0             	movsx  eax,al
 2fc:	8b 4d 08             	mov    ecx,DWORD PTR [ebp+0x8]
 2ff:	8b 55 f8             	mov    edx,DWORD PTR [ebp-0x8]
 302:	01 ca                	add    edx,ecx
 304:	ff 75 14             	push   DWORD PTR [ebp+0x14]
 307:	50                   	push   eax
 308:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 30b:	52                   	push   edx
 30c:	e8 fc ff ff ff       	call   30d <pokevstr+0x2f>
 311:	83 c4 10             	add    esp,0x10
        i++;
 314:	83 45 f8 01          	add    DWORD PTR [ebp-0x8],0x1
        p++;
 318:	83 45 fc 01          	add    DWORD PTR [ebp-0x4],0x1
    while (*p) {
 31c:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 31f:	0f b6 00             	movzx  eax,BYTE PTR [eax]
 322:	84 c0                	test   al,al
 324:	75 cd                	jne    2f3 <pokevstr+0x15>
    }
}
 326:	90                   	nop
 327:	c9                   	leave  
 328:	c3                   	ret    

00000329 <box>:

void
box(int toprow, int leftcolumn, int bottomrow, int rightcolumn, int color)
{
 329:	55                   	push   ebp
 32a:	89 e5                	mov    ebp,esp
 32c:	83 ec 10             	sub    esp,0x10
    int saved_rightcolumn = rightcolumn;
 32f:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 332:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax

    pokech(bottomrow, rightcolumn, 217, color);
 335:	ff 75 18             	push   DWORD PTR [ebp+0x18]
 338:	68 d9 00 00 00       	push   0xd9
 33d:	ff 75 14             	push   DWORD PTR [ebp+0x14]
 340:	ff 75 10             	push   DWORD PTR [ebp+0x10]
 343:	e8 fc ff ff ff       	call   344 <box+0x1b>
 348:	83 c4 10             	add    esp,0x10
    pokech(toprow,    rightcolumn, 191, color);
 34b:	ff 75 18             	push   DWORD PTR [ebp+0x18]
 34e:	68 bf 00 00 00       	push   0xbf
 353:	ff 75 14             	push   DWORD PTR [ebp+0x14]
 356:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 359:	e8 fc ff ff ff       	call   35a <box+0x31>
 35e:	83 c4 10             	add    esp,0x10
    pokech(bottomrow, leftcolumn,  192, color);
 361:	ff 75 18             	push   DWORD PTR [ebp+0x18]
 364:	68 c0 00 00 00       	push   0xc0
 369:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 36c:	ff 75 10             	push   DWORD PTR [ebp+0x10]
 36f:	e8 fc ff ff ff       	call   370 <box+0x47>
 374:	83 c4 10             	add    esp,0x10
    pokech(toprow,    leftcolumn,  218, color);
 377:	ff 75 18             	push   DWORD PTR [ebp+0x18]
 37a:	68 da 00 00 00       	push   0xda
 37f:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 382:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 385:	e8 fc ff ff ff       	call   386 <box+0x5d>
 38a:	83 c4 10             	add    esp,0x10
    while (--rightcolumn > leftcolumn) {
 38d:	eb 2c                	jmp    3bb <box+0x92>
        pokech(bottomrow, rightcolumn, 196, color);
 38f:	ff 75 18             	push   DWORD PTR [ebp+0x18]
 392:	68 c4 00 00 00       	push   0xc4
 397:	ff 75 14             	push   DWORD PTR [ebp+0x14]
 39a:	ff 75 10             	push   DWORD PTR [ebp+0x10]
 39d:	e8 fc ff ff ff       	call   39e <box+0x75>
 3a2:	83 c4 10             	add    esp,0x10
        pokech(toprow,    rightcolumn, 196, color);
 3a5:	ff 75 18             	push   DWORD PTR [ebp+0x18]
 3a8:	68 c4 00 00 00       	push   0xc4
 3ad:	ff 75 14             	push   DWORD PTR [ebp+0x14]
 3b0:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 3b3:	e8 fc ff ff ff       	call   3b4 <box+0x8b>
 3b8:	83 c4 10             	add    esp,0x10
    while (--rightcolumn > leftcolumn) {
 3bb:	83 6d 14 01          	sub    DWORD PTR [ebp+0x14],0x1
 3bf:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 3c2:	3b 45 0c             	cmp    eax,DWORD PTR [ebp+0xc]
 3c5:	7f c8                	jg     38f <box+0x66>
    }
    rightcolumn = saved_rightcolumn;
 3c7:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 3ca:	89 45 14             	mov    DWORD PTR [ebp+0x14],eax
    while (--bottomrow > toprow) {
 3cd:	eb 2c                	jmp    3fb <box+0xd2>
        pokech(bottomrow, leftcolumn,  179, color);
 3cf:	ff 75 18             	push   DWORD PTR [ebp+0x18]
 3d2:	68 b3 00 00 00       	push   0xb3
 3d7:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 3da:	ff 75 10             	push   DWORD PTR [ebp+0x10]
 3dd:	e8 fc ff ff ff       	call   3de <box+0xb5>
 3e2:	83 c4 10             	add    esp,0x10
        pokech(bottomrow, rightcolumn, 179, color);
 3e5:	ff 75 18             	push   DWORD PTR [ebp+0x18]
 3e8:	68 b3 00 00 00       	push   0xb3
 3ed:	ff 75 14             	push   DWORD PTR [ebp+0x14]
 3f0:	ff 75 10             	push   DWORD PTR [ebp+0x10]
 3f3:	e8 fc ff ff ff       	call   3f4 <box+0xcb>
 3f8:	83 c4 10             	add    esp,0x10
    while (--bottomrow > toprow) {
 3fb:	83 6d 10 01          	sub    DWORD PTR [ebp+0x10],0x1
 3ff:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 402:	3b 45 08             	cmp    eax,DWORD PTR [ebp+0x8]
 405:	7f c8                	jg     3cf <box+0xa6>
    }
}
 407:	90                   	nop
 408:	c9                   	leave  
 409:	c3                   	ret    

0000040a <hcollision>:
 * also changes the input arg 'dir' if there is a collision
 * in the primary direction.
 */
int
hcollision(int row, int startcolumn, int * dirp, int len)
{
 40a:	55                   	push   ebp
 40b:	89 e5                	mov    ebp,esp
 40d:	83 ec 10             	sub    esp,0x10
    int clear_to_left  = ((peekch(row, startcolumn-1) & 0xff) == ' ');
 410:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 413:	83 e8 01             	sub    eax,0x1
 416:	50                   	push   eax
 417:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 41a:	e8 fc ff ff ff       	call   41b <hcollision+0x11>
 41f:	83 c4 08             	add    esp,0x8
 422:	0f b6 c0             	movzx  eax,al
 425:	83 f8 20             	cmp    eax,0x20
 428:	0f 94 c0             	sete   al
 42b:	0f b6 c0             	movzx  eax,al
 42e:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax
    int clear_to_right = ((peekch(row, startcolumn+len-1) & 0xff) == ' ');
 431:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 434:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 437:	01 d0                	add    eax,edx
 439:	83 e8 01             	sub    eax,0x1
 43c:	50                   	push   eax
 43d:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 440:	e8 fc ff ff ff       	call   441 <hcollision+0x37>
 445:	83 c4 08             	add    esp,0x8
 448:	0f b6 c0             	movzx  eax,al
 44b:	83 f8 20             	cmp    eax,0x20
 44e:	0f 94 c0             	sete   al
 451:	0f b6 c0             	movzx  eax,al
 454:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax

    // are we good to continue?
    if ((*dirp > 0  &&  clear_to_right) || (*dirp < 0  &&  clear_to_left))
 457:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 45a:	8b 00                	mov    eax,DWORD PTR [eax]
 45c:	85 c0                	test   eax,eax
 45e:	7e 06                	jle    466 <hcollision+0x5c>
 460:	83 7d f8 00          	cmp    DWORD PTR [ebp-0x8],0x0
 464:	75 0f                	jne    475 <hcollision+0x6b>
 466:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 469:	8b 00                	mov    eax,DWORD PTR [eax]
 46b:	85 c0                	test   eax,eax
 46d:	79 0d                	jns    47c <hcollision+0x72>
 46f:	83 7d fc 00          	cmp    DWORD PTR [ebp-0x4],0x0
 473:	74 07                	je     47c <hcollision+0x72>
        return *dirp;
 475:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 478:	8b 00                	mov    eax,DWORD PTR [eax]
 47a:	eb 38                	jmp    4b4 <hcollision+0xaa>
    // else try the opposite direction
    *dirp = -(*dirp);
 47c:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 47f:	8b 00                	mov    eax,DWORD PTR [eax]
 481:	f7 d8                	neg    eax
 483:	89 c2                	mov    edx,eax
 485:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 488:	89 10                	mov    DWORD PTR [eax],edx
    if ((*dirp > 0  &&  clear_to_right) || (*dirp < 0  &&  clear_to_left))
 48a:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 48d:	8b 00                	mov    eax,DWORD PTR [eax]
 48f:	85 c0                	test   eax,eax
 491:	7e 06                	jle    499 <hcollision+0x8f>
 493:	83 7d f8 00          	cmp    DWORD PTR [ebp-0x8],0x0
 497:	75 0f                	jne    4a8 <hcollision+0x9e>
 499:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 49c:	8b 00                	mov    eax,DWORD PTR [eax]
 49e:	85 c0                	test   eax,eax
 4a0:	79 0d                	jns    4af <hcollision+0xa5>
 4a2:	83 7d fc 00          	cmp    DWORD PTR [ebp-0x4],0x0
 4a6:	74 07                	je     4af <hcollision+0xa5>
        return *dirp;
 4a8:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 4ab:	8b 00                	mov    eax,DWORD PTR [eax]
 4ad:	eb 05                	jmp    4b4 <hcollision+0xaa>
    // completely blocked
    return 0;
 4af:	b8 00 00 00 00       	mov    eax,0x0
}
 4b4:	c9                   	leave  
 4b5:	c3                   	ret    

000004b6 <vcollision>:
/*
 * check for a vertical collision
 */
int
vcollision(int startrow, int column, int * dirp, int len)
{
 4b6:	55                   	push   ebp
 4b7:	89 e5                	mov    ebp,esp
 4b9:	83 ec 10             	sub    esp,0x10
    int clear_above = ((peekch(startrow-1, column) & 0xff) == ' ');
 4bc:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 4bf:	83 e8 01             	sub    eax,0x1
 4c2:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 4c5:	50                   	push   eax
 4c6:	e8 fc ff ff ff       	call   4c7 <vcollision+0x11>
 4cb:	83 c4 08             	add    esp,0x8
 4ce:	0f b6 c0             	movzx  eax,al
 4d1:	83 f8 20             	cmp    eax,0x20
 4d4:	0f 94 c0             	sete   al
 4d7:	0f b6 c0             	movzx  eax,al
 4da:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax
    int clear_below = ((peekch(startrow+len-1, column) & 0xff) == ' ');
 4dd:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
 4e0:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 4e3:	01 d0                	add    eax,edx
 4e5:	83 e8 01             	sub    eax,0x1
 4e8:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 4eb:	50                   	push   eax
 4ec:	e8 fc ff ff ff       	call   4ed <vcollision+0x37>
 4f1:	83 c4 08             	add    esp,0x8
 4f4:	0f b6 c0             	movzx  eax,al
 4f7:	83 f8 20             	cmp    eax,0x20
 4fa:	0f 94 c0             	sete   al
 4fd:	0f b6 c0             	movzx  eax,al
 500:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax

    // are we good to continue?
    if ((*dirp > 0  &&  clear_below) || (*dirp < 0  &&  clear_above))
 503:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 506:	8b 00                	mov    eax,DWORD PTR [eax]
 508:	85 c0                	test   eax,eax
 50a:	7e 06                	jle    512 <vcollision+0x5c>
 50c:	83 7d f8 00          	cmp    DWORD PTR [ebp-0x8],0x0
 510:	75 0f                	jne    521 <vcollision+0x6b>
 512:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 515:	8b 00                	mov    eax,DWORD PTR [eax]
 517:	85 c0                	test   eax,eax
 519:	79 0d                	jns    528 <vcollision+0x72>
 51b:	83 7d fc 00          	cmp    DWORD PTR [ebp-0x4],0x0
 51f:	74 07                	je     528 <vcollision+0x72>
        return *dirp;
 521:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 524:	8b 00                	mov    eax,DWORD PTR [eax]
 526:	eb 38                	jmp    560 <vcollision+0xaa>
    // else try the opposite direction
    *dirp = -(*dirp);
 528:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 52b:	8b 00                	mov    eax,DWORD PTR [eax]
 52d:	f7 d8                	neg    eax
 52f:	89 c2                	mov    edx,eax
 531:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 534:	89 10                	mov    DWORD PTR [eax],edx
    if ((*dirp > 0  &&  clear_below) || (*dirp < 0  &&  clear_above))
 536:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 539:	8b 00                	mov    eax,DWORD PTR [eax]
 53b:	85 c0                	test   eax,eax
 53d:	7e 06                	jle    545 <vcollision+0x8f>
 53f:	83 7d f8 00          	cmp    DWORD PTR [ebp-0x8],0x0
 543:	75 0f                	jne    554 <vcollision+0x9e>
 545:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 548:	8b 00                	mov    eax,DWORD PTR [eax]
 54a:	85 c0                	test   eax,eax
 54c:	79 0d                	jns    55b <vcollision+0xa5>
 54e:	83 7d fc 00          	cmp    DWORD PTR [ebp-0x4],0x0
 552:	74 07                	je     55b <vcollision+0xa5>
        return *dirp;
 554:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 557:	8b 00                	mov    eax,DWORD PTR [eax]
 559:	eb 05                	jmp    560 <vcollision+0xaa>
    // completely blocked
    return 0;
 55b:	b8 00 00 00 00       	mov    eax,0x0
}
 560:	c9                   	leave  
 561:	c3                   	ret    

00000562 <hthread>:

#define memcpy __builtin_memcpy

void
hthread(int thno)
{
 562:	55                   	push   ebp
 563:	89 e5                	mov    ebp,esp
 565:	83 ec 20             	sub    esp,0x20
    char blip[8];
    int row = thno / 2 + 2;
 568:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 56b:	89 c2                	mov    edx,eax
 56d:	c1 ea 1f             	shr    edx,0x1f
 570:	01 d0                	add    eax,edx
 572:	d1 f8                	sar    eax,1
 574:	83 c0 02             	add    eax,0x2
 577:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax
    int xpos = 1;
 57a:	c7 45 fc 01 00 00 00 	mov    DWORD PTR [ebp-0x4],0x1
    int xdir = 1;
 581:	c7 45 e8 01 00 00 00 	mov    DWORD PTR [ebp-0x18],0x1
    int mdir;

    memcpy(blip, hblip, sizeof(hblip)+1);   // copy hblip to the local stack
 588:	8d 45 ec             	lea    eax,[ebp-0x14]
 58b:	8b 15 00 00 00 00    	mov    edx,DWORD PTR ds:0x0
 591:	89 10                	mov    DWORD PTR [eax],edx
 593:	0f b7 15 04 00 00 00 	movzx  edx,WORD PTR ds:0x4
 59a:	66 89 50 04          	mov    WORD PTR [eax+0x4],dx
 59e:	0f b6 15 06 00 00 00 	movzx  edx,BYTE PTR ds:0x6
 5a5:	88 50 06             	mov    BYTE PTR [eax+0x6],dl
    blip[2] = '0' + thno;                   // make our blip unique
 5a8:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 5ab:	83 c0 30             	add    eax,0x30
 5ae:	88 45 ee             	mov    BYTE PTR [ebp-0x12],al

    while (1) {
        // write new blip
        pokehstr(row, xpos, blip, CYAN);
 5b1:	6a 0b                	push   0xb
 5b3:	8d 45 ec             	lea    eax,[ebp-0x14]
 5b6:	50                   	push   eax
 5b7:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 5ba:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 5bd:	e8 fc ff ff ff       	call   5be <hthread+0x5c>
 5c2:	83 c4 10             	add    esp,0x10

        if (thno == 0) {
 5c5:	83 7d 08 00          	cmp    DWORD PTR [ebp+0x8],0x0
 5c9:	75 11                	jne    5dc <hthread+0x7a>
            sleep(1);                       // the control threads sleeps
 5cb:	6a 01                	push   0x1
 5cd:	e8 fc ff ff ff       	call   5ce <hthread+0x6c>
 5d2:	83 c4 04             	add    esp,0x4
            resume();
 5d5:	e8 fc ff ff ff       	call   5d6 <hthread+0x74>
 5da:	eb 05                	jmp    5e1 <hthread+0x7f>
        } else {
            pause();                        // other threads wait
 5dc:	e8 fc ff ff ff       	call   5dd <hthread+0x7b>
        }

        mdir = hcollision(row, xpos, &xdir, sizeof(hblip));
 5e1:	6a 06                	push   0x6
 5e3:	8d 45 e8             	lea    eax,[ebp-0x18]
 5e6:	50                   	push   eax
 5e7:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 5ea:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 5ed:	e8 fc ff ff ff       	call   5ee <hthread+0x8c>
 5f2:	83 c4 10             	add    esp,0x10
 5f5:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax

        // blank part of old blip
        if (mdir > 0)
 5f8:	83 7d f4 00          	cmp    DWORD PTR [ebp-0xc],0x0
 5fc:	7e 14                	jle    612 <hthread+0xb0>
            pokech(row, xpos, ' ', BLACK);
 5fe:	6a 00                	push   0x0
 600:	6a 20                	push   0x20
 602:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 605:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 608:	e8 fc ff ff ff       	call   609 <hthread+0xa7>
 60d:	83 c4 10             	add    esp,0x10
 610:	eb 1c                	jmp    62e <hthread+0xcc>
        else if (mdir < 0)
 612:	83 7d f4 00          	cmp    DWORD PTR [ebp-0xc],0x0
 616:	79 16                	jns    62e <hthread+0xcc>
            pokech(row, xpos+sizeof(hblip)-2, ' ', BLACK);
 618:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 61b:	83 c0 04             	add    eax,0x4
 61e:	6a 00                	push   0x0
 620:	6a 20                	push   0x20
 622:	50                   	push   eax
 623:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 626:	e8 fc ff ff ff       	call   627 <hthread+0xc5>
 62b:	83 c4 10             	add    esp,0x10

        xpos += mdir;
 62e:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 631:	01 45 fc             	add    DWORD PTR [ebp-0x4],eax
        pokehstr(row, xpos, blip, CYAN);
 634:	e9 78 ff ff ff       	jmp    5b1 <hthread+0x4f>

00000639 <vthread>:
    }
}

void
vthread(int thno)
{
 639:	55                   	push   ebp
 63a:	89 e5                	mov    ebp,esp
 63c:	83 ec 20             	sub    esp,0x20
    char blip[8];
    int column = thno * 2 + 20;
 63f:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 642:	83 c0 0a             	add    eax,0xa
 645:	01 c0                	add    eax,eax
 647:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax
    int ypos = 1;
 64a:	c7 45 fc 01 00 00 00 	mov    DWORD PTR [ebp-0x4],0x1
    int ydir = 1;
 651:	c7 45 e8 01 00 00 00 	mov    DWORD PTR [ebp-0x18],0x1
    int mdir;

    memcpy(blip, vblip, sizeof(vblip)+1);   // copy vblip to the local stack
 658:	8d 45 ec             	lea    eax,[ebp-0x14]
 65b:	8b 15 00 00 00 00    	mov    edx,DWORD PTR ds:0x0
 661:	89 10                	mov    DWORD PTR [eax],edx
 663:	0f b6 15 04 00 00 00 	movzx  edx,BYTE PTR ds:0x4
 66a:	88 50 04             	mov    BYTE PTR [eax+0x4],dl
    blip[1] = '0' + thno;                   // make our blip unique
 66d:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 670:	83 c0 30             	add    eax,0x30
 673:	88 45 ed             	mov    BYTE PTR [ebp-0x13],al

    while (1) {
        // write new blip
        pokevstr(ypos, column, blip, CYAN);
 676:	6a 0b                	push   0xb
 678:	8d 45 ec             	lea    eax,[ebp-0x14]
 67b:	50                   	push   eax
 67c:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 67f:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 682:	e8 fc ff ff ff       	call   683 <vthread+0x4a>
 687:	83 c4 10             	add    esp,0x10
        pause();
 68a:	e8 fc ff ff ff       	call   68b <vthread+0x52>

        mdir = vcollision(ypos, column, &ydir, sizeof(vblip));
 68f:	6a 04                	push   0x4
 691:	8d 45 e8             	lea    eax,[ebp-0x18]
 694:	50                   	push   eax
 695:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 698:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 69b:	e8 fc ff ff ff       	call   69c <vthread+0x63>
 6a0:	83 c4 10             	add    esp,0x10
 6a3:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax

        // blank part of old blip
        if (mdir > 0)
 6a6:	83 7d f4 00          	cmp    DWORD PTR [ebp-0xc],0x0
 6aa:	7e 14                	jle    6c0 <vthread+0x87>
            pokech(ypos, column, ' ', BLACK);
 6ac:	6a 00                	push   0x0
 6ae:	6a 20                	push   0x20
 6b0:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 6b3:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 6b6:	e8 fc ff ff ff       	call   6b7 <vthread+0x7e>
 6bb:	83 c4 10             	add    esp,0x10
 6be:	eb 1c                	jmp    6dc <vthread+0xa3>
        else if (mdir < 0)
 6c0:	83 7d f4 00          	cmp    DWORD PTR [ebp-0xc],0x0
 6c4:	79 16                	jns    6dc <vthread+0xa3>
            pokech(ypos+sizeof(vblip)-2, column, ' ', BLACK);
 6c6:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 6c9:	83 c0 02             	add    eax,0x2
 6cc:	6a 00                	push   0x0
 6ce:	6a 20                	push   0x20
 6d0:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 6d3:	50                   	push   eax
 6d4:	e8 fc ff ff ff       	call   6d5 <vthread+0x9c>
 6d9:	83 c4 10             	add    esp,0x10

        ypos += mdir;
 6dc:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 6df:	01 45 fc             	add    DWORD PTR [ebp-0x4],eax
        pokevstr(ypos, column, blip, CYAN);
 6e2:	eb 92                	jmp    676 <vthread+0x3d>

000006e4 <main>:
    }
}

int
main(void)
{
 6e4:	55                   	push   ebp
 6e5:	89 e5                	mov    ebp,esp
 6e7:	83 ec 10             	sub    esp,0x10
    int i;
    int ncpus;

    map_vga_memory();
 6ea:	e8 fc ff ff ff       	call   6eb <main+0x7>

    ncpus = syscall0(0x1000);       //  0x1000 = ncpus
 6ef:	68 00 10 00 00       	push   0x1000
 6f4:	e8 fc ff ff ff       	call   6f5 <main+0x11>
 6f9:	83 c4 04             	add    esp,0x4
 6fc:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax

    if (ncpus > MAX_THREADS)
 6ff:	83 7d f8 20          	cmp    DWORD PTR [ebp-0x8],0x20
 703:	7e 07                	jle    70c <main+0x28>
        ncpus = MAX_THREADS;
 705:	c7 45 f8 20 00 00 00 	mov    DWORD PTR [ebp-0x8],0x20

    // create boundaries for blips
    box(0, 0, HEIGHT-1, WIDTH-1, GRAY);
 70c:	6a 08                	push   0x8
 70e:	6a 4f                	push   0x4f
 710:	6a 12                	push   0x12
 712:	6a 00                	push   0x0
 714:	6a 00                	push   0x0
 716:	e8 fc ff ff ff       	call   717 <main+0x33>
 71b:	83 c4 14             	add    esp,0x14

    for (i = 1; i < ncpus; i++) {
 71e:	c7 45 fc 01 00 00 00 	mov    DWORD PTR [ebp-0x4],0x1
 725:	eb 30                	jmp    757 <main+0x73>
        if (i & 1)
 727:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 72a:	83 e0 01             	and    eax,0x1
 72d:	85 c0                	test   eax,eax
 72f:	74 12                	je     743 <main+0x5f>
            new_thread(vthread, i);
 731:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 734:	68 00 00 00 00       	push   0x0
 739:	e8 fc ff ff ff       	call   73a <main+0x56>
 73e:	83 c4 08             	add    esp,0x8
 741:	eb 10                	jmp    753 <main+0x6f>
        else
            new_thread(hthread, i);
 743:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 746:	68 00 00 00 00       	push   0x0
 74b:	e8 fc ff ff ff       	call   74c <main+0x68>
 750:	83 c4 08             	add    esp,0x8
    for (i = 1; i < ncpus; i++) {
 753:	83 45 fc 01          	add    DWORD PTR [ebp-0x4],0x1
 757:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 75a:	3b 45 f8             	cmp    eax,DWORD PTR [ebp-0x8]
 75d:	7c c8                	jl     727 <main+0x43>
    }
    start_threads();                // currently an ipi is needed to start threads
 75f:	e8 fc ff ff ff       	call   760 <main+0x7c>

    pokehstr(1, 1, "using", YELLOW);
 764:	6a 0e                	push   0xe
 766:	68 0c 00 00 00       	push   0xc
 76b:	6a 01                	push   0x1
 76d:	6a 01                	push   0x1
 76f:	e8 fc ff ff ff       	call   770 <main+0x8c>
 774:	83 c4 10             	add    esp,0x10
    pokehint(1, 7, i, YELLOW);
 777:	6a 0e                	push   0xe
 779:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 77c:	6a 07                	push   0x7
 77e:	6a 01                	push   0x1
 780:	e8 fc ff ff ff       	call   781 <main+0x9d>
 785:	83 c4 10             	add    esp,0x10
    pokehstr(1, 10, "of", YELLOW);
 788:	6a 0e                	push   0xe
 78a:	68 12 00 00 00       	push   0x12
 78f:	6a 0a                	push   0xa
 791:	6a 01                	push   0x1
 793:	e8 fc ff ff ff       	call   794 <main+0xb0>
 798:	83 c4 10             	add    esp,0x10
    i = 14;
 79b:	c7 45 fc 0e 00 00 00 	mov    DWORD PTR [ebp-0x4],0xe
    i += pokehint(1, 13, ncpus, YELLOW);
 7a2:	6a 0e                	push   0xe
 7a4:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 7a7:	6a 0d                	push   0xd
 7a9:	6a 01                	push   0x1
 7ab:	e8 fc ff ff ff       	call   7ac <main+0xc8>
 7b0:	83 c4 10             	add    esp,0x10
 7b3:	01 45 fc             	add    DWORD PTR [ebp-0x4],eax
    pokehstr(1, i, "cpus", YELLOW);
 7b6:	6a 0e                	push   0xe
 7b8:	68 15 00 00 00       	push   0x15
 7bd:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 7c0:	6a 01                	push   0x1
 7c2:	e8 fc ff ff ff       	call   7c3 <main+0xdf>
 7c7:	83 c4 10             	add    esp,0x10

    // main is thread 0
    hthread(0);
 7ca:	6a 00                	push   0x0
 7cc:	e8 fc ff ff ff       	call   7cd <main+0xe9>
 7d1:	83 c4 04             	add    esp,0x4
 7d4:	b8 00 00 00 00       	mov    eax,0x0

    // no return
}
 7d9:	c9                   	leave  
 7da:	c3                   	ret    

000007db <_start>:
                            (u64)&_end, (u64)&_start, (u64)&_data, 0,
#endif
                            };
void
_start(void)
{
 7db:	55                   	push   ebp
 7dc:	89 e5                	mov    ebp,esp
//  asm("    finit;      \n");      // include if using floating point
    asm("    call main;  \n");
 7de:	e8 fc ff ff ff       	call   7df <_start+0x4>
    asm("1:  iret;       \n");
 7e3:	cf                   	iret   
    asm("    jmp 1;      \n");
 7e4:	e9 fd ff ff ff       	jmp    7e6 <_start+0xb>
}
 7e9:	90                   	nop
 7ea:	5d                   	pop    ebp
 7eb:	c3                   	ret    
