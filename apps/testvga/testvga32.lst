
testvga32.o:     file format elf32-i386


Disassembly of section .text:

00000000 <syscall3>:

#include "types.h"

long
syscall3(int op, unsigned int arg1, unsigned int arg2, unsigned int arg3)
{
   0:	55                   	push   ebp
   1:	89 e5                	mov    ebp,esp
   3:	57                   	push   edi
   4:	56                   	push   esi
   5:	53                   	push   ebx
   6:	83 ec 10             	sub    esp,0x10
    long ret;
    asm volatile(
   9:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
   c:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
   f:	8b 4d 10             	mov    ecx,DWORD PTR [ebp+0x10]
  12:	8b 5d 14             	mov    ebx,DWORD PTR [ebp+0x14]
  15:	cd ff                	int    0xff
  17:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
        "int $0xff"
        : "=a" (ret)
        : "0" (op), "d" (arg1), "c" (arg2), "b" (arg3)
        : "cc", "edi", "esi", "memory");
    return ret;
  1a:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
}
  1d:	83 c4 10             	add    esp,0x10
  20:	5b                   	pop    ebx
  21:	5e                   	pop    esi
  22:	5f                   	pop    edi
  23:	5d                   	pop    ebp
  24:	c3                   	ret    

00000025 <syscall2>:

long
syscall2(int op, unsigned int arg1, unsigned int arg2)
{
  25:	55                   	push   ebp
  26:	89 e5                	mov    ebp,esp
  28:	57                   	push   edi
  29:	56                   	push   esi
  2a:	53                   	push   ebx
  2b:	83 ec 10             	sub    esp,0x10
    long ret;
    asm volatile(
  2e:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  31:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
  34:	8b 4d 10             	mov    ecx,DWORD PTR [ebp+0x10]
  37:	cd ff                	int    0xff
  39:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
        "int $0xff"
        : "=a" (ret)
        : "0" (op), "d" (arg1), "c" (arg2)
        : "cc", "ebx", "edi", "esi", "memory");
    return ret;
  3c:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
}
  3f:	83 c4 10             	add    esp,0x10
  42:	5b                   	pop    ebx
  43:	5e                   	pop    esi
  44:	5f                   	pop    edi
  45:	5d                   	pop    ebp
  46:	c3                   	ret    

00000047 <syscall1>:

long
syscall1(int op, unsigned int arg1)
{
  47:	55                   	push   ebp
  48:	89 e5                	mov    ebp,esp
  4a:	57                   	push   edi
  4b:	56                   	push   esi
  4c:	53                   	push   ebx
  4d:	83 ec 10             	sub    esp,0x10
    long ret;
    asm volatile(
  50:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  53:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
  56:	cd ff                	int    0xff
  58:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
        "int $0xff"
        : "=a" (ret)
        : "0" (op), "d" (arg1)
        : "cc", "ebx", "edi", "esi", "memory");
    return ret;
  5b:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
}
  5e:	83 c4 10             	add    esp,0x10
  61:	5b                   	pop    ebx
  62:	5e                   	pop    esi
  63:	5f                   	pop    edi
  64:	5d                   	pop    ebp
  65:	c3                   	ret    

00000066 <syscall0>:

long
syscall0(int op)
{
  66:	55                   	push   ebp
  67:	89 e5                	mov    ebp,esp
  69:	57                   	push   edi
  6a:	56                   	push   esi
  6b:	53                   	push   ebx
  6c:	83 ec 10             	sub    esp,0x10
    long ret;
    asm volatile(
  6f:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  72:	cd ff                	int    0xff
  74:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
        "int $0xff"
        : "=a" (ret)
        : "0" (op)
        : "cc", "ebx", "edi", "esi", "memory");
    return ret;
  77:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
}
  7a:	83 c4 10             	add    esp,0x10
  7d:	5b                   	pop    ebx
  7e:	5e                   	pop    esi
  7f:	5f                   	pop    edi
  80:	5d                   	pop    ebp
  81:	c3                   	ret    

00000082 <sleep>:

void
sleep(int ticks)
{
  82:	55                   	push   ebp
  83:	89 e5                	mov    ebp,esp
    //   0x2700 = wait for n timer interrupts
    syscall1(0x2000, ticks);
  85:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  88:	50                   	push   eax
  89:	68 00 20 00 00       	push   0x2000
  8e:	e8 fc ff ff ff       	call   8f <sleep+0xd>
  93:	83 c4 08             	add    esp,0x8
}
  96:	90                   	nop
  97:	c9                   	leave  
  98:	c3                   	ret    

00000099 <new_thread>:
// disrupting the app's 8k footprint)
unsigned char stack[MAX_THREADS][STACK_SIZE] = {1};

int
new_thread(void (* func)(int), int thno)
{
  99:	55                   	push   ebp
  9a:	89 e5                	mov    ebp,esp
  9c:	83 ec 10             	sub    esp,0x10
    unsigned char * stackend = stack[MAX_THREADS - thno];
  9f:	b8 10 00 00 00       	mov    eax,0x10
  a4:	2b 45 0c             	sub    eax,DWORD PTR [ebp+0xc]
  a7:	c1 e0 08             	shl    eax,0x8
  aa:	05 00 00 00 00       	add    eax,0x0
  af:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax

    if (thno == 0)
  b2:	83 7d 0c 00          	cmp    DWORD PTR [ebp+0xc],0x0
  b6:	75 07                	jne    bf <new_thread+0x26>
        return -1;
  b8:	b8 ff ff ff ff       	mov    eax,0xffffffff
  bd:	eb 29                	jmp    e8 <new_thread+0x4f>

    // push thno onto the new thread's stack
    stackend -= sizeof(thno);
  bf:	83 6d fc 04          	sub    DWORD PTR [ebp-0x4],0x4
    *((int *)stackend) = thno;
  c3:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
  c6:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
  c9:	89 10                	mov    DWORD PTR [eax],edx
    stackend -= sizeof(void *);     // account for a return ip
  cb:	83 6d fc 04          	sub    DWORD PTR [ebp-0x4],0x4

    //    0x2100 = new thread
    //      func = function address
    //  stackend = address of the end of a thread specific stack
    //      thno = thread number
    return syscall3(0x2100, (unsigned int)func, (unsigned int)stackend, thno);
  cf:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
  d2:	8b 55 fc             	mov    edx,DWORD PTR [ebp-0x4]
  d5:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  d8:	51                   	push   ecx
  d9:	52                   	push   edx
  da:	50                   	push   eax
  db:	68 00 21 00 00       	push   0x2100
  e0:	e8 fc ff ff ff       	call   e1 <new_thread+0x48>
  e5:	83 c4 10             	add    esp,0x10
}
  e8:	c9                   	leave  
  e9:	c3                   	ret    

000000ea <map_vga_memory>:

#define VIDEORAM    ((short *)0xb8000)

void
map_vga_memory()
{
  ea:	55                   	push   ebp
  eb:	89 e5                	mov    ebp,esp
    //   0x2700 = request mem access
    // videoram = base physical address
    //   0x2000 = length in bytes
    syscall2(0x2700, (unsigned int)VIDEORAM, 0x2000);
  ed:	68 00 20 00 00       	push   0x2000
  f2:	68 00 80 0b 00       	push   0xb8000
  f7:	68 00 27 00 00       	push   0x2700
  fc:	e8 fc ff ff ff       	call   fd <map_vga_memory+0x13>
 101:	83 c4 0c             	add    esp,0xc
}
 104:	90                   	nop
 105:	c9                   	leave  
 106:	c3                   	ret    

00000107 <pokech>:
#define YELLOW  14
#define WHITE   15

void
pokech(int row, int column, int ch, int color)
{
 107:	55                   	push   ebp
 108:	89 e5                	mov    ebp,esp
    VIDEORAM[WIDTH * (TOPLINE + row) + column] = (color << 8) | ch;
 10a:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 10d:	8d 50 06             	lea    edx,[eax+0x6]
 110:	89 d0                	mov    eax,edx
 112:	c1 e0 02             	shl    eax,0x2
 115:	01 d0                	add    eax,edx
 117:	c1 e0 04             	shl    eax,0x4
 11a:	89 c2                	mov    edx,eax
 11c:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 11f:	01 d0                	add    eax,edx
 121:	01 c0                	add    eax,eax
 123:	05 00 80 0b 00       	add    eax,0xb8000
 128:	8b 55 14             	mov    edx,DWORD PTR [ebp+0x14]
 12b:	c1 e2 08             	shl    edx,0x8
 12e:	89 d1                	mov    ecx,edx
 130:	8b 55 10             	mov    edx,DWORD PTR [ebp+0x10]
 133:	09 ca                	or     edx,ecx
 135:	66 89 10             	mov    WORD PTR [eax],dx
}
 138:	90                   	nop
 139:	5d                   	pop    ebp
 13a:	c3                   	ret    

0000013b <peekch>:

int
peekch(int row, int column)
{
 13b:	55                   	push   ebp
 13c:	89 e5                	mov    ebp,esp
    return VIDEORAM[WIDTH * (TOPLINE + row) + column];
 13e:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 141:	8d 50 06             	lea    edx,[eax+0x6]
 144:	89 d0                	mov    eax,edx
 146:	c1 e0 02             	shl    eax,0x2
 149:	01 d0                	add    eax,edx
 14b:	c1 e0 04             	shl    eax,0x4
 14e:	89 c2                	mov    edx,eax
 150:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 153:	01 d0                	add    eax,edx
 155:	01 c0                	add    eax,eax
 157:	05 00 80 0b 00       	add    eax,0xb8000
 15c:	0f b7 00             	movzx  eax,WORD PTR [eax]
 15f:	98                   	cwde   
}
 160:	5d                   	pop    ebp
 161:	c3                   	ret    

00000162 <pokehstr>:

void
pokehstr(int row, int column, const char * str, int color)
{
 162:	55                   	push   ebp
 163:	89 e5                	mov    ebp,esp
 165:	83 ec 10             	sub    esp,0x10
    const char * p = str;
 168:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 16b:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax
    int i = 0;
 16e:	c7 45 f8 00 00 00 00 	mov    DWORD PTR [ebp-0x8],0x0

    while (*p) {
 175:	eb 29                	jmp    1a0 <pokehstr+0x3e>
        pokech(row, column+i, *p, color);
 177:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 17a:	0f b6 00             	movzx  eax,BYTE PTR [eax]
 17d:	0f be c0             	movsx  eax,al
 180:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
 183:	8b 55 f8             	mov    edx,DWORD PTR [ebp-0x8]
 186:	01 ca                	add    edx,ecx
 188:	ff 75 14             	push   DWORD PTR [ebp+0x14]
 18b:	50                   	push   eax
 18c:	52                   	push   edx
 18d:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 190:	e8 fc ff ff ff       	call   191 <pokehstr+0x2f>
 195:	83 c4 10             	add    esp,0x10
        i++;
 198:	83 45 f8 01          	add    DWORD PTR [ebp-0x8],0x1
        p++;
 19c:	83 45 fc 01          	add    DWORD PTR [ebp-0x4],0x1
pokehstr(int row, int column, const char * str, int color)
{
    const char * p = str;
    int i = 0;

    while (*p) {
 1a0:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 1a3:	0f b6 00             	movzx  eax,BYTE PTR [eax]
 1a6:	84 c0                	test   al,al
 1a8:	75 cd                	jne    177 <pokehstr+0x15>
        pokech(row, column+i, *p, color);
        i++;
        p++;
    }
}
 1aa:	90                   	nop
 1ab:	c9                   	leave  
 1ac:	c3                   	ret    

000001ad <pokehint>:

int
pokehint(int row, int column, int n, int color)
{
 1ad:	55                   	push   ebp
 1ae:	89 e5                	mov    ebp,esp
 1b0:	83 ec 10             	sub    esp,0x10
    int i = 1;
 1b3:	c7 45 fc 01 00 00 00 	mov    DWORD PTR [ebp-0x4],0x1
    if (n > 99) {
 1ba:	83 7d 10 63          	cmp    DWORD PTR [ebp+0x10],0x63
 1be:	7e 59                	jle    219 <pokehint+0x6c>
        pokech(row, column++, '0' + n/100, YELLOW);
 1c0:	8b 4d 10             	mov    ecx,DWORD PTR [ebp+0x10]
 1c3:	ba 1f 85 eb 51       	mov    edx,0x51eb851f
 1c8:	89 c8                	mov    eax,ecx
 1ca:	f7 ea                	imul   edx
 1cc:	c1 fa 05             	sar    edx,0x5
 1cf:	89 c8                	mov    eax,ecx
 1d1:	c1 f8 1f             	sar    eax,0x1f
 1d4:	29 c2                	sub    edx,eax
 1d6:	89 d0                	mov    eax,edx
 1d8:	8d 48 30             	lea    ecx,[eax+0x30]
 1db:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 1de:	8d 50 01             	lea    edx,[eax+0x1]
 1e1:	89 55 0c             	mov    DWORD PTR [ebp+0xc],edx
 1e4:	6a 0e                	push   0xe
 1e6:	51                   	push   ecx
 1e7:	50                   	push   eax
 1e8:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 1eb:	e8 fc ff ff ff       	call   1ec <pokehint+0x3f>
 1f0:	83 c4 10             	add    esp,0x10
        n %= 100;
 1f3:	8b 4d 10             	mov    ecx,DWORD PTR [ebp+0x10]
 1f6:	ba 1f 85 eb 51       	mov    edx,0x51eb851f
 1fb:	89 c8                	mov    eax,ecx
 1fd:	f7 ea                	imul   edx
 1ff:	c1 fa 05             	sar    edx,0x5
 202:	89 c8                	mov    eax,ecx
 204:	c1 f8 1f             	sar    eax,0x1f
 207:	29 c2                	sub    edx,eax
 209:	89 d0                	mov    eax,edx
 20b:	6b c0 64             	imul   eax,eax,0x64
 20e:	29 c1                	sub    ecx,eax
 210:	89 c8                	mov    eax,ecx
 212:	89 45 10             	mov    DWORD PTR [ebp+0x10],eax
        i++;
 215:	83 45 fc 01          	add    DWORD PTR [ebp-0x4],0x1
    }
    if (n > 9) {
 219:	83 7d 10 09          	cmp    DWORD PTR [ebp+0x10],0x9
 21d:	7e 5d                	jle    27c <pokehint+0xcf>
        pokech(row, column++, '0' + n/10, YELLOW);
 21f:	8b 4d 10             	mov    ecx,DWORD PTR [ebp+0x10]
 222:	ba 67 66 66 66       	mov    edx,0x66666667
 227:	89 c8                	mov    eax,ecx
 229:	f7 ea                	imul   edx
 22b:	c1 fa 02             	sar    edx,0x2
 22e:	89 c8                	mov    eax,ecx
 230:	c1 f8 1f             	sar    eax,0x1f
 233:	29 c2                	sub    edx,eax
 235:	89 d0                	mov    eax,edx
 237:	8d 48 30             	lea    ecx,[eax+0x30]
 23a:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 23d:	8d 50 01             	lea    edx,[eax+0x1]
 240:	89 55 0c             	mov    DWORD PTR [ebp+0xc],edx
 243:	6a 0e                	push   0xe
 245:	51                   	push   ecx
 246:	50                   	push   eax
 247:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 24a:	e8 fc ff ff ff       	call   24b <pokehint+0x9e>
 24f:	83 c4 10             	add    esp,0x10
        n %= 10;
 252:	8b 4d 10             	mov    ecx,DWORD PTR [ebp+0x10]
 255:	ba 67 66 66 66       	mov    edx,0x66666667
 25a:	89 c8                	mov    eax,ecx
 25c:	f7 ea                	imul   edx
 25e:	c1 fa 02             	sar    edx,0x2
 261:	89 c8                	mov    eax,ecx
 263:	c1 f8 1f             	sar    eax,0x1f
 266:	29 c2                	sub    edx,eax
 268:	89 d0                	mov    eax,edx
 26a:	c1 e0 02             	shl    eax,0x2
 26d:	01 d0                	add    eax,edx
 26f:	01 c0                	add    eax,eax
 271:	29 c1                	sub    ecx,eax
 273:	89 c8                	mov    eax,ecx
 275:	89 45 10             	mov    DWORD PTR [ebp+0x10],eax
        i++;
 278:	83 45 fc 01          	add    DWORD PTR [ebp-0x4],0x1
    }
    pokech(row, column++, '0' + n, YELLOW);
 27c:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 27f:	8d 48 30             	lea    ecx,[eax+0x30]
 282:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 285:	8d 50 01             	lea    edx,[eax+0x1]
 288:	89 55 0c             	mov    DWORD PTR [ebp+0xc],edx
 28b:	6a 0e                	push   0xe
 28d:	51                   	push   ecx
 28e:	50                   	push   eax
 28f:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 292:	e8 fc ff ff ff       	call   293 <pokehint+0xe6>
 297:	83 c4 10             	add    esp,0x10
    return i;
 29a:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
}
 29d:	c9                   	leave  
 29e:	c3                   	ret    

0000029f <pokevstr>:

void
pokevstr(int row, int column, const char * str, int color)
{
 29f:	55                   	push   ebp
 2a0:	89 e5                	mov    ebp,esp
 2a2:	83 ec 10             	sub    esp,0x10
    const char * p = str;
 2a5:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 2a8:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax
    int i = 0;
 2ab:	c7 45 f8 00 00 00 00 	mov    DWORD PTR [ebp-0x8],0x0

    while (*p) {
 2b2:	eb 29                	jmp    2dd <pokevstr+0x3e>
        pokech(row+i, column, *p, color);
 2b4:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 2b7:	0f b6 00             	movzx  eax,BYTE PTR [eax]
 2ba:	0f be c0             	movsx  eax,al
 2bd:	8b 4d 08             	mov    ecx,DWORD PTR [ebp+0x8]
 2c0:	8b 55 f8             	mov    edx,DWORD PTR [ebp-0x8]
 2c3:	01 ca                	add    edx,ecx
 2c5:	ff 75 14             	push   DWORD PTR [ebp+0x14]
 2c8:	50                   	push   eax
 2c9:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 2cc:	52                   	push   edx
 2cd:	e8 fc ff ff ff       	call   2ce <pokevstr+0x2f>
 2d2:	83 c4 10             	add    esp,0x10
        i++;
 2d5:	83 45 f8 01          	add    DWORD PTR [ebp-0x8],0x1
        p++;
 2d9:	83 45 fc 01          	add    DWORD PTR [ebp-0x4],0x1
pokevstr(int row, int column, const char * str, int color)
{
    const char * p = str;
    int i = 0;

    while (*p) {
 2dd:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 2e0:	0f b6 00             	movzx  eax,BYTE PTR [eax]
 2e3:	84 c0                	test   al,al
 2e5:	75 cd                	jne    2b4 <pokevstr+0x15>
        pokech(row+i, column, *p, color);
        i++;
        p++;
    }
}
 2e7:	90                   	nop
 2e8:	c9                   	leave  
 2e9:	c3                   	ret    

000002ea <box>:

void
box(int toprow, int leftcolumn, int bottomrow, int rightcolumn, int color)
{
 2ea:	55                   	push   ebp
 2eb:	89 e5                	mov    ebp,esp
 2ed:	83 ec 10             	sub    esp,0x10
    int saved_rightcolumn = rightcolumn;
 2f0:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 2f3:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax

    pokech(bottomrow, rightcolumn, 217, color);
 2f6:	ff 75 18             	push   DWORD PTR [ebp+0x18]
 2f9:	68 d9 00 00 00       	push   0xd9
 2fe:	ff 75 14             	push   DWORD PTR [ebp+0x14]
 301:	ff 75 10             	push   DWORD PTR [ebp+0x10]
 304:	e8 fc ff ff ff       	call   305 <box+0x1b>
 309:	83 c4 10             	add    esp,0x10
    pokech(toprow,    rightcolumn, 191, color);
 30c:	ff 75 18             	push   DWORD PTR [ebp+0x18]
 30f:	68 bf 00 00 00       	push   0xbf
 314:	ff 75 14             	push   DWORD PTR [ebp+0x14]
 317:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 31a:	e8 fc ff ff ff       	call   31b <box+0x31>
 31f:	83 c4 10             	add    esp,0x10
    pokech(bottomrow, leftcolumn,  192, color);
 322:	ff 75 18             	push   DWORD PTR [ebp+0x18]
 325:	68 c0 00 00 00       	push   0xc0
 32a:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 32d:	ff 75 10             	push   DWORD PTR [ebp+0x10]
 330:	e8 fc ff ff ff       	call   331 <box+0x47>
 335:	83 c4 10             	add    esp,0x10
    pokech(toprow,    leftcolumn,  218, color);
 338:	ff 75 18             	push   DWORD PTR [ebp+0x18]
 33b:	68 da 00 00 00       	push   0xda
 340:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 343:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 346:	e8 fc ff ff ff       	call   347 <box+0x5d>
 34b:	83 c4 10             	add    esp,0x10
    while (--rightcolumn > leftcolumn) {
 34e:	eb 2c                	jmp    37c <box+0x92>
        pokech(bottomrow, rightcolumn, 196, color);
 350:	ff 75 18             	push   DWORD PTR [ebp+0x18]
 353:	68 c4 00 00 00       	push   0xc4
 358:	ff 75 14             	push   DWORD PTR [ebp+0x14]
 35b:	ff 75 10             	push   DWORD PTR [ebp+0x10]
 35e:	e8 fc ff ff ff       	call   35f <box+0x75>
 363:	83 c4 10             	add    esp,0x10
        pokech(toprow,    rightcolumn, 196, color);
 366:	ff 75 18             	push   DWORD PTR [ebp+0x18]
 369:	68 c4 00 00 00       	push   0xc4
 36e:	ff 75 14             	push   DWORD PTR [ebp+0x14]
 371:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 374:	e8 fc ff ff ff       	call   375 <box+0x8b>
 379:	83 c4 10             	add    esp,0x10

    pokech(bottomrow, rightcolumn, 217, color);
    pokech(toprow,    rightcolumn, 191, color);
    pokech(bottomrow, leftcolumn,  192, color);
    pokech(toprow,    leftcolumn,  218, color);
    while (--rightcolumn > leftcolumn) {
 37c:	83 6d 14 01          	sub    DWORD PTR [ebp+0x14],0x1
 380:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 383:	3b 45 0c             	cmp    eax,DWORD PTR [ebp+0xc]
 386:	7f c8                	jg     350 <box+0x66>
        pokech(bottomrow, rightcolumn, 196, color);
        pokech(toprow,    rightcolumn, 196, color);
    }
    rightcolumn = saved_rightcolumn;
 388:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 38b:	89 45 14             	mov    DWORD PTR [ebp+0x14],eax
    while (--bottomrow > toprow) {
 38e:	eb 2c                	jmp    3bc <box+0xd2>
        pokech(bottomrow, leftcolumn,  179, color);
 390:	ff 75 18             	push   DWORD PTR [ebp+0x18]
 393:	68 b3 00 00 00       	push   0xb3
 398:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 39b:	ff 75 10             	push   DWORD PTR [ebp+0x10]
 39e:	e8 fc ff ff ff       	call   39f <box+0xb5>
 3a3:	83 c4 10             	add    esp,0x10
        pokech(bottomrow, rightcolumn, 179, color);
 3a6:	ff 75 18             	push   DWORD PTR [ebp+0x18]
 3a9:	68 b3 00 00 00       	push   0xb3
 3ae:	ff 75 14             	push   DWORD PTR [ebp+0x14]
 3b1:	ff 75 10             	push   DWORD PTR [ebp+0x10]
 3b4:	e8 fc ff ff ff       	call   3b5 <box+0xcb>
 3b9:	83 c4 10             	add    esp,0x10
    while (--rightcolumn > leftcolumn) {
        pokech(bottomrow, rightcolumn, 196, color);
        pokech(toprow,    rightcolumn, 196, color);
    }
    rightcolumn = saved_rightcolumn;
    while (--bottomrow > toprow) {
 3bc:	83 6d 10 01          	sub    DWORD PTR [ebp+0x10],0x1
 3c0:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 3c3:	3b 45 08             	cmp    eax,DWORD PTR [ebp+0x8]
 3c6:	7f c8                	jg     390 <box+0xa6>
        pokech(bottomrow, leftcolumn,  179, color);
        pokech(bottomrow, rightcolumn, 179, color);
    }
}
 3c8:	90                   	nop
 3c9:	c9                   	leave  
 3ca:	c3                   	ret    

000003cb <hcollision>:
 * also changes the input arg 'dir' if there is a collision
 * in the primary direction.
 */
int
hcollision(int row, int startcolumn, int * dirp, int len)
{
 3cb:	55                   	push   ebp
 3cc:	89 e5                	mov    ebp,esp
 3ce:	83 ec 10             	sub    esp,0x10
    int clear_to_left  = ((peekch(row, startcolumn-1) & 0xff) == ' ');
 3d1:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 3d4:	83 e8 01             	sub    eax,0x1
 3d7:	50                   	push   eax
 3d8:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 3db:	e8 fc ff ff ff       	call   3dc <hcollision+0x11>
 3e0:	83 c4 08             	add    esp,0x8
 3e3:	0f b6 c0             	movzx  eax,al
 3e6:	83 f8 20             	cmp    eax,0x20
 3e9:	0f 94 c0             	sete   al
 3ec:	0f b6 c0             	movzx  eax,al
 3ef:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax
    int clear_to_right = ((peekch(row, startcolumn+len-1) & 0xff) == ' ');
 3f2:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 3f5:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 3f8:	01 d0                	add    eax,edx
 3fa:	83 e8 01             	sub    eax,0x1
 3fd:	50                   	push   eax
 3fe:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 401:	e8 fc ff ff ff       	call   402 <hcollision+0x37>
 406:	83 c4 08             	add    esp,0x8
 409:	0f b6 c0             	movzx  eax,al
 40c:	83 f8 20             	cmp    eax,0x20
 40f:	0f 94 c0             	sete   al
 412:	0f b6 c0             	movzx  eax,al
 415:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax

    // are we good to continue?
    if ((*dirp > 0  &&  clear_to_right) || (*dirp < 0  &&  clear_to_left))
 418:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 41b:	8b 00                	mov    eax,DWORD PTR [eax]
 41d:	85 c0                	test   eax,eax
 41f:	7e 06                	jle    427 <hcollision+0x5c>
 421:	83 7d f8 00          	cmp    DWORD PTR [ebp-0x8],0x0
 425:	75 0f                	jne    436 <hcollision+0x6b>
 427:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 42a:	8b 00                	mov    eax,DWORD PTR [eax]
 42c:	85 c0                	test   eax,eax
 42e:	79 0d                	jns    43d <hcollision+0x72>
 430:	83 7d fc 00          	cmp    DWORD PTR [ebp-0x4],0x0
 434:	74 07                	je     43d <hcollision+0x72>
        return *dirp;
 436:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 439:	8b 00                	mov    eax,DWORD PTR [eax]
 43b:	eb 38                	jmp    475 <hcollision+0xaa>
    // else try the opposite direction
    *dirp = -(*dirp);
 43d:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 440:	8b 00                	mov    eax,DWORD PTR [eax]
 442:	f7 d8                	neg    eax
 444:	89 c2                	mov    edx,eax
 446:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 449:	89 10                	mov    DWORD PTR [eax],edx
    if ((*dirp > 0  &&  clear_to_right) || (*dirp < 0  &&  clear_to_left))
 44b:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 44e:	8b 00                	mov    eax,DWORD PTR [eax]
 450:	85 c0                	test   eax,eax
 452:	7e 06                	jle    45a <hcollision+0x8f>
 454:	83 7d f8 00          	cmp    DWORD PTR [ebp-0x8],0x0
 458:	75 0f                	jne    469 <hcollision+0x9e>
 45a:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 45d:	8b 00                	mov    eax,DWORD PTR [eax]
 45f:	85 c0                	test   eax,eax
 461:	79 0d                	jns    470 <hcollision+0xa5>
 463:	83 7d fc 00          	cmp    DWORD PTR [ebp-0x4],0x0
 467:	74 07                	je     470 <hcollision+0xa5>
        return *dirp;
 469:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 46c:	8b 00                	mov    eax,DWORD PTR [eax]
 46e:	eb 05                	jmp    475 <hcollision+0xaa>
    // completely blocked
    return 0;
 470:	b8 00 00 00 00       	mov    eax,0x0
}
 475:	c9                   	leave  
 476:	c3                   	ret    

00000477 <vcollision>:
/*
 * check for a vertical collision
 */
int
vcollision(int startrow, int column, int * dirp, int len)
{
 477:	55                   	push   ebp
 478:	89 e5                	mov    ebp,esp
 47a:	83 ec 10             	sub    esp,0x10
    int clear_above = ((peekch(startrow-1, column) & 0xff) == ' ');
 47d:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 480:	83 e8 01             	sub    eax,0x1
 483:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 486:	50                   	push   eax
 487:	e8 fc ff ff ff       	call   488 <vcollision+0x11>
 48c:	83 c4 08             	add    esp,0x8
 48f:	0f b6 c0             	movzx  eax,al
 492:	83 f8 20             	cmp    eax,0x20
 495:	0f 94 c0             	sete   al
 498:	0f b6 c0             	movzx  eax,al
 49b:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax
    int clear_below = ((peekch(startrow+len-1, column) & 0xff) == ' ');
 49e:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
 4a1:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 4a4:	01 d0                	add    eax,edx
 4a6:	83 e8 01             	sub    eax,0x1
 4a9:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 4ac:	50                   	push   eax
 4ad:	e8 fc ff ff ff       	call   4ae <vcollision+0x37>
 4b2:	83 c4 08             	add    esp,0x8
 4b5:	0f b6 c0             	movzx  eax,al
 4b8:	83 f8 20             	cmp    eax,0x20
 4bb:	0f 94 c0             	sete   al
 4be:	0f b6 c0             	movzx  eax,al
 4c1:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax

    // are we good to continue?
    if ((*dirp > 0  &&  clear_below) || (*dirp < 0  &&  clear_above))
 4c4:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 4c7:	8b 00                	mov    eax,DWORD PTR [eax]
 4c9:	85 c0                	test   eax,eax
 4cb:	7e 06                	jle    4d3 <vcollision+0x5c>
 4cd:	83 7d f8 00          	cmp    DWORD PTR [ebp-0x8],0x0
 4d1:	75 0f                	jne    4e2 <vcollision+0x6b>
 4d3:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 4d6:	8b 00                	mov    eax,DWORD PTR [eax]
 4d8:	85 c0                	test   eax,eax
 4da:	79 0d                	jns    4e9 <vcollision+0x72>
 4dc:	83 7d fc 00          	cmp    DWORD PTR [ebp-0x4],0x0
 4e0:	74 07                	je     4e9 <vcollision+0x72>
        return *dirp;
 4e2:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 4e5:	8b 00                	mov    eax,DWORD PTR [eax]
 4e7:	eb 38                	jmp    521 <vcollision+0xaa>
    // else try the opposite direction
    *dirp = -(*dirp);
 4e9:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 4ec:	8b 00                	mov    eax,DWORD PTR [eax]
 4ee:	f7 d8                	neg    eax
 4f0:	89 c2                	mov    edx,eax
 4f2:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 4f5:	89 10                	mov    DWORD PTR [eax],edx
    if ((*dirp > 0  &&  clear_below) || (*dirp < 0  &&  clear_above))
 4f7:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 4fa:	8b 00                	mov    eax,DWORD PTR [eax]
 4fc:	85 c0                	test   eax,eax
 4fe:	7e 06                	jle    506 <vcollision+0x8f>
 500:	83 7d f8 00          	cmp    DWORD PTR [ebp-0x8],0x0
 504:	75 0f                	jne    515 <vcollision+0x9e>
 506:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 509:	8b 00                	mov    eax,DWORD PTR [eax]
 50b:	85 c0                	test   eax,eax
 50d:	79 0d                	jns    51c <vcollision+0xa5>
 50f:	83 7d fc 00          	cmp    DWORD PTR [ebp-0x4],0x0
 513:	74 07                	je     51c <vcollision+0xa5>
        return *dirp;
 515:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 518:	8b 00                	mov    eax,DWORD PTR [eax]
 51a:	eb 05                	jmp    521 <vcollision+0xaa>
    // completely blocked
    return 0;
 51c:	b8 00 00 00 00       	mov    eax,0x0
}
 521:	c9                   	leave  
 522:	c3                   	ret    

00000523 <hthread>:

#define memcpy __builtin_memcpy

void
hthread(int thno)
{
 523:	55                   	push   ebp
 524:	89 e5                	mov    ebp,esp
 526:	83 ec 20             	sub    esp,0x20
    char blip[8];
    int row = 2 * thno + 4;
 529:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 52c:	83 c0 02             	add    eax,0x2
 52f:	01 c0                	add    eax,eax
 531:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax
    int xpos = 1;
 534:	c7 45 fc 01 00 00 00 	mov    DWORD PTR [ebp-0x4],0x1
    int xdir = 1;
 53b:	c7 45 e8 01 00 00 00 	mov    DWORD PTR [ebp-0x18],0x1
    int mdir;

    memcpy(blip, hblip, sizeof(hblip)+1);   // copy hblip to the local stack
 542:	8d 45 ec             	lea    eax,[ebp-0x14]
 545:	8b 15 00 00 00 00    	mov    edx,DWORD PTR ds:0x0
 54b:	89 10                	mov    DWORD PTR [eax],edx
 54d:	0f b7 15 04 00 00 00 	movzx  edx,WORD PTR ds:0x4
 554:	66 89 50 04          	mov    WORD PTR [eax+0x4],dx
 558:	0f b6 15 06 00 00 00 	movzx  edx,BYTE PTR ds:0x6
 55f:	88 50 06             	mov    BYTE PTR [eax+0x6],dl
    blip[2] = '0' + thno;                   // make our blip unique
 562:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 565:	83 c0 30             	add    eax,0x30
 568:	88 45 ee             	mov    BYTE PTR [ebp-0x12],al

    while (1) {
        // write new blip
        pokehstr(row, xpos, blip, CYAN);
 56b:	6a 0b                	push   0xb
 56d:	8d 45 ec             	lea    eax,[ebp-0x14]
 570:	50                   	push   eax
 571:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 574:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 577:	e8 fc ff ff ff       	call   578 <hthread+0x55>
 57c:	83 c4 10             	add    esp,0x10
        sleep(1);
 57f:	6a 01                	push   0x1
 581:	e8 fc ff ff ff       	call   582 <hthread+0x5f>
 586:	83 c4 04             	add    esp,0x4

        mdir = hcollision(row, xpos, &xdir, sizeof(hblip));
 589:	6a 06                	push   0x6
 58b:	8d 45 e8             	lea    eax,[ebp-0x18]
 58e:	50                   	push   eax
 58f:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 592:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 595:	e8 fc ff ff ff       	call   596 <hthread+0x73>
 59a:	83 c4 10             	add    esp,0x10
 59d:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax

        // blank part of old blip
        if (mdir > 0)
 5a0:	83 7d f4 00          	cmp    DWORD PTR [ebp-0xc],0x0
 5a4:	7e 14                	jle    5ba <hthread+0x97>
            pokech(row, xpos, ' ', BLACK);
 5a6:	6a 00                	push   0x0
 5a8:	6a 20                	push   0x20
 5aa:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 5ad:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 5b0:	e8 fc ff ff ff       	call   5b1 <hthread+0x8e>
 5b5:	83 c4 10             	add    esp,0x10
 5b8:	eb 1c                	jmp    5d6 <hthread+0xb3>
        else if (mdir < 0)
 5ba:	83 7d f4 00          	cmp    DWORD PTR [ebp-0xc],0x0
 5be:	79 16                	jns    5d6 <hthread+0xb3>
            pokech(row, xpos+sizeof(hblip)-2, ' ', BLACK);
 5c0:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 5c3:	83 c0 04             	add    eax,0x4
 5c6:	6a 00                	push   0x0
 5c8:	6a 20                	push   0x20
 5ca:	50                   	push   eax
 5cb:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 5ce:	e8 fc ff ff ff       	call   5cf <hthread+0xac>
 5d3:	83 c4 10             	add    esp,0x10

        xpos += mdir;
 5d6:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 5d9:	01 45 fc             	add    DWORD PTR [ebp-0x4],eax
    }
 5dc:	eb 8d                	jmp    56b <hthread+0x48>

000005de <vthread>:
}

void
vthread(int thno)
{
 5de:	55                   	push   ebp
 5df:	89 e5                	mov    ebp,esp
 5e1:	83 ec 20             	sub    esp,0x20
    char blip[8];
    int column = 4 * thno + 20;
 5e4:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 5e7:	83 c0 05             	add    eax,0x5
 5ea:	c1 e0 02             	shl    eax,0x2
 5ed:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax
    int ypos = 1;
 5f0:	c7 45 fc 01 00 00 00 	mov    DWORD PTR [ebp-0x4],0x1
    int ydir = 1;
 5f7:	c7 45 e8 01 00 00 00 	mov    DWORD PTR [ebp-0x18],0x1
    int mdir;

    memcpy(blip, vblip, sizeof(vblip)+1);   // copy vblip to the local stack
 5fe:	8d 45 ec             	lea    eax,[ebp-0x14]
 601:	8b 15 00 00 00 00    	mov    edx,DWORD PTR ds:0x0
 607:	89 10                	mov    DWORD PTR [eax],edx
 609:	0f b6 15 04 00 00 00 	movzx  edx,BYTE PTR ds:0x4
 610:	88 50 04             	mov    BYTE PTR [eax+0x4],dl
    blip[1] = '0' + thno;                   // make our blip unique
 613:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 616:	83 c0 30             	add    eax,0x30
 619:	88 45 ed             	mov    BYTE PTR [ebp-0x13],al

    while (1) {
        // write new blip
        pokevstr(ypos, column, blip, CYAN);
 61c:	6a 0b                	push   0xb
 61e:	8d 45 ec             	lea    eax,[ebp-0x14]
 621:	50                   	push   eax
 622:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 625:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 628:	e8 fc ff ff ff       	call   629 <vthread+0x4b>
 62d:	83 c4 10             	add    esp,0x10
        sleep(1);
 630:	6a 01                	push   0x1
 632:	e8 fc ff ff ff       	call   633 <vthread+0x55>
 637:	83 c4 04             	add    esp,0x4

        mdir = vcollision(ypos, column, &ydir, sizeof(vblip));
 63a:	6a 04                	push   0x4
 63c:	8d 45 e8             	lea    eax,[ebp-0x18]
 63f:	50                   	push   eax
 640:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 643:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 646:	e8 fc ff ff ff       	call   647 <vthread+0x69>
 64b:	83 c4 10             	add    esp,0x10
 64e:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax

        // blank part of old blip
        if (mdir > 0)
 651:	83 7d f4 00          	cmp    DWORD PTR [ebp-0xc],0x0
 655:	7e 14                	jle    66b <vthread+0x8d>
            pokech(ypos, column, ' ', BLACK);
 657:	6a 00                	push   0x0
 659:	6a 20                	push   0x20
 65b:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 65e:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 661:	e8 fc ff ff ff       	call   662 <vthread+0x84>
 666:	83 c4 10             	add    esp,0x10
 669:	eb 1c                	jmp    687 <vthread+0xa9>
        else if (mdir < 0)
 66b:	83 7d f4 00          	cmp    DWORD PTR [ebp-0xc],0x0
 66f:	79 16                	jns    687 <vthread+0xa9>
            pokech(ypos+sizeof(vblip)-2, column, ' ', BLACK);
 671:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 674:	83 c0 02             	add    eax,0x2
 677:	6a 00                	push   0x0
 679:	6a 20                	push   0x20
 67b:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 67e:	50                   	push   eax
 67f:	e8 fc ff ff ff       	call   680 <vthread+0xa2>
 684:	83 c4 10             	add    esp,0x10

        ypos += mdir;
 687:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 68a:	01 45 fc             	add    DWORD PTR [ebp-0x4],eax
    }
 68d:	eb 8d                	jmp    61c <vthread+0x3e>

0000068f <main>:
}

int
main(void)
{
 68f:	55                   	push   ebp
 690:	89 e5                	mov    ebp,esp
 692:	83 ec 10             	sub    esp,0x10
    int i;
    int ncpus;

    map_vga_memory();
 695:	e8 fc ff ff ff       	call   696 <main+0x7>
  
    //  0x1000 = ncpus
    ncpus = syscall0(0x1000);
 69a:	68 00 10 00 00       	push   0x1000
 69f:	e8 fc ff ff ff       	call   6a0 <main+0x11>
 6a4:	83 c4 04             	add    esp,0x4
 6a7:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax

//    // testvga only has room for 16 stacks ...
//    if (ncpus > MAX_THREADS)
//        ncpus = MAX_THREADS;

    pokehstr(1, 1, "using", YELLOW);
 6aa:	6a 0e                	push   0xe
 6ac:	68 0c 00 00 00       	push   0xc
 6b1:	6a 01                	push   0x1
 6b3:	6a 01                	push   0x1
 6b5:	e8 fc ff ff ff       	call   6b6 <main+0x27>
 6ba:	83 c4 10             	add    esp,0x10
    pokehstr(1, 9, "of", YELLOW);
 6bd:	6a 0e                	push   0xe
 6bf:	68 12 00 00 00       	push   0x12
 6c4:	6a 09                	push   0x9
 6c6:	6a 01                	push   0x1
 6c8:	e8 fc ff ff ff       	call   6c9 <main+0x3a>
 6cd:	83 c4 10             	add    esp,0x10
    // ... but we know the kernel can only handle 8 threads right now
    i = 13;
 6d0:	c7 45 fc 0d 00 00 00 	mov    DWORD PTR [ebp-0x4],0xd
    if (ncpus > 8) {
 6d7:	83 7d f8 08          	cmp    DWORD PTR [ebp-0x8],0x8
 6db:	7e 1d                	jle    6fa <main+0x6b>
        i += pokehint(1, 12, ncpus, YELLOW);
 6dd:	6a 0e                	push   0xe
 6df:	ff 75 f8             	push   DWORD PTR [ebp-0x8]
 6e2:	6a 0c                	push   0xc
 6e4:	6a 01                	push   0x1
 6e6:	e8 fc ff ff ff       	call   6e7 <main+0x58>
 6eb:	83 c4 10             	add    esp,0x10
 6ee:	01 45 fc             	add    DWORD PTR [ebp-0x4],eax
        ncpus = 8;
 6f1:	c7 45 f8 08 00 00 00 	mov    DWORD PTR [ebp-0x8],0x8
 6f8:	eb 19                	jmp    713 <main+0x84>
    } else {
        pokech(1, 12, '0'+ncpus, YELLOW);
 6fa:	8b 45 f8             	mov    eax,DWORD PTR [ebp-0x8]
 6fd:	83 c0 30             	add    eax,0x30
 700:	6a 0e                	push   0xe
 702:	50                   	push   eax
 703:	6a 0c                	push   0xc
 705:	6a 01                	push   0x1
 707:	e8 fc ff ff ff       	call   708 <main+0x79>
 70c:	83 c4 10             	add    esp,0x10
        i++;
 70f:	83 45 fc 01          	add    DWORD PTR [ebp-0x4],0x1
    }
    pokehstr(1, i, "cpus", YELLOW);
 713:	6a 0e                	push   0xe
 715:	68 15 00 00 00       	push   0x15
 71a:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 71d:	6a 01                	push   0x1
 71f:	e8 fc ff ff ff       	call   720 <main+0x91>
 724:	83 c4 10             	add    esp,0x10
    pokech(1, 7, '0'+ncpus, YELLOW);
 727:	8b 45 f8             	mov    eax,DWORD PTR [ebp-0x8]
 72a:	83 c0 30             	add    eax,0x30
 72d:	6a 0e                	push   0xe
 72f:	50                   	push   eax
 730:	6a 07                	push   0x7
 732:	6a 01                	push   0x1
 734:	e8 fc ff ff ff       	call   735 <main+0xa6>
 739:	83 c4 10             	add    esp,0x10

    // create boundaries for blips
    box(0, 0, HEIGHT-1, WIDTH-1, GRAY);
 73c:	6a 08                	push   0x8
 73e:	6a 4f                	push   0x4f
 740:	6a 12                	push   0x12
 742:	6a 00                	push   0x0
 744:	6a 00                	push   0x0
 746:	e8 fc ff ff ff       	call   747 <main+0xb8>
 74b:	83 c4 14             	add    esp,0x14

    for (i = 1; i < ncpus; i++) {
 74e:	c7 45 fc 01 00 00 00 	mov    DWORD PTR [ebp-0x4],0x1
 755:	eb 30                	jmp    787 <main+0xf8>
        if (i & 1)
 757:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 75a:	83 e0 01             	and    eax,0x1
 75d:	85 c0                	test   eax,eax
 75f:	74 12                	je     773 <main+0xe4>
            new_thread(vthread, i);
 761:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 764:	68 00 00 00 00       	push   0x0
 769:	e8 fc ff ff ff       	call   76a <main+0xdb>
 76e:	83 c4 08             	add    esp,0x8
 771:	eb 10                	jmp    783 <main+0xf4>
        else
            new_thread(hthread, i);
 773:	ff 75 fc             	push   DWORD PTR [ebp-0x4]
 776:	68 00 00 00 00       	push   0x0
 77b:	e8 fc ff ff ff       	call   77c <main+0xed>
 780:	83 c4 08             	add    esp,0x8
    pokech(1, 7, '0'+ncpus, YELLOW);

    // create boundaries for blips
    box(0, 0, HEIGHT-1, WIDTH-1, GRAY);

    for (i = 1; i < ncpus; i++) {
 783:	83 45 fc 01          	add    DWORD PTR [ebp-0x4],0x1
 787:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 78a:	3b 45 f8             	cmp    eax,DWORD PTR [ebp-0x8]
 78d:	7c c8                	jl     757 <main+0xc8>
        else
            new_thread(hthread, i);
    }

    // main is thread 0
    hthread(0);
 78f:	6a 00                	push   0x0
 791:	e8 fc ff ff ff       	call   792 <main+0x103>
 796:	83 c4 04             	add    esp,0x4
 799:	b8 00 00 00 00       	mov    eax,0x0

    // no return
}
 79e:	c9                   	leave  
 79f:	c3                   	ret    

000007a0 <_start>:
                            (u64)&_end, (u64)&_start
#endif
                            };
void
_start(void)
{
 7a0:	55                   	push   ebp
 7a1:	89 e5                	mov    ebp,esp
//  asm("    finit;      \n");      // include if using floating point
    asm("    call main;  \n");
 7a3:	e8 fc ff ff ff       	call   7a4 <_start+0x4>
    asm("1:  iret;       \n");
 7a8:	cf                   	iret   
    asm("    jmp 1;      \n");
 7a9:	e9 fd ff ff ff       	jmp    7ab <_start+0xb>
}
 7ae:	90                   	nop
 7af:	5d                   	pop    ebp
 7b0:	c3                   	ret    
